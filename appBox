#!/bin/env python3

import argparse
import fcntl
import json
import logging
import os
import pty
import pwd
import select
import shutil
import stat
import struct
import subprocess
import sys
import tarfile
import termios
import time
import tty
import urllib.request
import uuid

# Global Logger
appLogger = None

appBoxVersion = '2.0.0'


def getUN():
    '''
    Return the username of this account
    '''
    return pwd.getpwuid(os.getuid())[0]


def getHome():
    '''
    Return the home directory of this account
    '''
    return pwd.getpwuid(os.getuid())[5]


class ImageSource():

    def __init__(self, defaultCacheDir=None):
        if defaultCacheDir:
            self.imageCacheDir = defaultCacheDir
        else:
            self.imageCacheDir = '/tmp/appBox_{}'.format(getUN())

    def writeContainerInfo(self, _file, image, tag):

        appBox_metaData = { '__version__': appBoxVersion,
                            'containerName': '{}://{}:{}'.format(self.proto, image, tag),
                            'installedTime': '{}'.format(str(time.time())),
                          }
        json.dump(appBox_metaData, _file, ensure_ascii=True, indent=2)

    def dumpContainerInfo(self, metaData):

        with open(metaData, 'r') as _file:
            appBoxData = json.loads(_file.read())

        appLogger.info(appBoxData)

    def getArch(self):

        ## TODO add logic to determine correct string for each arch based on running system
        return 'amd64'


class DockerHub(ImageSource):

    def __init__(self, defaultCacheDir=None, should_cleanup=False):

        ImageSource.__init__(self, defaultCacheDir)

        # Cached tokens during this instance
        self.token = {}

        self.docker_auth = "auth.docker.io"
        self.docker_auth_service = "registry.docker.io"
        self.docker_reg = "registry-1.docker.io"
        self.image_pre = "library"

        self._should_cleanup = bool(should_cleanup)

        self.proto = 'docker'

    def _getImageStr(self, image):

        image_pre = self.image_pre
        image_split = image.split('/')
        if len(image_split) > 1:
            image_pre = image_split[0]
            image = image_split[1]
        return image_pre, image

    def checkToken(self, token, image):
        '''
        Just try to list the manifest and return based on the authenticated or not
        '''
        try:
            image_pre, image = self._getImageStr(image)
            _ = urllib.request.urlopen(urllib.request.Request(
                    "https://{}/v2/{}/{}/manifests/{}".format(self.docker_reg, image_pre, image, "latest")
                )).read()
            return True
        except:
            return False

    def getToken(self, image):

        if image in self.token:
            this_token = self.token[image]
            if self.checkToken(this_token, image):
                return this_token

        image_pre, image = self._getImageStr(image)

        appLogger.debug("Querying: https://{}/token?service={}&scope=repository:{}/{}:pull".format(self.docker_auth, self.docker_auth_service,
                                                                               image_pre, image))
        token_response = urllib.request.urlopen(urllib.request.Request(
            "https://{}/token?service={}&scope=repository:{}/{}:pull".format(self.docker_auth, self.docker_auth_service,
                                                                             image_pre, image),
            #    headers={"Accept" : ''}
        )).read()
        #appLogger.debug('Requested token for "{}", received: "{}"'.format(image, token_response))

        token = json.loads(token_response.decode())['token']

        self.token[image] = token

        return self.token[image]

    def getDigest(self, manifest, image):

        appLogger.debug('Manifest: {}'.format(manifest))

        digest_list = []

        ## '.fsLayers[]' | jq -r '.blobSum'
        ## Read the blobSum and return

        ## '.layers[0]' | jq -r '.digest'
        ## Read the digest from the layers and return
        if 'layers' in manifest:
            for this_layer in manifest['layers']:
                digest_list.append({'mediaType': this_layer['mediaType'],
                                    'digest': this_layer['digest']})

        ## '.manifest[0]' | jq -r '.digest'
        ## Read the manifest, get the correct digests and return
        elif 'manifests' in manifest:
            this_arch = self.getArch()
            for _manifest in manifest['manifests']:
                if _manifest['platform']['architecture'] == this_arch:
                    this_csum = _manifest['digest']

                    token = self.getToken(image)
                    _headers = self.getHeaders(token, "application/vnd.oci.image.manifest.v1+json")

                    manifest_response = self.getManifests(image, this_csum, _headers)

                    manifest_json = json.loads(manifest_response)

                    digest_list = self.getDigest(manifest_json, image)

                    break

        #raise Exception('here')
        return digest_list

    def _assembleImage(self, image_layers, output_image):

        ## Perform logic to assemble layers into single compressed image

        appLogger.debug('Image Layers: {}'.format(image_layers))

        tmpFolder = os.path.join(self.imageCacheDir, 'appBox_tmpFolder_{}'.format(str(uuid.uuid4())[:8]))
        os.makedirs(tmpFolder)

        for layer in image_layers:
            if layer['mediaType'] in ['application/vnd.docker.image.rootfs.diff.tar.gzip',
                                      'application/vnd.oci.image.layer.v1.tar+gzip']:
                ## TODO add a tarfile filter to catch (bad image) failing mknod errors
                ## This should probably be done by a filter as we 'care' about some errors we're silencing here
                ## See Ubuntu:16.04 if you can still find it...
                with tarfile.open(layer['cacheFile'], errorlevel=0) as _tfile:
                    _tfile.extractall(tmpFolder)

        for (root, dirs, files) in os.walk(tmpFolder, topdown=True):
            for _dir in dirs:
                this_path = os.path.join(root,_dir)
                if not os.path.islink(this_path):
                    current = stat.S_IMODE(os.lstat(this_path).st_mode)
                    os.chmod(this_path, current | stat.S_IWUSR | stat.S_IRUSR | stat.S_ISGID)
            for _file in files:
                this_path = os.path.join(root,_file)
                if not os.path.islink(this_path):
                    current = stat.S_IMODE(os.lstat(this_path).st_mode)
                    os.chmod(os.path.join(root,_file), current | stat.S_IWUSR | stat.S_IRUSR)

        with tarfile.open(output_image, "w|gz") as tar:
            contents = os.listdir(tmpFolder)
            for _obj in contents:
                tar.add(os.path.join(tmpFolder,_obj), arcname=_obj)

        shutil.rmtree(tmpFolder)

        return output_image

    def cacheImage(self, image, tag):

        return os.path.join(self.imageCacheDir, 'appBox_{}_{}.compressed'.format(image, tag))

    def getHeaders(self, token, accept="application/vnd.docker.distribution.manifest.v2+json"):

        return {"Accept": accept,
                 "Authorization": "Bearer {}".format(token),
                 "Content-Type": "application/json",
                 "User-Agent": "curl/8.0.1"}

    def getManifests(self, image, tag, _headers):
        appLogger.debug('Request Headers: {}'.format(_headers))

        image_pre, image = self._getImageStr(image)

        appLogger.debug("Querying: https://{}/v2/{}/{}/manifests/{}".format(self.docker_reg, image_pre, image, tag))

        return urllib.request.urlopen(urllib.request.Request(
            "https://{}/v2/{}/{}/manifests/{}".format(self.docker_reg, image_pre, image, tag),
            headers = _headers,
        )).read()

    def pullContainer(self, image, tag):

        image_pre, image_sub = self._getImageStr(image)
        output_image = self.cacheImage(image_sub, tag)

        if os.path.isfile(output_image):
            appLogger.info('Output Image: "{}" found for image: "{}", tag: "{}"'.format(output_image, image, tag))
            return
        else:
            appLogger.info('Pulling Image for: {}:{}'.format(image, tag))

        token = self.getToken(image)

        _headers = self.getHeaders(token)

        appLogger.debug('Request Headers: {}'.format(_headers))
        appLogger.debug("Querying: https://{}/v2/{}/{}/manifests/{}".format(self.docker_reg, self.image_pre, image, tag))

        try:
            manifest_response = self.getManifests(image, tag, _headers)
        except Exception as err:
            appLogger.error('Failed to get manifest for image: "{}", tag: "{}"'.format(image, tag))
            appLogger.error('Error: {}'.format(err))
            sys.exit(201)

        manifest_json = json.loads(manifest_response)

        this_digest_list = self.getDigest(manifest_json, image)

        def checkOutputLocation(outputDir):
            if not os.path.exists(outputDir):
                appLogger.debug('Creating output directory: {}'.format(outputDir))
                os.makedirs(outputDir)

        checkOutputLocation(self.imageCacheDir)

        image_layers = []

        image_pre, image = self._getImageStr(image)

        for this_digest in this_digest_list:

            output_cache = '{}_{}_{}.digest'.format(this_digest['digest'], image, tag)
            output_cache = os.path.join(self.imageCacheDir, output_cache)
            image_layers.append({'mediaType': this_digest['mediaType'],
                                 'cacheFile': output_cache,
                                 'digest': this_digest['digest']})

            appLogger.debug('Downloading Layer: {}'.format(this_digest['digest']))
            with urllib.request.urlopen(urllib.request.Request(
                "https://{}/v2/{}/{}/blobs/{}".format(self.docker_reg, image_pre,
                                                      image, this_digest['digest']),
                headers = _headers)) as request_data:

                with open(output_cache, 'wb+') as _file:
                    while True:
                        chunk = request_data.read(32 * 1024)
                        if not chunk:
                            break
                        _file.write(chunk)

        assembled_image = self._assembleImage(image_layers, output_image)
        
        appLogger.info('Image assembled at: {}'.format(assembled_image))

        #def cleanUp(to_be_removed):
        #    ## Loop through and unlink un-needed layer and compressed layer versions
        #    while _file in to_be_removed:
        #        os.unlink(_file)

        if self._should_cleanup:
            for _layer in image_layers:
                os.unlink(_layer['cacheFile'])

    def buildSandbox(self, image, tag, dest):

        appBox_file = os.path.join(dest, '._appBoxContainer')

        _, img = self._getImageStr(image)

        this_image = self.cacheImage(img, tag)

        if not os.path.exists(this_image):
            appLogger.error('Expected to find (cached) image at: "{}", for image: "{}", tag: "{}".'.format(this_image, image, tag))
            appLogger.error('Did you forget to pull first?')
            return

        if not os.path.exists(dest):
            os.makedirs(dest)
        else:
            if os.path.exists(appBox_file):
                appLogger.info('Found appBox sandbox at: {}'.format(dest))
                self.dumpContainerInfo(appBox_file)
                return

        appLogger.info('Extracting Compressed Image.')
        with tarfile.open(this_image) as _tfile:
            _tfile.extractall(dest)

        appLogger.info('Writing metaData.')
        with open(appBox_file, 'w+') as _file:
            self.writeContainerInfo(_file, image, tag)


class sandboxFixes():
    
    def __init__(self, sandboxPath, addNV):
        
        self.sandboxPath = sandboxPath
        self.addNvidia = addNV
    
    def applyAllFixes(self):
        
        self.fixFilePermissions()
        self.fixAptSandboxing()
        self.fixMissingPaths()
        self.fixMissingStubs()
        self.fixUserAccounts()
        self.fixAliases()
        self.fixEnvironment()
        self.installAppBox()
        
    def fixFilePermissions(self):
        '''
        Fix the permissions of a given path
        '''
        for root, dirs, files in os.walk(self.sandboxPath, topdown=True):
            for _dir in dirs:
                this_path = os.path.join(root,_dir)
                if not os.path.islink(this_path):
                    current = stat.S_IMODE(os.lstat(this_path).st_mode)
                    os.chmod(this_path, current | stat.S_IWUSR | stat.S_IRUSR | stat.S_ISGID)
            for _file in files:
                this_path = os.path.join(root,_file)
                if not os.path.islink(this_path):
                    current = stat.S_IMODE(os.lstat(this_path).st_mode)
                    os.chmod(os.path.join(root,_file), current | stat.S_IWUSR | stat.S_IRUSR)

    def _getPathList(self):
        '''
        '''
        base_path_list = ['/dev', '/etc', '/cvmfs', '/scratch', '/Data', '/localdisk', '/sys', '/tmp', '/home']
        
        if self.addNvidia:
            base_path_list.append('/usr/lib/wsl')
            
        return base_path_list        

    def fixMissingPaths(self):
        '''
        '''
        needed_sandbox_paths = self._getPathList()
        
        abs_paths = []
        for _path in needed_sandbox_paths:
            abs_paths.append(os.path.abspath(os.path.join(self.sandboxPath, '.'+_path)))

        for _path in abs_paths:
            if not os.path.exists(_path):
                os.makedirs(_path)

    def _getStubList(self):
        '''
        '''
        base_stubs = ['/etc/resolv.conf', '/etc/localtime', '/etc/hostname']
        
        if self.addNvidia:
            base_stubs.append('/usr/bin/nvidia-smi')
            base_stubs.append('/usr/bin/nvidia-modprobe')

        return base_stubs

    def fixMissingStubs(self):
        '''
        Create the stubs needed for the sandbox
        '''
        needed_stubs = self._getStubList()
        
        abs_paths = []
        for _path in needed_stubs:
            abs_paths.append(os.path.abspath(os.path.join(self.sandboxPath, '.'+_path)))
            
        for _path in abs_paths:
            if not os.path.exists(_path):
                with open(_path, 'a'):
                    os.utime(_path, None)

    def getAnonUIDGID(self):
        # TODO work out if we need to detect/change this
        return (65534, 65534)

    def fixUserAccounts(self):
        '''
        Fix the user accounts within the sandbox
        '''
        self._fixPasswd()
        self._fixGroup()

    def _fixPasswd(self):
        '''
        '''
        with open(os.path.join(self.sandboxPath, './etc/passwd'), 'r') as _file:
            _content = _file.read()
            appLogger.debug('Content: "{}"'.format(_content))
        
        new_content = 'root:x:0:0:root:/root:/bin/bash\n'
        new_content += '{}:x:65534:65534:{}:{}:/bin/bash\n'.format(getUN(),getUN(),getHome())

        a_uid, a_gid = self.getAnonUIDGID()

        for _line in _content.split('\n'):
            if _line:
                _user, _, _uid, _gid, _name, _home, _shell = _line.split(':')
                if _user in ['root', getUN()]:
                    continue
                appLogger.debug('User: "{}", UID: "{}", GID: "{}", Name: "{}", Home: "{}", Shell: "{}"'.format(
                                    _user, _uid, _gid, _name, _home, _shell))
                
                new_content += '{}:x:{}:{}:{}:{}:{}\n'.format(_user, a_uid, a_gid, _name, _home, _shell)

        with open(os.path.join(self.sandboxPath, './etc/passwd'), 'w+') as _file:
            _file.write(new_content)
    
    def _fixGroup(self):
        '''
        '''
        with open(os.path.join(self.sandboxPath, './etc/group'), 'r') as _file:
            _content = _file.read()
            appLogger.debug('Content: "{}"'.format(_content))

        _, a_gid = self.getAnonUIDGID()

        new_content = 'root:x:0:\n'
        new_content += '{}:x:{}:\n'.format(getUN(), a_gid)
        
        for _line in _content.split('\n'):
            if _line:
                _group, _, _gid, _users = _line.split(':')
                if _group in ['root', getUN()]:
                    continue
                appLogger.debug('Group: "{}", GID: "{}", Users: "{}"'.format(_group, _gid, _users))

                new_content += '{}:x:{}:{}\n'.format(_group, a_gid, _users)
                
        with open(os.path.join(self.sandboxPath, './etc/group'), 'w+') as _file:
            _file.write(new_content)
    
    def fixAliases(self):
        
        def fixDeactivate():
            deac_script = os.path.join(self.sandboxPath, 'etc/profile.d/deac.sh')
            with open(deac_script, 'w+') as _file:
                _file.write('alias deactivate=exit')

            st = os.stat(deac_script)
            os.chmod(deac_script, st.st_mode | stat.S_IEXEC)

        fixDeactivate()
    
    def fixEnvironment(self):
        
        if self.addNvidia:
            with open(os.path.join(self.sandboxPath, './etc/ld.so.conf.d/ld.wsl.conf')) as _file:
                _file.write('/usr/lib/wsl/lib')

    def fixAptSandboxing(self):
        '''
        Fix issues related to installing packages on Debian in a single-user-sandbox...
        '''
        app_conf_path = os.path.join(self.sandboxPath, './etc/apt/apt.conf.d/')

        if os.path.exists(app_conf_path):
            # Only want to apply this 'fix' in sandboxes where apt is installed

            fix_apt  = 'APT::Sandbox::User "root";\nAPT::Sandbox::Verify "0";\n'
            fix_apt += 'APT::Sandbox::Verify::IDs "0";\nAPT::Sandbox::Verify::Groups "0";\n'
            fix_apt += 'APT::Sandbox::Verify::Regain "0";'

            with open(os.path.join(app_conf_path, 'sandbox-disable'), 'w+') as _file:
                _file.write(fix_apt)

    def installAppBox(self):
        '''
        Install the appBox tool into the sandbox
        '''
        currentInstance = os.path.abspath(__file__)
        with open(currentInstance, 'r') as _file:
            _content = _file.read()
        installInstance = os.path.join(self.sandboxPath, './bin/appBox')
        with open(installInstance, 'w+') as _file:
            _file.write(_content)
            
        activate_script = """#!/bin/bash

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

/bin/env python3 ./appBox -l ${SCRIPT_DIR}/../ -ra"""
        activatePath = os.path.join(self.sandboxPath, './bin/activate')
        with open(activatePath, 'w+') as _file:
            _file.write(activate_script)

        for _file in [installInstance, activatePath, ]:
            st = os.stat(_file)
            os.chmod(_file, st.st_mode | stat.S_IEXEC)


class sessionManager():

    def __init__(self, sandboxPath, compatV1=False, addNV=False):
        '''
        Standard __init__ :)
        '''
        self.proc = None
        self.pid_parent = None
        self.pid_child = None
        self.old_i_tty = None
        self.sandboxPath = sandboxPath
        self.compatV1 = compatV1
        self.addNvidia = addNV

    def _wrangle_tty(self):
        '''
        This is some boiler-plate for setting up a pTTY
        '''

        # save original tty setting then set it to raw mode
        old_i_tty = termios.tcgetattr(sys.stdin)
        tty.setraw(sys.stdin.fileno())

        # open pseudo-terminal to interact with subprocess
        stdout_m_fd, stdout_s_fd = pty.openpty()

        size = os.get_terminal_size()
        winsize = struct.pack("HHHH", size[1], size[0], 0, 0)
        fcntl.ioctl(stdout_m_fd, termios.TIOCSWINSZ, winsize)

        appLogger.debug('Opening PTY')

        self.old_i_tty = old_i_tty
        self.stdout_m, self.stdout_s = stdout_m_fd, stdout_s_fd

    def setupHostSpace(self):
        '''
        This sets up a 'root' namespace.
        This persists for the lifetime of this shell.
        '''

        background_task='/bin/bash'
        self.proc = subprocess.Popen("unshare -primf --propagation unchanged {}".format(background_task),
                                     shell=True, preexec_fn=os.setsid,
                                     stdin = subprocess.PIPE,
                                     stdout = subprocess.PIPE,
                                     stderr = subprocess.PIPE,
                                     universal_newlines = True)

        appLogger.debug('Host sandbox namespace: {}'.format(self.proc.pid))
        self.pid_parent=self.proc.pid
        time.sleep(0.1)

        parentID = self.pid_parent
        childID = parentID
        while True:

            appLogger.debug('Parent PID: {}'.format(parentID))
            appLogger.debug('Child PID: {}'.format(childID))
            try:
                parentID, childID = self.getChildID(childID)
                self.pid_child = childID
            except:
                break
            time.sleep(0.1)

            appLogger.debug('---')

        return self.pid_parent, self.pid_child

    def getChildID(self, this_pid):

        child_pid_path = '/proc/{}/task/{}/children'.format(this_pid, this_pid)
        appLogger.debug('Querying: {}'.format(child_pid_path))
        with open(child_pid_path, 'r') as _file:
            _content = _file.read()
            appLogger.debug('Content: "{}"'.format(_content))
            child_pid = int(_content)
            appLogger.debug('PID: {}'.format(child_pid))

        return this_pid, child_pid

    def getSharePaths(self):
        '''
        This is a list of directories to be mounted into the sandbox from the host
        '''
        mounts = ['/home', '/tmp', '/dev', '/etc/resolv.conf', '/cvmfs', '/scratch', '/Data', '/localdisk', '/sys', '/etc/localtime',]
        if self.addNvidia:
            mounts += ['/usr/lib/wsl', '/usr/bin/nvidia-smi', '/usr/bin/nvidia-modprobe']
        return mounts

    def mountHost(self):
        '''
        Mount the shared paths between the host and the sandbox namespace
        '''
        host_mounts = self.getSharePaths()

        for host_path in host_mounts:

            sandbox_path = os.path.abspath(os.path.join(self.sandboxPath, '.'+host_path))

            if not os.path.exists(host_path):
                appLogger.info('Skipping path {}, as it doesn\'t exist on the host'.format(host_path))
                continue
            if not os.path.exists(sandbox_path):
                appLogger.info('Skipping path {}, as it doesn\'t exist on the guest'.format(sandbox_path))
                continue

            appLogger.debug('Bind Mounting: {} as: {}'.format(host_path, sandbox_path))

            mount_proc = subprocess.Popen(
                            'nsenter --preserve-credentials --user --mount --pid -t {} mount --rbind --make-rslave {} {}'.format(
                                self.pid_child, host_path, sandbox_path),
                            stdin = subprocess.PIPE,
                            stdout = subprocess.PIPE,
                            stderr = subprocess.PIPE,
                            shell=True)

            del mount_proc

    def cleanupSpaces(self):
        '''
        Cleanup the 'persistent' spaces which have been created
        '''
        # restore tty settings back
        os.write(sys.stdin.fileno(), '\n\r'.encode())
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.old_i_tty)
        sys.stdin.flush()
        sys.stdout.flush()
        del self.proc
        self.proc = None

    def setupSubSpace(self, asRoot):
        '''
        Create a subSpace within the root space of the host
        '''
        appLogger.debug('Setting up SubSpace')

        chroot_cmd = self._getSandboxCmd(None, asRoot)

        self.proc2 = subprocess.Popen(chroot_cmd,
                                     shell=True, preexec_fn=os.setsid,
                                     stdin = subprocess.PIPE,
                                     stdout = subprocess.PIPE,
                                     stderr = subprocess.PIPE,
                                     universal_newlines = True)

        appLogger.debug('PID of subSpace: {}'.format(self.proc2.pid))

        self.pid_subParent=self.proc2.pid

        time.sleep(0.1)

        with open('/proc/{}/task/{}/children'.format(self.pid_subParent, self.pid_subParent), 'r') as _file:
            self.pid_subChild=int(_file.read())
            appLogger.debug('Child PID: {}'.format(self.pid_subChild))

        return (self.pid_subParent, self.pid_subChild)

    def _getSandboxCmd(self, command=None, asRoot=False):

        if command is None:
            command = '"/bin/bash -l"'
    
        if not self.compatV1:
            # Continue as Normal and use good hosts unshare
            if asRoot:
                chroot_cmd = 'bash -c \'unshare -priUmf --mount --mount-proc -R {} --propagation=unchanged bash -c {};\' exit $?'.format(self.sandboxPath, command)
            else:
                chroot_cmd = 'bash -c \'unshare -piUmf --mount --mount-proc -R {} --propagation=unchanged bash -c {};\' exit $?'.format(self.sandboxPath, command)
        else:
            # Use the older compatibility mode for the sandbox, use chroot and drop the '-R' unshare arg...
            # TBF for HEP it was clear as day AL9 wa going to be the way forward in 202x, but some people are still on CO8/R8... _sigh_ ...
            if asRoot:
                chroot_cmd = 'bash -c \'unshare -priUmf --mount --mount-proc --propagation=unchanged chroot {} bash -c {};\' exit $?'.format(self.sandboxPath, command)
            else:
                chroot_cmd = 'bash -c \'unshare -piUmf --mount --mount-proc --propagation=unchanged chroot {} bash -c {};\' exit $?'.format(self.sandboxPath, command)
    
        return chroot_cmd

    def runCommand(self, command, asRoot=False):
        '''
        '''        

        chroot_cmd = self._getSandboxCmd(command, asRoot)

        appLogger.debug('About to execute')
        ns_cmd = 'nsenter --preserve-credentials --user --mount --pid -t {} {} ; exit $?;'
        appLogger.debug(ns_cmd.format(self.pid_child, chroot_cmd))

        self._wrangle_tty()
        interactive_proc = subprocess.Popen(
                                ns_cmd.format(self.pid_child, chroot_cmd),
                                stdin = self.stdout_s,
                                stdout = self.stdout_s,
                                stderr = self.stdout_s,
                                shell = True, universal_newlines = True, preexec_fn=os.setsid
                                )


        readable = [sys.stdin, self.stdout_m]
        while True:

            self.running = True
            should_continue = self._shell_fwd_bck(interactive_proc, readable)

            if not should_continue:
                break
        self.running=False

        rc = interactive_proc.poll()
        
        appLogger.debug('Return Code: {}'.format(rc))

        return rc

    def runInteractive(self, asRoot=True):
        '''
        Launch an interactive sandbox with a shell within the 'root' sandbox namespace of the host
        '''
        #self.setupSubSpace(asRoot)
        #chroot_cmd = '/bin/bash -l'

        shell="/bin/bash -l"
        #shell="bash -c '/bin/bash -i; echo $?'"
        #shell='bash -c "/bin/bash -l;" exit $?'
        #shell='bash -c "exit 100"; exit $?'
        #if asRoot:
        #    chroot_cmd = 'bash -c \'unshare -priUmf --mount-proc -R {} --propagation=unchanged {};\' exit $?'.format(self.sandboxPath, shell)
        #else:
        #    chroot_cmd = 'bash -c \'unshare -piUmf --mount-proc -R {} --propagation=unchanged {};\' exit $?'.format(self.sandboxPath, shell)


        ## Keeping CO8 compatability because not everyone could read the writing on the wall with regard to Rocky vs Alma vs Oracle vs IBM re CERN/Fermilab...
        chroot_cmd = self._getSandboxCmd(asRoot=asRoot)

        appLogger.info('About to enter namespace.')
        ns_cmd = 'nsenter --preserve-credentials --user --mount --pid -t {} {} ; exit $?;'
        appLogger.info(ns_cmd.format(self.pid_child, chroot_cmd))

        #time.sleep(300)

        self._wrangle_tty()
        interactive_proc = subprocess.Popen(
                                ns_cmd.format(self.pid_child, chroot_cmd),
                                stdin = self.stdout_s,
                                stdout = self.stdout_s,
                                stderr = self.stdout_s,
                                shell = True, universal_newlines = True, preexec_fn=os.setsid
                                )


        readable = [sys.stdin, self.stdout_m]
        while True:

            self.running = True
            should_continue = self._shell_fwd_bck(interactive_proc, readable)

            if not should_continue:
                break
        self.running=False

        rc = interactive_proc.poll()
        
        appLogger.debug('Return Code: {}'.format(rc))

        return rc

    def procState(self, pid):
        '''
        Return the state of a given PID in linux
        '''
        # Only on Linux
        for _line in open("/proc/%d/status" % pid).readlines():
            if _line.startswith("State:"):
                entry = _line.split(":")[1].strip()
                value = entry.rstrip()[0]
                return value
        # Unknown
        return 'E'

    def _shell_fwd_bck(self, interactive_proc, readable):
        '''
        This is the component for handling sending data in/out of the pty
        '''

        # If the process is unknown or in a zombie state
        if self.procState(interactive_proc.pid) in ['Z', 'E']:
            try:
                #os.kill(pid)
                pass
            except:
                pass
            return False

	    # Poll for input/output
        if interactive_proc and interactive_proc.poll() is None:
            r, w, e = select.select(readable, [], [], 0.01)

            for _in in r:
                if _in is sys.stdin:
                    d = os.read(sys.stdin.fileno(), 10240)
                    #if d.decode() in ['\x04',]:
                    #    self._should_stop = True
                    #    return False
                    os.write(self.stdout_m, d)
                elif _in is self.stdout_m:
                    try:
                        o = os.read(self.stdout_m, 10240)
                    except OSError as e:
                        return False
                    if o:
                        os.write(sys.stdout.fileno(), o)
                else:
                    raise Exception('Help')
            return True
        else:
            return False


class appBoxManager():
    
    def setLogLevel(level):

        global appLogger
        appLogger = logging.getLogger('appBox')

        logging.basicConfig(level=level, format='%(message)s')
        appLogger.setLevel(level)
        for handler in appLogger.handlers:
            handler.setLevel(level)


class CmdLineParser():
    
    def getArgsParser():
        '''
        Parse the Args passed to this instance
        '''

        #class BlankLinesHelpFormatter(argparse.HelpFormatter):
        class BlankLinesHelpFormatter(argparse.RawDescriptionHelpFormatter):
            def _split_lines(self, text, width):
                return super()._split_lines(text, width) + ['']

        un = getUN()
        epilog = """
------------------------------------------------------------------------------------------

Example Usage for this might be:
--------------------------------

# Usage 1 (Download, extract, setup then manuall source) #
##########################################################

RH> ./appBox -ii Ubuntu20 -ip /scratch/appBox_{}/Ubuntu20
RH> source /scratch/appBox_{}/Ubuntu20/bin/activate
...
Ubuntu>

# Usage 2 (Download, extract, setup and drop me into a root shell) #
####################################################################

RH7> ./appBox -ii docker://almalinux:9 -ip /scratch/appBox_{}/AL9 -rar
...
RH9# dnf update -y
...

# Usage 3 (Download, ..., then run a command and exit) #
########################################################

RH7> ./appBox -ii Ubuntu22 -ip /scratch/appBox_{}/Ubuntu22 -q -rcr 'echo /etc/os-release'
PRETTY_NAME="Ubuntu 22.04.4 LTS"
NAME="Ubuntu"
VERSION_ID="22.04"
VERSION="22.04.4 LTS (Jammy Jellyfish)"
VERSION_CODENAME=jammy
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=jammy
RH7> 

------------------------------------------------------------------------------------------

""".format(un, un, un, un)


        parser = argparse.ArgumentParser(
                        prog='appBox', formatter_class=BlankLinesHelpFormatter,
                        description='This is a short tool to allow you to install a custom container image as a sandbox like "virtualenv".',
                        epilog=epilog)

        parser.add_argument('-rc', '--run-command',
                            help='Run a given command inside a sandbox.')

        parser.add_argument('-rp', '--run-path',
                            help='Path to look for an installed image (extracted sandbox) to use as a run-environment.')

        parser.add_argument('-rcr', '--run-command-root',
                            help='Run a given command AS ROOT inside a sandbox.')

        default_root = '/scratch/appBox_rcurrie/sandbox'

        #parser.add_argument('-ri', '--run-interactive',
        #                    type=str, default=default_root,
        #                    help='Launch a sandbox shell from this location.')

        #parser.add_argument('-rir', '--run-interactive-root',
        #                    type=str, default=default_root,
        #                    help='Launch a sandbox shell AS ROOT from this location.')

        default_image = 'almalinux:9'

        parser.add_argument('-ii', '--install-image',
                            default=default_image,
                            help='Image to install, or short-hand of image from "{} -li"'.format(sys.argv[0]))

        parser.add_argument('-ip', '--install-path',
                            default=default_root,
                            help='Install path, path to "install" an image to on disk. (The path that an image extracted to on disk)')

        parser.add_argument('-ra', '--run-after', action='store_true',
                            help='Should we drop into the new sandbox after installing.')

        parser.add_argument('-rar', '--run-after-root', action='store_true',
                            help='Should we drop into the new sandbox AS ROOT after installing.')

        #parser.add_argument('-li', '--list-images', action='store_true',
        #                    help='List suggested images to "install".')

        parser.add_argument('-q', '--quiet', action='store_true',
                            help='Quiet')

        parser.add_argument('-d', '--debug', action='store_true',
                            help='Debugging on.')

        #parser.add_argument('-ds', '--dump-settings', action='store_true',
        #                    help='Dump settings used by this instance.')

        parser.add_argument('-l', '--launch',
                            help='Launch Interactive environment from ...')

        parser.add_argument('-lr', '--launch-root',
                            help='Launch Interactive environment AS ROOT, from ...')

        parser.add_argument('-compat', '--compat-v1', action='store_true',
                            help='Use the older compatibility mode for the sandbox. This allows use of a CO8 host, but has issues with mounts.')

        parser.add_argument('-addNV', '--add-nvidia', action='store_true',
                            help='Add the nvidia-smi binary to the sandbox.')

        return parser


def run_sandbox(sandboxPath, asRoot, compatV1=False):
    '''
    Run a sandbox within a given Path as root or unknown/mapped user
    '''

    try:
        thisSandbox = sessionManager(sandboxPath, compatV1)
        thisSandbox.setupHostSpace()

        thisSandbox.mountHost()
        rc = thisSandbox.runInteractive(asRoot)

        return rc

    except Exception as err:
        appLogger.error('Exception during running appBox Shell: {}'.format(err))
        raise
    finally:
        thisSandbox.cleanupSpaces()


def run_command(sandboxPath, command, asRoot, compatV1=False, addNV=False):
    '''
    Run a command within a sandbox
    '''

    try:
        thisSandbox = sessionManager(sandboxPath, compatV1, addNV)
        thisSandbox.setupHostSpace()

        thisSandbox.mountHost()
        rc = thisSandbox.runCommand(command, asRoot)

        return rc

    except Exception as err:
        appLogger.error('Exception during running appBox Shell: {}'.format(err))
        raise
    finally:
        thisSandbox.cleanupSpaces()


def main():
    '''
    Main :) Hello
    '''
    
    ### Parse our args and steer
    parser = CmdLineParser.getArgsParser()
    parsed_args = parser.parse_args(sys.argv[1:])

    if parsed_args.quiet:
        appBoxManager.setLogLevel(logging.ERROR)
    elif parsed_args.debug:
        appBoxManager.setLogLevel(logging.DEBUG)
    else:
        appBoxManager.setLogLevel(logging.INFO)

    appLogger.debug('')
    appLogger.debug('Debugging Enabled. Jolan tru.')
    appLogger.debug('')


    command_to_run = None
    asRoot = False
    compatV1 = False
    wanted_dest = None
    should_run = False
    needToInstall = False
    addNV = parsed_args.add_nvidia

    if parsed_args.compat_v1:
        compatV1 = True

    wanted_image = parsed_args.install_image
    if parsed_args.install_path:
        wanted_dest = parsed_args.install_path
        needToInstall = True

    if parsed_args.run_command:
        command_to_run = parsed_args.run_command
        should_run = True
    if parsed_args.run_command_root:
        command_to_run = parsed_args.run_command_root
        asRoot = True
        should_run = True

    if parsed_args.launch:
        wanted_dest = parsed_args.launch
        should_run = True
    if parsed_args.launch_root:
        wanted_dest = parsed_args.launch_root
        asRoot = True
        should_run = True
        
    if parsed_args.run_after:
        should_run = True
    if parsed_args.run_after_root:
        asRoot = True
        should_run = True
        
    #if parsed_args.run_interactive:
    #    wanted_dest = parsed_args.run_interactive
    #    should_run = True
    #if parsed_args.run_interactive_root:
    #    wanted_dest = parsed_args.run_interactive_root
    #    asRoot = True
    #    should_run = True
    
    wanted_dest = os.path.abspath(wanted_dest)
    
    appLogger.debug('Looking in path: "{}"'.format(wanted_dest))
        
    if parsed_args.run_path:
        wanted_dest = parsed_args.run_path
        should_run = True

    if not os.path.exists(wanted_dest):
        appLogger.info('Sandbox: "{}" does not exist.'.format(wanted_dest))
        appLogger.info('Installing: "{}" at "{}"'.format(wanted_image, wanted_dest))
        needToInstall = True


    if needToInstall:

        ## TODO
        ## Add some way of handling images from other sources
        ## This should identify docker images from docker://
        ## This will probably involve adding additional classes for Quay, Singularity, etc.
        ## Can safely default to assume most users just want a docker image

        # Construct Manager
        image_manager = DockerHub()
        
        # Get data about which image we're about to pull
        image_name = wanted_image.split(':')[0]
        image_tag = wanted_image.split(':')[1]

        # Pull the image from the source to a temp folder
        image_manager.pullContainer(image_name, image_tag)

        # Extract the image to the destination path
        image_manager.buildSandbox(image_name, image_tag, wanted_dest)
        
        thisSandbox = sandboxFixes(wanted_dest, addNV)
        thisSandbox.applyAllFixes()

    if should_run:
    
        if command_to_run:
            command_to_run = '" ' + command_to_run + ' "'
    
        # We now plan to run a command or launch a shell
        rc = run_command(wanted_dest, command_to_run, asRoot, compatV1, addNV)
        sys.exit(rc)
        
    sys.exit(0)


if __name__ == '__main__':
    main()


