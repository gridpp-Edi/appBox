#!/bin/env python3
#
#   ▄▀▀█▄   ▄▀▀▄▀▀▀▄  ▄▀▀▄▀▀▀▄  ▄▀▀█▄▄   ▄▀▀▀▀▄   ▄▀▀▄  ▄▀▄ 
#  ▐ ▄▀ ▀▄ █   █   █ █   █   █ ▐ ▄▀   █ █      █ █    █   █ 
#    █▄▄▄█ ▐  █▀▀▀▀  ▐  █▀▀▀▀    █▄▄▄▀  █      █ ▐     ▀▄▀  
#   ▄▀   █    █         █        █   █  ▀▄    ▄▀      ▄▀ █  
#  █   ▄▀   ▄▀        ▄▀        ▄▀▄▄▄▀    ▀▀▀▀       █  ▄▀  
#  ▐   ▐   █         █         █    ▐              ▄▀  ▄▀   
#          ▐         ▐         ▐                  █    ▐    
# - Written by Rob Currie <rob.currie(at)ed.ac.uk>
#
# This tool is designed to simplify the life of users looking to use container-like sandbox environments to do work, testing, hacking
# This was written to address several issues which all have the same solution, but the existing implementations are, well... ugly.
#
# This is a tool for initializing sandboxes, fixing common gotchas and generaly allowing users to do more with what they have.
#
# This is distributed under the GPLv2 only, but I ask that people not remove attribution when using/modifying this.


import argparse
import fcntl
import json
import logging
import os
import platform
import pty
import pwd
import select
import shutil
import stat
import struct
import subprocess
import sys
import tarfile
import termios
import time
import tty
import urllib.request
import uuid

# Global Logger
appLogger = None

appBoxVersion = '2.0.0'


def getUN():
    '''
    Return the username of this account
    '''
    return pwd.getpwuid(os.getuid())[0]


def getHome():
    '''
    Return the home directory of this account
    '''
    return pwd.getpwuid(os.getuid())[5]


class ImageSource:

    def __init__(self, defaultCacheDir=None):
        self.proto = 'unknown'
        if defaultCacheDir:
            self.imageCacheDir = defaultCacheDir
        else:
            self.imageCacheDir = '/tmp/appBox_{}'.format(getUN())

    def writeContainerInfo(self, _file, image, tag):

        appBox_metaData = { '__version__': appBoxVersion,
                            'containerName': '{}://{}:{}'.format(self.proto, image, tag),
                            'installedTime': '{}'.format(str(time.time())),
                          }
        json.dump(appBox_metaData, _file, ensure_ascii=True, indent=2)

    def dumpContainerInfo(self, metaData):

        with open(metaData, 'r', encoding='utf-8') as _file:
            appBoxData = json.loads(_file.read())

        appLogger.info(appBoxData)

    def getArch(self):

        ## TODO add logic to determine correct string for each arch based on running system
        return 'amd64'


class DockerHub(ImageSource):

    def __init__(self, defaultCacheDir=None, should_cleanup=False):

        ImageSource.__init__(self, defaultCacheDir)

        # Cached tokens during this instance
        self.token = {}

        self.docker_auth = "auth.docker.io"
        self.docker_auth_service = "registry.docker.io"
        self.docker_reg = "registry-1.docker.io"
        self.image_pre = "library"

        self._should_cleanup = bool(should_cleanup)

        self.proto = 'docker'

    def _getImageStr(self, image):

        image_pre = self.image_pre
        image_split = image.split('/')
        if len(image_split) > 1:
            image_pre = image_split[0]
            image = image_split[1]
        return image_pre, image

    def checkToken(self, token, image):
        '''
        Just try to list the manifest and return based on the authenticated or not
        '''
        try:
            _headers = self.getHeaders(token)
            image_pre, image = self._getImageStr(image)
            _ = urllib.request.urlopen(urllib.request.Request(
                    "https://{}/v2/{}/{}/manifests/{}".format(self.docker_reg, image_pre, image, "latest"),
                    headers = _headers,
                )).read()
            return True
        except urllib.error.HTTPError as err:
            appLogger.debug(err)
            return False

    def getToken(self, image):

        if image in self.token:
            this_token = self.token[image]
            if self.checkToken(this_token, image):
                return this_token

        image_pre, image = self._getImageStr(image)

        appLogger.debug("Querying: https://%s/token?service=%s&scope=repository:%s/%s:pull", self.docker_auth, self.docker_auth_service,
                                                                               image_pre, image)
        token_response = urllib.request.urlopen(urllib.request.Request(
            "https://{}/token?service={}&scope=repository:{}/{}:pull".format(self.docker_auth, self.docker_auth_service,
                                                                             image_pre, image),
            #    headers={"Accept" : ''}
        )).read()
        #appLogger.debug('Requested token for "{}", received: "{}"'.format(image, token_response))

        token = json.loads(token_response.decode())['token']

        self.token[image] = token

        return self.token[image]

    def getDigest(self, manifest, image):

        appLogger.debug('Manifest: %s', manifest)

        digest_list = []

        ## '.fsLayers[]' | jq -r '.blobSum'
        ## Read the blobSum and return

        ## '.layers[0]' | jq -r '.digest'
        ## Read the digest from the layers and return
        if 'layers' in manifest:
            for this_layer in manifest['layers']:
                digest_list.append({'mediaType': this_layer['mediaType'],
                                    'digest': this_layer['digest']})

        ## '.manifest[0]' | jq -r '.digest'
        ## Read the manifest, get the correct digests and return
        elif 'manifests' in manifest:
            this_arch = self.getArch()
            for _manifest in manifest['manifests']:
                if _manifest['platform']['architecture'] == this_arch:
                    this_csum = _manifest['digest']

                    token = self.getToken(image)
                    _headers = self.getHeaders(token, "application/vnd.oci.image.manifest.v1+json")

                    manifest_response = self.getManifests(image, this_csum, _headers)

                    manifest_json = json.loads(manifest_response)

                    digest_list = self.getDigest(manifest_json, image)

                    break

        #raise Exception('here')
        return digest_list

    def _assembleImage(self, image_layers, output_image):

        ## Perform logic to assemble layers into single compressed image

        appLogger.debug('Image Layers: %s', image_layers)

        tmpFolder = os.path.join(self.imageCacheDir, 'appBox_tmpFolder_{}'.format(str(uuid.uuid4())[:8]))
        os.makedirs(tmpFolder)

        for layer in image_layers:
            if layer['mediaType'] in ['application/vnd.docker.image.rootfs.diff.tar.gzip',
                                      'application/vnd.oci.image.layer.v1.tar+gzip']:
                ## TODO add a tarfile filter to catch (bad image) failing mknod errors
                ## This should probably be done by a filter as we 'care' about some errors we're silencing here
                ## See Ubuntu:16.04 if you can still find it...
                with tarfile.open(layer['cacheFile'], errorlevel=0) as _tfile:
                    try:
                        _tfile.extractall(tmpFolder, filter='tar')
                    except TypeError:
                        _tfile.extractall(tmpFolder)

        for (root, dirs, files) in os.walk(tmpFolder, topdown=True):
            for _dir in dirs:
                this_path = os.path.join(root,_dir)
                if not os.path.islink(this_path):
                    current = stat.S_IMODE(os.lstat(this_path).st_mode)
                    os.chmod(this_path, current | stat.S_IWUSR | stat.S_IRUSR | stat.S_ISGID)
            for _file in files:
                this_path = os.path.join(root,_file)
                if not os.path.islink(this_path):
                    current = stat.S_IMODE(os.lstat(this_path).st_mode)
                    os.chmod(os.path.join(root,_file), current | stat.S_IWUSR | stat.S_IRUSR)

        with tarfile.open(output_image, "w|gz") as tar:
            contents = os.listdir(tmpFolder)
            for _obj in contents:
                tar.add(os.path.join(tmpFolder,_obj), arcname=_obj)

        shutil.rmtree(tmpFolder)

        return output_image

    def cacheImage(self, image, tag):

        return os.path.join(self.imageCacheDir, 'appBox_{}_{}.compressed'.format(image, tag))

    def getHeaders(self, token, accept="application/vnd.docker.distribution.manifest.v2+json"):

        return {"Accept": accept,
                 "Authorization": "Bearer {}".format(token),
                 "Content-Type": "application/json",
                 "User-Agent": "curl/8.0.1"}

    def getManifests(self, image, tag, _headers):
        appLogger.debug('Request Headers: %s', _headers)

        image_pre, image = self._getImageStr(image)

        appLogger.debug("Querying: https://%s/v2/%s/%s/manifests/%s", self.docker_reg, image_pre, image, tag)

        return urllib.request.urlopen(urllib.request.Request(
            "https://{}/v2/{}/{}/manifests/{}".format(self.docker_reg, image_pre, image, tag),
            headers = _headers,
        )).read()

    def pullContainer(self, image, tag):

        image_pre, image_sub = self._getImageStr(image)
        output_image = self.cacheImage(image_sub, tag)

        if os.path.isfile(output_image):
            appLogger.info('Output Image: "%s" found for image: "%s", tag: "%s"', output_image, image, tag)
            return
        else:
            appLogger.info('Pulling Image for: %s:%s', image, tag)

        token = self.getToken(image)

        _headers = self.getHeaders(token)

        appLogger.debug('Request Headers: %s', _headers)
        appLogger.debug("Querying: https://%s/v2/%s/%s/manifests/%s", self.docker_reg, self.image_pre, image, tag)

        try:
            manifest_response = self.getManifests(image, tag, _headers)
        except urllib.error.HTTPError as err:
            appLogger.error('Failed to get manifest for image: "%s", tag: "%s"', image, tag)
            appLogger.error('Error: %s', err)
            sys.exit(201)

        manifest_json = json.loads(manifest_response)

        this_digest_list = self.getDigest(manifest_json, image)

        def checkOutputLocation(outputDir):
            if not os.path.exists(outputDir):
                appLogger.debug('Creating output directory: %s', outputDir)
                os.makedirs(outputDir)

        checkOutputLocation(self.imageCacheDir)

        image_layers = []

        image_pre, image = self._getImageStr(image)

        for this_digest in this_digest_list:

            output_cache = '{}_{}_{}.digest'.format(this_digest['digest'], image, tag)
            output_cache = os.path.join(self.imageCacheDir, output_cache)
            image_layers.append({'mediaType': this_digest['mediaType'],
                                 'cacheFile': output_cache,
                                 'digest': this_digest['digest']})

            appLogger.debug('Downloading Layer: %s', this_digest['digest'])
            with urllib.request.urlopen(urllib.request.Request(
                "https://{}/v2/{}/{}/blobs/{}".format(self.docker_reg, image_pre,
                                                      image, this_digest['digest']),
                headers = _headers)) as request_data:

                with open(output_cache, 'wb+') as _file:
                    while True:
                        chunk = request_data.read(32 * 1024)
                        if not chunk:
                            break
                        _file.write(chunk)

        assembled_image = self._assembleImage(image_layers, output_image)

        appLogger.info('Image assembled at: %s', assembled_image)

        #def cleanUp(to_be_removed):
        #    ## Loop through and unlink un-needed layer and compressed layer versions
        #    while _file in to_be_removed:
        #        os.unlink(_file)

        if self._should_cleanup:
            for _layer in image_layers:
                os.unlink(_layer['cacheFile'])

    def buildSandbox(self, image, tag, dest):

        appBox_file = os.path.join(dest, '._appBoxContainer')

        _, img = self._getImageStr(image)

        this_image = self.cacheImage(img, tag)

        if not os.path.exists(this_image):
            appLogger.error('Expected to find (cached) image at: "%s", for image: "%s", tag: "%s".', this_image, image, tag)
            appLogger.error('Did you forget to pull first?')
            return False

        if not os.path.exists(dest):
            os.makedirs(dest)
        else:
            if os.path.exists(appBox_file):
                appLogger.info('Found appBox sandbox at: %s', dest)
                self.dumpContainerInfo(appBox_file)
                return False

        appLogger.info('Extracting Compressed Image.')
        with tarfile.open(this_image) as _tfile:
            try:
               _tfile.extractall(dest, filter='fully_trusted')
            except TypeError:
               _tfile.extractall(dest)

        appLogger.info('Writing metaData.')
        with open(appBox_file, 'w+', encoding='utf-8') as _file:
            self.writeContainerInfo(_file, image, tag)

        return True


class sandboxFixes():

    def __init__(self, add_nv, sandbox_instance):

        #self.sandbox_path = sandbox_path
        self.add_nvidia = add_nv
        self.sandbox_instance = sandbox_instance

        self.tmpPath = '/tmp'

    def applyAllFixes(self):
        '''
        '''
        self.fixFilePermissions()
        self.fixAptSandboxing()
        self.fixMissingPaths()
        self.fixMissingStubs()
        self.fixUserAccounts()
        self.fixAliases()
        self.fixEnvironment()
        self.installAppBox()
        self.copyFromHost()
        self.fixForLies()

    def applySafeFixes(self):
        '''
        '''
        self.fixUserAccounts()
        self.copyFromHost()

    def copyFromHost(self):

        file_list = ['/etc/resolv.conf', '/etc/hostname', '/etc/localtime', '/etc/timezone', '/etc/vimrc']

        for _file in file_list:
            self.sandbox_instance.copyFileFromHost(_file, os.path.abspath(os.path.join(self.sandbox_instance.getsandbox_path(), '.'+_file)))
        #else:
        #    for _file in file_list:
        #        if not os.path.exists(os.path.join(self.sandbox_path, '.'+_file)):
        #            shutil.copyfile(_file,
        #                            os.path.join(self.sandbox_path, '.'+_file))

    def fixFilePermissions(self):
        '''
        Fix the permissions of a given path
        '''
        if self.sandbox_instance.rootfs:
            return
        for root, dirs, files in os.walk(self.sandbox_instance.getsandbox_path(), topdown=True):
            for _dir in dirs:
                this_path = os.path.join(root,_dir)
                if not os.path.islink(this_path):
                    current = stat.S_IMODE(os.lstat(this_path).st_mode)
                    os.chmod(this_path, current | stat.S_IWUSR | stat.S_IRUSR | stat.S_ISGID)
            for _file in files:
                this_path = os.path.join(root,_file)
                if not os.path.islink(this_path):
                    current = stat.S_IMODE(os.lstat(this_path).st_mode)
                    os.chmod(os.path.join(root,_file), current | stat.S_IWUSR | stat.S_IRUSR)

    def _getPathList(self):
        '''
        '''
        # This is a good fraction of the lsb because not all images follow the lsb...
        # which means...
        # well...
        # yeah...
        base_path_list = ['/afs', '/dev', '/etc', '/cvmfs', '/scratch', '/Data', '/localdisk', '/sys', '/tmp', '/home', '/proc', '/tmp/{}'.format(getUN()), '/mnt']

        if self.add_nvidia:
            base_path_list.append('/usr/lib/wsl')

        return base_path_list

    def fixMissingPaths(self):
        '''
        '''
        needed_sandbox_paths = self._getPathList()

        abs_paths = []
        for _path in needed_sandbox_paths:
            abs_paths.append(os.path.abspath(os.path.join(self.sandbox_instance.getsandbox_path(), '.'+_path)))

        for _path in abs_paths:
            self.sandbox_instance.createsandbox_path(_path)

    def _getStubList(self):
        '''
        '''
        base_stubs = ['/etc/resolv.conf', '/etc/hostname']

        if self.add_nvidia:
            base_stubs.append('/usr/bin/nvidia-smi')
            base_stubs.append('/usr/bin/nvidia-modprobe')

        return base_stubs

    def fixMissingStubs(self):
        '''
        Create the stubs needed for the sandbox
        '''
        needed_stubs = self._getStubList()

        abs_paths = []
        for _path in needed_stubs:
            abs_paths.append(os.path.abspath(os.path.join(self.sandbox_instance.getsandbox_path(), '.'+_path)))

        for _path in abs_paths:
            self.sandbox_instance.createSandboxEmptyFile(_path)

    def getAnonUIDGID(self):
        # TODO work out if we need to detect/change this
        return (65534, 65534)

    def fixUserAccounts(self):
        '''
        Fix the user accounts within the sandbox
        '''
        tmp_passwd_file = os.path.join(self.tmpPath, 'passwd_{}'.format(str(uuid.uuid4())[:8]))
        try:
            self._fixPasswd(tmp_passwd_file)
        finally:
            os.unlink(tmp_passwd_file)
        tmp_group_file = os.path.join(self.tmpPath, 'group_{}'.format(str(uuid.uuid4())[:8]))
        try:
            self._fixGroup(tmp_group_file)
        finally:
            os.unlink(tmp_group_file)
        tmp_shadow_file = os.path.join(self.tmpPath, 'gshadow_{}'.format(str(uuid.uuid4())[:8]))
        try:
            self._fixGShadow(tmp_shadow_file)
        finally:
            os.unlink(tmp_shadow_file)

    def _fixPasswd(self, tmp_passwd_file):
        '''
        '''
        self.sandbox_instance.copyFileToHost('/etc/passwd', tmp_passwd_file)

        with open(tmp_passwd_file, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('Content: "%s"', _content)

        new_content = 'root:x:0:0:root:/root:/bin/bash\n'
        new_content += '{}:x:65534:65534:{}:{}:/bin/bash\n'.format(getUN(),getUN(),getHome())

        a_uid, a_gid = self.getAnonUIDGID()

        for _line in _content.split('\n'):
            if _line:
                _user, _, _uid, _gid, _name, _home, _shell = _line.split(':')
                if _user in ['root', getUN(), 'fax', 'input', 'kvm', 'render']:
                    continue
                if _user.startswith('systemd'): # A dirty trick to keep apt 'content' on Ubuntu systems
                    continue
                appLogger.debug('User: "%s", UID: "%s", GID: "%s", Name: "%s", Home: "%s", Shell: "%s"',
                                    _user, _uid, _gid, _name, _home, _shell)

                new_content += '{}:x:{}:{}:{}:{}:{}\n'.format(_user, a_uid, a_gid, _name, _home, _shell)

        with open(tmp_passwd_file, 'w+', encoding='utf-8') as _file:
            _file.write(new_content)

        self.sandbox_instance.copyFileFromHost(tmp_passwd_file, os.path.join(self.sandbox_instance.getsandbox_path(), './etc/passwd'))

    def _fixGroup(self, tmp_group_file):
        '''
        '''
        self.sandbox_instance.copyFileToHost('/etc/group', tmp_group_file)

        with open(tmp_group_file, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('Content: "%s"', _content)

        _, a_gid = self.getAnonUIDGID()

        new_content = 'root:x:0:\n'
        new_content += '{}:x:{}:\n'.format(getUN(), a_gid)

        for _line in _content.split('\n'):
            if _line:
                _group, _, _gid, _users = _line.split(':')
                if _group in ['root', getUN(), 'fax', 'input', 'kvm', 'render']:
                    continue
                if _group.startswith('systemd'): # A dirty trick to keep apt 'content' on Ubuntu systems
                    continue
                appLogger.debug('Group: "%s", GID: "%s", Users: "%s"', _group, _gid, _users)

                new_content += '{}:x:{}:{}\n'.format(_group, a_gid, _users)

        with open(tmp_group_file, 'w+', encoding='utf-8') as _file:
            _file.write(new_content)

        self.sandbox_instance.copyFileFromHost(tmp_group_file, os.path.join(self.sandbox_instance.getsandbox_path(), './etc/group'))

    def _fixGShadow(self, tmp_shadow_file):
        '''
        '''
        self.sandbox_instance.copyFileToHost('/etc/gshadow', tmp_shadow_file)
        with open(tmp_shadow_file, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('Content: "%s"', _content)

        new_content = ''

        for _line in _content.split('\n'):
            if _line:
                _pass = True
                for check in ['fax', 'voice', 'sudo', 'dip', 'operator', 'src', 'shadow', 'sasl', 'plugdev', 'staff', 'nogroup']:
                    if _line.startswith(check):
                        _pass = False
                        break
                if not _pass:
                    continue
                new_content += _line + '\n'

        with open(tmp_shadow_file, 'w+', encoding='utf-8') as _file:
            _file.write(new_content)

        self.sandbox_instance.copyFileFromHost(tmp_shadow_file, os.path.join(self.sandbox_instance.getsandbox_path(), './etc/gshadow'))

    def fixAliases(self):

        self.sandbox_instance.createsandbox_path(os.path.join(self.sandbox_instance.getsandbox_path(), './etc/profile.d'))

        def fixDeactivate():
            tmp_deac_script = os.path.join(self.tmpPath, 'deac.sh_{}'.format(str(uuid.uuid4())[:8]))
            with open(tmp_deac_script, 'w+', encoding='utf-8') as _file:
                _file.write('alias deactivate=exit')

            self.sandbox_instance.copyFileFromHost(tmp_deac_script, os.path.join(self.sandbox_instance.getsandbox_path(), './etc/profile.d/deac.sh'))

        fixDeactivate()

    def fixEnvironment(self):

        if self.add_nvidia:
            self.sandbox_instance.createsandbox_path(os.path.join(self.sandbox_instance.getsandbox_path(), './etc/ld.so.conf.d'))
            tmp_ld_path = os.path.join(self.tmpPath, 'ld.wsl.conf_{}'.format(str(uuid.uuid4())[:8]))
            with open(tmp_ld_path, 'w+', encoding='utf-8') as _file:
                _file.write('/usr/lib/wsl/lib')
            self.sandbox_instance.copyFileFromHost(tmp_ld_path, os.path.join(self.sandbox_instance.getsandbox_path(), './etc/ld.so.conf.d/wsl.conf'))

    def fixAptSandboxing(self):
        '''
        Fix issues related to installing packages on Debian in a single-user-sandbox...
        '''

        app_conf_path = os.path.join(self.sandbox_instance.getsandbox_path(), './etc/apt/apt.conf.d/')
        self.sandbox_instance.createsandbox_path(app_conf_path)

        layer_path = os.path.join(self.sandbox_instance.sandbox_path, './etc/apt/apt.conf.d/')
        if os.path.exists(layer_path):
            # Only want to apply this 'fix' in sandboxes where apt is installed

            fix_apt  = 'APT::Sandbox::User "root";\nAPT::Sandbox::Verify "0";\n'
            fix_apt += 'APT::Sandbox::Verify::IDs "0";\nAPT::Sandbox::Verify::Groups "0";\n'
            fix_apt += 'APT::Sandbox::Verify::Regain "0";'

            tmp_sandbox = os.path.join(self.tmpPath, 'sandbox-disable_{}'.format(str(uuid.uuid4())[:8]))
            with open(tmp_sandbox, 'w+', encoding='utf-8') as _file:
                _file.write(fix_apt)

            self.sandbox_instance.copyFileFromHost(tmp_sandbox, os.path.join(app_conf_path, '99appBox'))

            ## Hack of a hack...
            ## cp /bin/true /usr/bin/dpkg-statoverride

            shutil.copyfile(os.path.join(self.sandbox_instance.getsandbox_path(), 'bin/true'),
                            os.path.join(self.sandbox_instance.getsandbox_path(), 'usr/bin/dpkg-statoverride'))

            shutil.copyfile(os.path.join(self.sandbox_instance.getsandbox_path(), 'bin/true'),
                            os.path.join(self.sandbox_instance.getsandbox_path(), 'bin/dpkg-statoverride'))

    def installAppBox(self):
        '''
        Install the appBox tool into the sandbox
        '''
        currentInstance = os.path.abspath(__file__)
        if not os.path.exists(os.path.join(self.sandbox_instance.sandbox_path, './bin')):
            os.makedirs(os.path.join(self.sandbox_instance.sandbox_path, './bin'))
        installInstance = os.path.join(self.sandbox_instance.sandbox_path, './bin/appBox')

        self.sandbox_instance.copyFileFromHost(currentInstance, installInstance)

        cvmfs_args = ''
        if self.sandbox_instance.rootfs:
            cvmfs_args = '-cvmfs {}'.format(os.path.abspath(self.sandbox_instance.rootfs))

        for _ in ['user', 'root']:
            if _ == 'root':
                as_string = '-rar'
                script_name = 'activate-asroot'
            else:
                as_string = '-ra'
                script_name = 'activate'

            activate_script = """#!/bin/bash

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

/bin/env python3 ${SCRIPT_DIR}/appBox """
            activate_script = activate_script + cvmfs_args
            activate_script = activate_script + " -l ${SCRIPT_DIR}/../ """ + as_string

            activatePath = os.path.join(self.sandbox_instance.sandbox_path, './bin/{}'.format(script_name))
            with open(activatePath, 'w+', encoding='utf-8') as _file:
                _file.write(activate_script)

            for _file in [installInstance, activatePath, ]:
                st = os.stat(_file)
                os.chmod(_file, st.st_mode | stat.S_IEXEC)

    def fixForLies(self):
        '''
        '''

        ## TODO decide if this is a bad idea or not...
        ## Intention here is to 'stop' automated tooling from trying to do something bad within the sandbox
        ## This has the side-effect of stopping people changing a file so that they can't so anything with it

        for _file in ['/usr/bin/chown', '/usr/bin/chmod', '/bin/chown', '/bin/chmod', ]:
            self.sandbox_instance.copyFileFromHost(os.path.join(self.sandbox_instance.getsandbox_path(), 'bin/true'),
                            os.path.join(self.sandbox_instance.getsandbox_path(), '.'+_file))
            self.sandbox_instance.copyFileFromHost(os.path.join(self.sandbox_instance.getsandbox_path(), 'bin/true'),
                            os.path.join(self.sandbox_instance.getsandbox_path(), '.'+_file))


class sessionManager():

    def __init__(self, sandbox_path, compat_v1=False, add_nv=False, rootfs=None):
        '''
        Standard __init__ :)
        '''
        self.proc = None
        self.pid_parent = None
        self.pid_child = None
        self.old_i_tty = None
        self.sandbox_path = sandbox_path
        self.compat_v1 = compat_v1
        self.add_nvidia = add_nv

        self.stdout_m, self.stdout_s = None, None
        self.pid_subParent = None
        self.running = False

        self.proc2 = None
        self.pid_subChild, self.pid_subParent = None, None

        self.rootfs = rootfs
        self._layers = ['._appBoxLayers/overlay', '._appBoxLayers/upper', '._appBoxLayers/work']

    def getsandbox_path(self):
        if self.rootfs:
            appLogger.debug('Sandbox Path: %s', os.path.join(self.sandbox_path, '._appBoxLayers/overlay'))
            return os.path.join(self.sandbox_path, '._appBoxLayers/overlay')
        else:
            appLogger.debug('Sandbox Path: %s', self.sandbox_path)
            return self.sandbox_path

    def _wrangle_tty(self):
        '''
        This is some boiler-plate for setting up a pTTY
        '''

        # save original tty setting then set it to raw mode
        old_i_tty = termios.tcgetattr(sys.stdin)
        tty.setraw(sys.stdin.fileno())

        # open pseudo-terminal to interact with subprocess
        stdout_m_fd, stdout_s_fd = pty.openpty()

        size = os.get_terminal_size()
        winsize = struct.pack("HHHH", size[1], size[0], 0, 0)
        fcntl.ioctl(stdout_m_fd, termios.TIOCSWINSZ, winsize)

        appLogger.debug('Opening PTY')

        self.old_i_tty = old_i_tty
        self.stdout_m, self.stdout_s = stdout_m_fd, stdout_s_fd

    def setupHostSpace(self):
        '''
        This sets up a 'root' namespace.
        This persists for the lifetime of this shell.
        '''

        if self.rootfs:
            for _layer in self._layers:
                this_layer = os.path.join(self.sandbox_path, _layer)
                if not os.path.exists(this_layer):
                    os.makedirs(this_layer)

        background_task='/bin/bash'
        appLogger.debug('Launching host namespace manager')
        host_manager="unshare -primf --propagation unchanged {}".format(background_task)
        appLogger.debug(host_manager)
        self.proc = subprocess.Popen(host_manager,
                                     shell=True, preexec_fn=os.setsid,
                                     stdin = subprocess.PIPE,
                                     stdout = subprocess.PIPE,
                                     stderr = subprocess.PIPE,
                                     universal_newlines = True)

        appLogger.debug('Host sandbox namespace: %s', self.proc.pid)
        self.pid_parent=self.proc.pid
        time.sleep(0.1)

        parentID = self.pid_parent
        childID = parentID
        while True:

            appLogger.debug('Parent PID: %s', parentID)
            appLogger.debug('Child PID: %s', childID)
            try:
                parentID, childID = self.getChildID(childID)
                self.pid_child = childID
            except (OSError, ValueError) as err:
                appLogger.debug('Error: %s', err)
                break
            time.sleep(0.1)

            appLogger.debug('---')

        if not self.pid_child:
            raise Exception('Cannot Fork Child Process. Are you trying to run appBox inside appBox?')

        return self.pid_parent, self.pid_child

    def _copyToFromSandbox(self, source, dest):
        '''
        '''
        copy_cmd = 'cp -rfHL {} {}'.format(source, dest)
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s',
                            self.pid_child, copy_cmd)

        copy_proc = subprocess.Popen(
                        'nsenter --preserve-credentials --user --mount --pid -t {} {}'.format(
                            self.pid_child, copy_cmd),
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        ## TODO add better error checking here
        copy_proc.wait()
        appLogger.debug(copy_proc.poll())
        del copy_proc

    def copyFileFromHost(self, hostFile, sandboxFile):
        '''
        '''
        i=0
        while os.path.islink(hostFile):
            appLogger.debug('Symlink: %s -> %s', hostFile, os.readlink(hostFile))
            hostFile = os.readlink(hostFile)
            i=i+1
            if i>10:
                break
        if i>10:
            appLogger.error('Too many symlinks in file: %s', hostFile)
            return
        #if self.compat_v1:
        #    sandboxFile = os.path.join(self.getsandbox_path(), '.'+sandboxFile)
        self._copyToFromSandbox(hostFile, sandboxFile)

    def copyFileToHost(self, sandboxFile, hostFile):
        '''
        '''
        #if self.compat_v1:
        sandboxFile = os.path.join(self.getsandbox_path(), '.'+sandboxFile)
        self._copyToFromSandbox(sandboxFile, hostFile)

    def createsandbox_path(self, path, overridePID=None):
        '''
        '''
        pid_space = self.pid_child
        if overridePID:
            pid_space = overridePID
        create_cmd = 'mkdir -p {}'.format(os.path.abspath(path))
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s',
                            pid_space, create_cmd)

        create_proc = subprocess.Popen(
                        'nsenter --preserve-credentials --user --mount --pid -t {} {}'.format(
                            pid_space, create_cmd),
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        ## TODO add better error checking here
        create_proc.wait()
        del create_proc

    def createSandboxEmptyFile(self, path):
        '''
        '''
        create_cmd = 'touch {}'.format(os.path.abspath(path))

        create_proc = subprocess.Popen(
                        'nsenter --preserve-credentials --user --mount --pid -t {} {}'.format(
                            self.pid_child, create_cmd),
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        ## TODO add better error checking here
        create_proc.wait()
        del create_proc

    def getChildID(self, this_pid):

        child_pid_path = '/proc/{}/task/{}/children'.format(this_pid, this_pid)
        appLogger.debug('Querying: %s', child_pid_path)
        with open(child_pid_path, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('Content: "%s"', _content)
            child_pid = int(_content)
            appLogger.debug('PID: %s', child_pid)

        return this_pid, child_pid

    def getSharePaths(self):
        '''
        This is a list of directories to be mounted into the sandbox from the host
        '''
        mounts = ['/afs', '/home', '/tmp', '/dev', '/cvmfs', '/scratch', '/Data', '/localdisk', '/sys', '/mnt']
        if self.add_nvidia:
            mounts += ['/usr/lib/wsl', '/usr/bin/nvidia-smi', '/usr/bin/nvidia-modprobe']
        return mounts

    def mountHost(self, overridePID=None):
        '''
        Mount the shared paths between the host and the sandbox namespace
        '''
        host_mounts = self.getSharePaths()

        for host_path in host_mounts:

            sandbox_path = os.path.abspath(os.path.join(self.getsandbox_path(), '.'+host_path))

            if not os.path.exists(host_path):
                appLogger.debug('Skipping path %s, as it doesn\'t exist on the host', host_path)
                continue

            appLogger.debug('Bind Mounting: %s as: %s', host_path, sandbox_path)
            self.createsandbox_path(sandbox_path, overridePID)

            pid_space = self.pid_child
            mount_opts = '--rbind --make-rslave'
            if overridePID:
                pid_space = overridePID
                mount_opts = '--rbind'

            appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s mount %s %s %s',
                                pid_space, mount_opts, host_path, sandbox_path)

            mount_proc = subprocess.Popen(
                            'nsenter --preserve-credentials --user --mount --pid -t {} mount {} {} {}'.format(
                                pid_space, mount_opts, host_path, sandbox_path),
                            stdin = subprocess.PIPE,
                            stdout = subprocess.PIPE,
                            stderr = subprocess.PIPE,
                            shell=True)
            mount_proc.wait()
            ## TODO add better error checking here

            del mount_proc

    def mountrootfs(self, rootfs):
        '''
        '''

        rootfs_path = os.path.realpath(os.path.abspath(os.path.join(rootfs)))

        needed_layers = ['._appBoxLayers/overlay', '._appBoxLayers/upper', '._appBoxLayers/work']

        layer_paths = []
        for _layer in needed_layers:

            layer_path = os.path.abspath(os.path.join(self.sandbox_path, _layer))

            if not os.path.exists(layer_path):
                os.makedirs(layer_path)

            layer_paths.append(layer_path)

        rootfs_mount_cmd = 'fuse-overlayfs -o squash_to_root -o lowerdir={},upperdir={},workdir={} {}'.format(
                                                            rootfs_path, layer_paths[1], layer_paths[2], layer_paths[0])

        appLogger.debug('Mounting rootfs via: %s', rootfs_mount_cmd)

        mount_proc = subprocess.Popen(
                        'nsenter --preserve-credentials --user --mount --pid -t {} {}'.format(
                            self.pid_child, rootfs_mount_cmd),
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        ## TODO add better error checking here
        mount_proc.wait()
        del mount_proc

    def cleanupSpaces(self):
        '''
        Cleanup the 'persistent' spaces which have been created
        '''
        # restore tty settings back
        try:
            os.write(sys.stdin.fileno(), '\n\r'.encode())
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.old_i_tty)
            sys.stdin.flush()
            sys.stdout.flush()
            del self.proc
            self.proc = None
        except:
            pass

    def setupSubSpace(self, as_root):
        '''
        Create a subSpace within the root space of the host
        '''
        appLogger.debug('Setting up SubSpace')

        chroot_cmd = self._getSandboxCmd(None, as_root)

        self.proc2 = subprocess.Popen(chroot_cmd,
                                     shell=True, preexec_fn=os.setsid,
                                     stdin = subprocess.PIPE,
                                     stdout = subprocess.PIPE,
                                     stderr = subprocess.PIPE,
                                     universal_newlines = True)

        appLogger.debug('PID of subSpace: %s', self.proc2.pid)

        self.pid_subParent=self.proc2.pid

        time.sleep(0.1)

        with open('/proc/{}/task/{}/children'.format(self.pid_subParent, self.pid_subParent),
                  'r', encoding='utf-8') as _file:
            self.pid_subChild=int(_file.read())
            appLogger.debug('Child PID: %s', self.pid_subChild)

        return (self.pid_subParent, self.pid_subChild)

    def _getSandboxCmd(self, command=None, as_root=False):

        if command is None:
            if self.rootfs:
                command_path = os.path.join(self.rootfs, 'bin/bash')
            else:
                command_path = os.path.join(self.sandbox_path, 'bin/bash')
            if os.path.exists(command_path):
                command = '/bin/bash -l'
            else:
                command = '/bin/sh'
        else:
            if not self.compat_v1:
                command_path = os.path.join(self.sandbox_path, 'bin/bash')
                if os.path.exists(command_path):
                    command = '/bin/bash -c "sleep 1; {}"'.format(command)
                else:
                    pass
            else:
                command = '/bin/bash -c \'sleep 1; {}\''.format(command)
        #command = '/bin/bash -l'

        if not self.compat_v1:
            # Continue as Normal and use good hosts unshare
            if as_root:
                chroot_cmd = '/bin/bash -c \'mount -t tmpfs tmpfs {}/run; unshare -priUmf --mount --mount-proc -R {} --propagation=unchanged {};\' exit $?'.format(
                    self.getsandbox_path(), self.getsandbox_path(), command)
            else:
                chroot_cmd = '/bin/bash -c \'mount -t tmpfs tmpfs {}/run; unshare -piUmf --mount --mount-proc -R {} --propagation=unchanged {};\' exit $?'.format(
                    self.getsandbox_path(), self.getsandbox_path(), command)
        else:
            # Use the older compatibility mode for the sandbox, use chroot and drop the '-R' unshare arg...
            # TBF for HEP it was clear as day AL9 wa going to be the way forward in 202x, but some people are still on CO8/R8... _sigh_ ...

            # I absolutely could not find a way without unshare -R to drop down to a non-priviledged anon user using chroot
            # This could simply be me mis-understanding something about sandboxes and their inheritance, or my mistake
            # Given I don't really _want_ to support running on such an old host I think we can just say for now:

            if not as_root:
                appLogger.warning('Compatability with older Hosts doesn\'t work with dropping into a \'non-root\' sandbox.')

            chroot_cmd = 'chroot {} /bin/bash -c "export PATH=/bin:/sbin:/usr/sbin:/usr/bin:$PATH; /bin/mount -t tmpfs tmpfs /run; /bin/mount -t proc proc /proc; {}"; exit $?'.format(
                self.getsandbox_path(), command)

        return chroot_cmd

    def runCommand(self, command, as_root=False):
        '''
        '''

        chroot_cmd = self._getSandboxCmd(command, as_root)

        appLogger.debug('About to execute')
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s ; exit $?;', self.pid_child, chroot_cmd)

        self._wrangle_tty()
        interactive_proc = subprocess.Popen(
            'nsenter --preserve-credentials --user --mount --pid -t {} {} ; exit $?;'.format(
                self.pid_child, chroot_cmd),
                 stdin = self.stdout_s,
                                stdout = self.stdout_s,
                                stderr = self.stdout_s,
                                shell = True, universal_newlines = True, preexec_fn=os.setsid
                                )

        i=0
        TIME_LIMIT=100

        while i<= TIME_LIMIT:
            time.sleep(0.1)  # Total 10s chance for child to spawn on a healthy system
            i=i+1            # Obviously 10s+work-time, but I'm assuming accessing proc is cheap

            parentID = interactive_proc.pid
            childID = parentID

            try:
                # If the process is unknown or in a zombie state
                if self.procState(interactive_proc.pid) in ['Z', 'E']:
                    break
            except PermissionError as err:
                break

            while True:

                appLogger.debug('Parent PID: %s', parentID)
                appLogger.debug('Child PID: %s', childID)
                try:
                    parentID, childID = self.getChildID(childID)
                    #self.pid_child = childID
                except (OSError, ValueError) as err:
                    appLogger.debug('Error: %s', err)
                    break
                time.sleep(0.1)

                appLogger.debug('---')

            if parentID != childID and childID:
                if self.compat_v1:
                    self.mountHost(childID)
                break

        if i>TIME_LIMIT:
            raise Exception('Failed to spawn child process to launch shell or run command.')

        readable = [sys.stdin, self.stdout_m]
        while True:

            self.running = True
            should_continue = self._shell_fwd_bck(interactive_proc, readable)

            if not should_continue:
                break
        self.running=False

        rc = interactive_proc.poll()

        appLogger.debug('Return Code: %s', rc)

        return rc

    def procState(self, pid):
        '''
        Return the state of a given PID in linux
        '''
        # Only on Linux
        for _line in open("/proc/%d/status" % pid, encoding='utf-8').readlines():
            if _line.startswith("State:"):
                entry = _line.split(":")[1].strip()
                value = entry.rstrip()[0]
                return value
        # Unknown
        return 'E'

    def _shell_fwd_bck(self, interactive_proc, readable):
        '''
        This is the component for handling sending data in/out of the pty
        '''

        try:
            # If the process is unknown or in a zombie state
            if self.procState(interactive_proc.pid) in ['Z', 'E']:
                return False
        except PermissionError as err:
            return False

	    # Poll for input/output
        if interactive_proc and interactive_proc.poll() is None:
            r, _w, _e = select.select(readable, [], [], 0.01)

            for _in in r:
                if _in is sys.stdin:
                    d = os.read(sys.stdin.fileno(), 10240)
                    #if d.decode() in ['\x04',]:
                    #    self._should_stop = True
                    #    return False
                    os.write(self.stdout_m, d)
                elif _in is self.stdout_m:
                    try:
                        o = os.read(self.stdout_m, 10240)
                    except OSError as e:
                        appLogger.debug('Error: %s', e)
                        return False
                    if o:
                        os.write(sys.stdout.fileno(), o)
                else:
                    raise Exception('Help')
            return True
        else:
            return False


class appBoxManager():

    def setLogLevel(self, level):

        global appLogger
        appLogger = logging.getLogger('appBox')

        logging.basicConfig(level=level, format='%(message)s')
        appLogger.setLevel(level)
        for handler in appLogger.handlers:
            handler.setLevel(level)


class CmdLineParser:

    def getArgsParser(self):
        '''
        Parse the Args passed to this instance
        '''

        #class BlankLinesHelpFormatter(argparse.HelpFormatter):
        class BlankLinesHelpFormatter(argparse.RawDescriptionHelpFormatter):
            def _split_lines(self, text, width):
                return super()._split_lines(text, width) + ['']

        un = getUN()
        epilog = """
------------------------------------------------------------------------------------------

Example Usage for this might be:
--------------------------------

# Usage 1 (Download, extract, setup then manuall source) #
##########################################################

RH> ./appBox -ii Ubuntu20 -ip /scratch/appBox_{}/Ubuntu20
RH> source /scratch/appBox_{}/Ubuntu20/bin/activate
...
Ubuntu>

# Usage 2 (Download, extract, setup and drop me into a root shell) #
####################################################################

RH7> ./appBox -ii docker://almalinux:9 -ip /scratch/appBox_{}/AL9 -rar
...
RH9# dnf update -y
...

# Usage 3 (Download, ..., then run a command and exit) #
########################################################

RH7> ./appBox -ii Ubuntu22 -ip /scratch/appBox_{}/Ubuntu22 -q -rcr 'echo /etc/os-release'
PRETTY_NAME="Ubuntu 22.04.4 LTS"
NAME="Ubuntu"
VERSION_ID="22.04"
VERSION="22.04.4 LTS (Jammy Jellyfish)"
VERSION_CODENAME=jammy
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=jammy
RH7> 

------------------------------------------------------------------------------------------

""".format(un, un, un, un)


        parser = argparse.ArgumentParser(
                        prog='appBox', formatter_class=BlankLinesHelpFormatter,
        description='This is a tool to install a custom container as a sandbox like "virtualenv".',
                        epilog=epilog)

        parser.add_argument('-rc', '--run-command',
                            help='Run a given command inside a sandbox.')

        parser.add_argument('-rp', '--run-path',
        help='Path to look for an installed image (extracted sandbox) to use as a run-environment.')

        parser.add_argument('-rcr', '--run-command-root',
                            help='Run a given command AS ROOT inside a sandbox.')

        if os.path.exists('/scratch'):
            leading_path = '/scratch'
        else:
            leading_path = '/tmp'

        default_root = '{}/appBox_{}/sandbox'.format(leading_path, getUN())

        #parser.add_argument('-ri', '--run-interactive',
        #                    type=str, default=default_root,
        #                    help='Launch a sandbox shell from this location.')

        #parser.add_argument('-rir', '--run-interactive-root',
        #                    type=str, default=default_root,
        #                    help='Launch a sandbox shell AS ROOT from this location.')

        #default_image = 'almalinux:9'
        default_image = 'centos:7'

        parser.add_argument('-ii', '--install-image',
                            default=default_image,
                help='Image to install, or short-hand of image from "{} -li"'.format(sys.argv[0]))

        parser.add_argument('-ip', '--install-path',
                            default=default_root,
        help='Install path, path to "install" an image to on disk. (Path to extract to on disk)')

        parser.add_argument('-ra', '--run-after', action='store_true',
                            help='Should we drop into the new sandbox after installing.')

        parser.add_argument('-rar', '--run-after-root', action='store_true',
                            help='Should we drop into the new sandbox AS ROOT after installing.')

        #parser.add_argument('-li', '--list-images', action='store_true',
        #                    help='List suggested images to "install".')

        parser.add_argument('-q', '--quiet', action='store_true',
                            help='Quiet')

        parser.add_argument('-d', '--debug', action='store_true',
                            help='Debugging on.')

        #parser.add_argument('-ds', '--dump-settings', action='store_true',
        #                    help='Dump settings used by this instance.')

        parser.add_argument('-l', '--launch',
                            help='Launch Interactive environment from ...')

        parser.add_argument('-lr', '--launch-root',
                            help='Launch Interactive environment AS ROOT, from ...')

        parser.add_argument('-compat', '--compat-v1', action='store_true',
            help='Use the older compatibility mode for the sandbox. Allows a CO8 host.')

        parser.add_argument('-add_nv', '--add-nvidia', action='store_true',
                            help='Add the nvidia-smi binary to the sandbox.')

        # Disabling the cvmfs tooling for now as it's not production ready/tested yet.
        #parser.add_argument('-cvmfs', '--use-cvmfs',
        #                    help='Use uncompressed image from this CVMFS path.')

        return parser


def run_command(sandbox_path, command, as_root, compat_v1=False, add_nv=False, rootfs=None):
    '''
    Run a command within a sandbox
    '''

    try:
        this_sandbox = sessionManager(sandbox_path, compat_v1, add_nv, rootfs)
        this_sandbox.setupHostSpace()

        if rootfs:
            this_sandbox.mountrootfs(rootfs)
            #time.sleep(1.0)

        this_sandbox.mountHost()

        these_fixes = sandboxFixes(add_nv, this_sandbox)
        these_fixes.applyAllFixes()

        rc = this_sandbox.runCommand(command, as_root)

        return rc

    except Exception as err:
        appLogger.error('Exception during running appBox Shell: %s', err)
        if appLogger.level == logging.DEBUG:
            raise
        sys.exit(56)
    finally:
        this_sandbox.cleanupSpaces()


def main():
    '''
    Main :) Hello
    '''

    ### Parse our args and steer
    parser = CmdLineParser().getArgsParser()
    parsed_args = parser.parse_args(sys.argv[1:])

    if parsed_args.quiet:
        appBoxManager().setLogLevel(logging.ERROR)
    elif parsed_args.debug:
        appBoxManager().setLogLevel(logging.DEBUG)
    else:
        appBoxManager().setLogLevel(logging.INFO)

    appLogger.debug('')
    appLogger.debug('Debugging Enabled. Jolan tru.')
    appLogger.debug('')


    command_to_run = None
    as_root = False
    compat_v1 = False
    wanted_dest = None
    should_run = False
    need_to_install = False
    add_nv = parsed_args.add_nvidia

    lower_layer = None

    if parsed_args.compat_v1:
        compat_v1 = True

    wanted_image = parsed_args.install_image
    if parsed_args.install_path:
        wanted_dest = parsed_args.install_path
        need_to_install = True

    if parsed_args.run_command:
        command_to_run = parsed_args.run_command
        should_run = True
    if parsed_args.run_command_root:
        command_to_run = parsed_args.run_command_root
        as_root = True
        should_run = True

    if parsed_args.launch:
        wanted_dest = parsed_args.launch
        should_run = True
    if parsed_args.launch_root:
        wanted_dest = parsed_args.launch_root
        as_root = True
        should_run = True

    if parsed_args.run_after:
        should_run = True
    if parsed_args.run_after_root:
        as_root = True
        should_run = True

    #if parsed_args.use_cvmfs:
    #    lower_layer = parsed_args.use_cvmfs
    #    should_run = True
    #    #cvmfs_sandbox(parsed_args.use_cvmfs, wanted_dest, None, True)
    #    #sys.exit(-200)

    #if parsed_args.run_interactive:
    #    wanted_dest = parsed_args.run_interactive
    #    should_run = True
    #if parsed_args.run_interactive_root:
    #    wanted_dest = parsed_args.run_interactive_root
    #    as_root = True
    #    should_run = True

    def platform_detection():
        plat_str = platform.platform()
        detected = False
        for _str in ['centos-7', '3.10.', '4.18.0', ]:
            if _str in plat_str:
                detected = True
                break
        return detected

    if platform_detection() and not compat_v1: 
        appLogger.warning('Detected older platform than EL9/UB22 defaulting back to compatability mode.')
        appLogger.warning('You won\'t be able to use anonymous user-mapping for this session.')
        appLogger.warning('To disable this warning, use the -compat cmd arg.')
        compat_v1 = True

    wanted_dest = os.path.abspath(wanted_dest)

    appLogger.debug('Looking in path: "%s"', wanted_dest)

    if parsed_args.run_path:
        wanted_dest = parsed_args.run_path
        should_run = True

    if not os.path.exists(wanted_dest):
        appLogger.info('Sandbox: "%s" does not exist.', wanted_dest)
        if not lower_layer:
            appLogger.info('Installing: "%s" at "%s"', wanted_image, wanted_dest)
            need_to_install = True
        else:
            appLogger.info('Using CVMFS: "%s"', lower_layer)
            need_to_install = False


    rc = False
    if need_to_install and not lower_layer:

        ## TODO
        ## Add some way of handling images from other sources
        ## This should identify docker images from docker://
        ## This will probably involve adding additional classes for Quay, Singularity, etc.
        ## Can safely default to assume most users just want a docker image

        # Construct Manager
        image_manager = DockerHub()

        image_lower = wanted_image.lower()
        if wanted_image != image_lower:
            appLogger.debug('Chaning search string to be lower-case! %s', image_lower)
            wanted_image = image_lower

        # Get data about which image we're about to pull
        image_name = wanted_image.split(':')[0]
        image_tag = wanted_image.split(':')[1]

        # Pull the image from the source to a temp folder
        image_manager.pullContainer(image_name, image_tag)

        # Extract the image to the destination path
        try:
            rc = image_manager.buildSandbox(image_name, image_tag, wanted_dest)
        except PermissionError as err:
            if appLogger.level == logging.DEBUG:
                raise err
            appLogger.error('Permission Denied. Normally this means we don\'t have write access to: "%s"', wanted_dest)
            sys.exit(19)


    if should_run:

        # We now plan to run a command or launch a shell
        rc = run_command(wanted_dest, command_to_run, as_root, compat_v1, add_nv, lower_layer)
        sys.exit(rc)

    sys.exit(0)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt as err:
        if appLogger:
            appLogger.error('Aborting due to user request.')
            if appLogger.level == appLogger.debug:
                print(err)
        else:
            print('Aborting due to user request.')

