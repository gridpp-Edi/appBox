#!/bin/env python3
# -*- coding: utf-8 -*-
# vim:fileencoding=utf-8
# pylint: disable=C0302,C0111,C0103
#
#   ▄▀▀█▄   ▄▀▀▄▀▀▀▄  ▄▀▀▄▀▀▀▄  ▄▀▀█▄▄   ▄▀▀▀▀▄   ▄▀▀▄  ▄▀▄
#  ▐ ▄▀ ▀▄ █   █   █ █   █   █ ▐ ▄▀   █ █      █ █    █   █
#    █▄▄▄█ ▐  █▀▀▀▀  ▐  █▀▀▀▀    █▄▄▄▀  █      █ ▐     ▀▄▀
#   ▄▀   █    █         █        █   █  ▀▄    ▄▀      ▄▀ █
#  █   ▄▀   ▄▀        ▄▀        ▄▀▄▄▄▀    ▀▀▀▀       █  ▄▀
#  ▐   ▐   █         █         █    ▐              ▄▀  ▄▀
#          ▐         ▐         ▐                  █    ▐
# - Written by Rob Currie <rob.currie(at)ed.ac.uk>
#
# This tool is designed to simplify the life of users looking to use
# container-like sandbox environments to do work, testing, hacking
# or just to have a play around.
# This was written to address several issues which all have the same solution,
# but the existing implementations are, well... ugly.
#
# USAGE:
#   Come one come all,
#     See appBox -h or README.md for some examples short&long, good&bad
#
# A tool for building&initializing sandboxes;
# fixing common gotchas
# and generaly allowing users to do more with what they have.
#
# Distributed under the GPLv2 only, but please don't remove attribution when using/modifying this.
#

import argparse
import datetime
import fcntl
from functools import wraps
import http.client
import json
import hashlib
import logging
import math
import os
import platform
import pty
import pwd
import re
import select
import shutil
import signal
import socket
import stat
import struct
import subprocess
import sys
import tarfile
import termios
import threading
import time
import tty
import urllib.request
import urllib.error
from urllib.parse import urlparse
import uuid


__version__ = '3.0.1'
appBoxVersion = __version__


# Global Logger(s)
appLogger = logging.getLogger('appBox')
barLogger = logging.getLogger('barLogger')
bgColour = '\033[1;32m'


class OneLineProgressHandler(logging.StreamHandler):
    '''
    Small class for handling progress bars in the terminal
    '''
    def emit(self, record):
        '''
        Emit a record with carriage return to overwrite the current line.
        '''
        message = self.format(record)
        stream = self.stream
        stream.write(f'\r{message}')  # Overwrite the current line
        stream.flush()


def getUN() -> str:
    '''
    Return the username of this account
    '''
    return pwd.getpwuid(os.getuid())[0]


def getHome() -> str:
    '''
    Return the home directory of this account
    '''
    return pwd.getpwuid(os.getuid())[5]


def findMountPath(path) -> str:
    '''
    Find the mount path for a given path
    '''
    path = os.path.abspath(path)
    while not os.path.ismount(path):
        path = os.path.dirname(path)
    return path


def printBar(iteration : int, total : int, prefix : str='',
             suffix : str='', length : int=50, fill : str='█') -> None:
    '''
    Call in a loop to create terminal progress bar
    @params:
        iteration   - Required  : current iteration (Int)
        total       - Required  : total iterations (Int)
        prefix      - Optional  : prefix string (Str)
        suffix      - Optional  : suffix string (Str)
        length      - Optional  : character length of bar (Int)
        fill        - Optional  : bar fill character (Str)
    '''
    if total<=0:
        total = 1
    percent = 100 * (iteration / float(total))
    percent = f"{round(percent, 2)}"
    filled_length = int(length * iteration // total)
    barStr = fill * filled_length + '-' * (length - filled_length)
    #if appLogger.level <= logging.INFO:
    #barLogger.info(f'{prefix} |{bar}| {percent}% {suffix}')
    barLogger.info('%s |%s| %s%% %s', prefix, barStr, percent, suffix)
    # Print New Line on Complete
    if iteration == total:
        barLogger.info('\n')


def bytesToHuman(num_bytes : int) -> str:
    '''
    Convert bytes to human readable format
    '''
    # Define size units
    units = ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']
    size = num_bytes
    unit_index = 0

    # Loop to determine the appropriate unit
    while size >= 1024 and unit_index < len(units) - 1:
        size /= 1024.0
        unit_index += 1

    # Format the result to 2 decimal places
    return f"{size:.2f} {units[unit_index]}B"


class downloadTokenAuthenticator:

    def __init__(self, repoURL : str="https://example.com", imagePath : str="project/image"):
        '''
        Note: This is a very basic implementation of the Docker Registry V2 API
        '''
        self.token = ""
        self.repoURL = repoURL
        self.imagePath = imagePath
        self.tokenRequired = True
        self.authRealm = ""
        self.authService = ""
        self.authScope = ""
        self.manifestPath = f"/v2/{self.imagePath}/manifests/latest"
        self.tokenExpiry = time.time() - 300  # Assume token is valid for 5min
        #self.getNewToken()

    def _getAuthnService(self) -> None:
        '''
        This method gets the authentication service for the registry
        '''
        appLogger.debug("1) Getting Authn Service: %s", self.repoURL)
        parsedURL = urllib.parse.urlsplit(self.repoURL)
        if (parsedURL.hostname is None) and (parsedURL.netloc is not None):
            remoteHost = parsedURL.netloc
        else:
            remoteHost = parsedURL.hostname
        appLogger.debug(parsedURL)
        appLogger.debug("2) Getting Authn Service: %s", remoteHost)
        conn = http.client.HTTPSConnection(remoteHost,
                                           port=parsedURL.port if parsedURL.port else 443)
        appLogger.debug("Querying Authn Service: %s", self.manifestPath)

        i = 0
        while i < 3:
            try:
                i += 1
                conn.request("GET", self.manifestPath)
                break
            except socket.gaierror as err:
                appLogger.error('Failed to connect to: %s', remoteHost)
                appLogger.error('Error: %s', err)
                if i == 2:
                    #pylint: disable=W0707
                    raise ConnectionError(f'Failed to connect to: "{remoteHost}"')
                #raise ConnectionError(f'Failed to connect to: "{remoteHost}"')

        response = conn.getresponse()
        if response.status == 401:
            authHeader = response.getheader('www-authenticate')
            appLogger.debug("Auth Header: %s", authHeader)
            if authHeader:
                match = re.match('[ \t]*([^ \t]+)[ \t]+realm="([^"]*)"', authHeader)
                scheme, realm = match.groups()
                if scheme.lower() != 'bearer':
                    raise ConnectionError(
                        f'Unknown Auth Scheme: "{scheme}" Returned by: "{self.repoURL}"')

                match = re.match('.*service="([^"]*)"', authHeader)
                service = match.groups()[0]
                match = re.match('.*scope="([^"]*)"', authHeader)
                scope = match.groups()[0]

                self.authRealm = realm
                self.authService = service
                self.authScope = scope

        elif response.status >=200 and response.status <= 299:
            self.tokenRequired = False

        elif response.status in [307, 308]:

            raise ConnectionError(f'Redirected to: "{response.getheader("Location")}"')

    def _getDownloadToken(self) -> None:
        '''
        This method gets the download token for the registry
        '''

        fullTokenURL = f'{self.authRealm}?service={self.authService}&scope={self.authScope}'
        parsedURL = urllib.parse.urlsplit(fullTokenURL)

        appLogger.debug('token: "%s", "%s"', fullTokenURL, parsedURL)
        if (parsedURL.hostname is None) and (parsedURL.netloc is not None):
            remoteHost = parsedURL.netloc
        else:
            remoteHost = parsedURL.hostname
        appLogger.debug("3) Getting Authn Service: %s", remoteHost)
        conn = http.client.HTTPSConnection(remoteHost,
                                           port=parsedURL.port if parsedURL.port else 443)
        appLogger.debug("Querying Authn Service: %s?%s", parsedURL.path, parsedURL.query)
        conn.request("GET", parsedURL.path + '?' + parsedURL.query)
        response = conn.getresponse()
        tokenResponse = response.read()

        #appLogger.debug("Querying Token: %s", fullTokenURL)
        #tokenResponse = urllib.request.urlopen(urllib.request.Request(
        #    fullTokenURL,
        #)).read()
        #appLogger.debug("Token Response: %s", tokenResponse)

        self.token = json.loads(tokenResponse.decode())['token']

        appLogger.debug("Token: %s",self.token)

    def getNewToken(self) -> None:
        '''
        Get a new token for the registry
        '''

        if self.tokenRequired:
            self._getAuthnService()
            self._getDownloadToken()
        else:
            return

    def isTokenValid(self) -> bool:
        '''
        Check if the token is still valid
        '''
        return time.time() < self.tokenExpiry

    def refreshToken(self) -> None:
        '''
        Refresh the token if needed
        '''
        if self.tokenRequired:
            if not self.isTokenValid():
                self.getNewToken()
        else:
            self.token = None

        self.tokenExpiry = time.time() + 300


class imageManager:
    '''
    Class for managing images, downloading, extracting, etc...
    '''

    def __init__(self, imagePath : str="almalinux:9",
                 installPath : str ='', layerCacheFolder : str='', forceUpdate : bool=False):
        '''
        Initialize the image manager instance
        '''

        self.userPath = imagePath
        self.imgHash = hashlib.sha256(imagePath.encode()).hexdigest()
        if forceUpdate:
            self.imgHash = 'forceUpdate'

        appLogger.debug('Image Hash: %s', self.imgHash)

        parsedImage = imageManager.parseImgString(imagePath)
        appLogger.debug('Using image String: %s', imagePath)
        appLogger.debug('Parsed Image: %s', parsedImage)
        self.downloadService = parsedImage[0] + '://' + parsedImage[1]
        self.imagePath = parsedImage[2]
        self.imageTag = parsedImage[3]

        userName = pwd.getpwuid(os.getuid())[0]
        if not layerCacheFolder:
            self.layerCacheFolder = os.path.join(os.path.join('/tmp', 'appBox_'+userName),
                                                 'layerCache')
        else:
            self.layerCacheFolder = layerCacheFolder

        if not os.path.exists(self.layerCacheFolder):
            os.makedirs(self.layerCacheFolder)

        if not installPath:
            self.installPath = os.path.join(os.path.join('/scratch', 'appBox_'+userName), 'sandbox')
            if not os.path.exists(os.path.dirname(self.installPath)):
                self.installPath = os.path.join(getHome(), 'sandbox')
        else:
            self.installPath = installPath

        self.authenticator = downloadTokenAuthenticator(self.downloadService, self.imagePath)

    @staticmethod
    def isUrl(candidate : str) -> bool:
        '''
        Check if the given string is a URL, even if it doesn't have a protocol.
        '''
        urlPattern = re.compile(
            r'^(https?|ftp)?(:\/\/)?'
            r'(([a-zA-Z0-9_-]+\.)+[a-zA-Z]{2,6})'
            r'(:\d+)?(/.*)?$'
        )
        return re.match(urlPattern, candidate) is not None

    @staticmethod
    def isLabel(candidate : str) -> bool:
        '''
        Check if the given string is a DockerHub label.
        '''
        dockerhubLabelPattern = re.compile(
            r'^[a-z0-9]+([._-][a-z0-9]+)*(/[a-z0-9]+([._-][a-z0-9]+)*)?(:[a-zA-Z0-9_.-]+)?$'
        )
        return re.match(dockerhubLabelPattern, candidate) is not None

    @staticmethod
    def parseImgString(image : str) -> tuple:
        '''
        Method to parse strings for images, urls, dockerhub label:tags, etc... 
        '''

        imgUrl = imageManager.isUrl(image)
        imgLabel = imageManager.isLabel(image)

        if (not imgLabel) and (not imgUrl):
            raise ValueError(f'Image: "{image}" is not a valid image string')

        if imgLabel and not imgUrl:
            image = 'https://registry-1.docker.io/' + image

        if imgUrl and '://' not in image:
            image = 'https://' + image

        appLogger.debug('Using URL: %s', image)

        parsedURI = urlparse(image)
        appLogger.debug('Parsed URI: %s', parsedURI)

        if parsedURI.scheme != "":
            realScheme = parsedURI.scheme
        else:
            realScheme = 'https'

        appLogger.debug('Adjusted Parsed URI: %s', parsedURI)

        realNetLoc = parsedURI.netloc
        if realNetLoc == "":
            realNetLoc = 'registry-1.docker.io'

        urlPath = parsedURI.path
        if urlPath.startswith('/'):
            urlPath = urlPath[1:]

        imageData = urlPath.split(':')
        imageLabel = imageData[0]

        if len(imageData) == 1:
            tag = 'latest'
        else:
            tag = imageData[1]

        if len(imageLabel.split('/')) == 1:
            imageLabel = 'library/' + imageLabel

        if appLogger.level == logging.DEBUG:
            appLogger.debug('Parsed Image: %s', image)
            appLogger.debug('Parsed Scheme: %s', realScheme)
            appLogger.debug('Parsed NetLoc: %s', realNetLoc)
            appLogger.debug('Parsed Label: %s', imageLabel)
            appLogger.debug('Parsed Tag: %s', tag)

        return realScheme, realNetLoc, imageLabel, tag

    #@staticmethod This makes Python 3.9 unhappy
    def tokenRequired(func : callable): # pylint: disable=E0213
        '''
        Decorator to check if a token is required and refresh it if needed
        '''
        @wraps(func)
        def decorated_function(*args, **kwargs):
            self = args[0]
            self.authenticator.refreshToken()
            return func(*args, **kwargs) # pylint: disable=E1102
        return decorated_function

    @staticmethod
    def getHeaders(token: str='') -> dict:
        '''
        Get the headers for the request
        '''
        returnable = {
                 "Accept":
        "application/vnd.docker.distribution.manifest.v2+json,"+
        "application/vnd.oci.image.manifest.v1+json," +
        "application/vnd.oci.image.config.v1+json,"+
        "application/vnd.docker.distribution.manifest.v1+prettyjws",
                 "Authorization": f"Bearer {token}",
                 "Content-Type": "application/json",
                 "User-Agent": "curl/8.0.1",
        }
        if not token:
            del returnable['Authorization']
        return returnable

    def getManifest(self, manifestVer : str='') -> str:
        '''
        Get the manifest for the image
        '''

        manCache = os.path.join(self.layerCacheFolder, self.imgHash)

        if not manifestVer:
            manifestVer = self.imageTag

        contents = {}

        if os.path.exists(manCache):
            with open(manCache, 'r', encoding="utf-8") as _file:
                contents = json.loads(_file.read())
                #appLogger.debug('Manifest Cache: %s', contents)

            if manifestVer in contents:
                return contents[manifestVer]
            else:
                remoteMan = self.getRemoteManifest(manifestVer)

        else:
            remoteMan = self.getRemoteManifest(manifestVer)

        contents[manifestVer] = remoteMan

        with open(manCache, 'w', encoding="utf-8") as _file:
            _file.write(json.dumps(contents))

        return contents[manifestVer]

    def cacheManifest(self, path: str) -> None:
        '''
        Cache the manifest for the image at a given path
        '''
        cachePath = os.path.join(path, self.imgHash)
        if os.path.exists(cachePath):
            return

        with open(cachePath, 'w', encoding="utf-8") as _file:
            _file.write(self.getManifest())

    def cacheConfig(self, path: str) -> None:
        '''
        Cache the config for the image at a given path
        '''
        _, digest = self.getConfigHash()
        cachePath = os.path.join(path, digest)
        if os.path.exists(cachePath):
            return

        with open(cachePath, 'w', encoding="utf-8") as _file:
            _file.write(json.dumps(self.getConfig()))

    @tokenRequired
    def getRemoteManifest(self, manifestVer : str='') -> str:
        '''
        Get the manifest for the image
        '''

        if not manifestVer:
            manifestVer = self.imageTag

        parsedURL = urlparse(self.downloadService)
        manifestPath = f"/v2/{self.imagePath}/manifests/{manifestVer}"

        appLogger.debug("Connecting to Manifest Service: %s", parsedURL.netloc)
        conn = http.client.HTTPSConnection(parsedURL.netloc)

        appLogger.debug("Querying Manifest Service: %s", manifestPath)
        headers = imageManager.getHeaders(self.authenticator.token)

        appLogger.debug("Headers: %s", headers)
        conn.request("GET", manifestPath, headers=headers)

        response = conn.getresponse()
        thisResponse = response.read()
        appLogger.debug("Manifest Response: %s", thisResponse)

        return thisResponse.decode('utf-8')

    @staticmethod
    def checkDownloadIntegrity(downloadLocation : str, refShasum : str) -> bool:
        '''
        Check the integrity of the downloaded file
        '''

        def compute_sha256(filepath : str) -> str:
            '''
            Compute the SHA256 checksum of a file
            '''
            sha256_hash = hashlib.sha256()
            with open(filepath, "rb") as file:
                # Read the file in chunks to handle large files
                # Try reading with 16k blocks
                # TODO add adjustments for block size on error
                for byte_block in iter(lambda: file.read(16384), b""):
                    sha256_hash.update(byte_block)
                return sha256_hash.hexdigest()

        def verify_file_sha256(filepath : str, reference_sha256: str) -> bool:
            '''
            Verify the SHA256 checksum of a file
            '''
            computed_sha256 = compute_sha256(filepath)
            if computed_sha256 == reference_sha256:
                appLogger.debug("The file's SHA256 checksum matches the reference.")
                return True
            else:
                appLogger.error("The file's SHA256 checksum does NOT match the reference.")
                appLogger.error("Computed SHA256: %s", computed_sha256)
                appLogger.error("Reference SHA256: %s", reference_sha256)
                return False

        return verify_file_sha256(downloadLocation, refShasum)

    def getLayerFileName(self, digest : str) -> str:
        '''
        Get the filename for the layer
        '''
        return os.path.join(self.layerCacheFolder, f"{digest}.tar.gz")

    @tokenRequired
    def downloadLayers(self, digests : list, retry : bool=True,
                       retryCount : int=3, retryDelay : int=0) -> bool:
        '''
        Download the layers for the image
        '''

        i=0
        for images in digests:
            i+=1

            appLogger.info('Downloading Layer: %s of %s', i, len(digests))
            digest = images['digest']
            retryNum = retryCount

            success = False
            skipped = False
            outputFile = self.getLayerFileName(digest)
            try:
                if os.path.exists(outputFile):
                    appLogger.info("Layer already downloaded: %s", outputFile)
                    skipped = True
                    continue
                else:
                    while retry and (retryNum > 0):
                        try:
                            appLogger.debug('Download Attempt: %s', retryNum)
                            retryNum -= 1
                            _ = self._downloadLayer(digest)
                            success = True
                            break
                        except Exception as err: # pylint: disable=W0703
                            appLogger.debug('Exception raised when downloading: %s', err)
                            time.sleep(retryDelay)
                            self.authenticator.refreshToken()
                        except KeyboardInterrupt as err:
                            appLogger.error('Download Cancelled by User')
                            appLogger.debug('Exception raised when downloading: %s', err)
                            return False
            finally:
                if not success:
                    try:
                        os.unlink(outputFile+'.tmp')
                        os.unlink(outputFile)
                    except FileNotFoundError:
                        pass
                else:
                    appLogger.debug('Successfully Downloaded Layer: %s', digest)
                    if not skipped:
                        os.rename(outputFile+'.tmp', outputFile)
        return True

    def _downloadLocation(self, host : str, port : int, path : str,
                          query : str, outputFile : str, digestSha : str) -> None:
        '''
        Download the layer from the given location
        '''

        conn = http.client.HTTPSConnection(host, port=port if port else 443)
        appLogger.debug("Querying Authn Service: %s", path)
        appLogger.debug("Query: %s", query)

        if 'X-Amz-SignedHeaders' in query:
            appLogger.debug("Using AWS Signed Query for Auth'n")
            conn.request("GET", path+'?'+query)
        else:
            appLogger.debug("Using Standard Headers for Auth'n")
            conn.request("GET", path+'?'+query,
                     headers=imageManager.getHeaders(self.authenticator.token))
        response = conn.getresponse()

        contentLength = response.getheader('Content-Length')
        if contentLength is not None:
            contentLength = int(contentLength)

        appLogger.info("Downloading Layer %s Size: %s", digestSha, bytesToHuman(contentLength))

        if response.status == 200:
            total=math.ceil(contentLength/4096)
            # Initial call to print 0% progress
            printBar(0, total, prefix = 'Downloading:', suffix = 'Complete', length = 50)
            # Open the output file for writing
            with open(outputFile, 'wb') as file:
                # Read the response in blocks and write to the file
                i=0
                while True:
                    block = response.read(4096)
                    if not block:
                        break
                    file.write(block)
                    i+=1
                    printBar(i, total, prefix = 'Downloading:',
                             suffix = 'Complete', length = 50)
        else:
            appLogger.debug("Failed to download layer: %s", response.read())
            appLogger.debug("%s", response)
            raise ConnectionError(f'Failed to download layer: "{response.status}"')

        if not imageManager.checkDownloadIntegrity(outputFile, digestSha):
            raise ConnectionError('Failed to download layer: "checksum failure"')

    def _downloadLayer(self, digest : str) -> bool:
        '''
        Download the layer from the given location
        '''

        digestSha = digest.split(':')[1]

        outputFile = self.getLayerFileName(digest) + '.tmp'

        imagePath = f"/v2/{self.imagePath}/blobs/{digest}"

        appLogger.debug("Connecting to Download Service: %s",
                        self.downloadService)
        parsedURL = urllib.parse.urlsplit(self.downloadService)
        conn = http.client.HTTPSConnection(parsedURL.hostname,
                                           port=parsedURL.port if parsedURL.port else 443)
        appLogger.debug("Querying Authn Service: %s", imagePath)

        conn.request("GET", imagePath,
                     headers=imageManager.getHeaders(self.authenticator.token))
        response = conn.getresponse()

        if response.status == 200:
            self._downloadLocation(parsedURL.hostname, parsedURL.port,
                                   imagePath, '', outputFile, digestSha)
        elif response.status == 307:

            appLogger.debug("Redirected to: %s", response.getheader("Location"))
            relocated = response.getheader("Location")

            appLogger.debug("Connecting to Download Service: %s", relocated)
            parsedURL = urllib.parse.urlsplit(relocated)

            self._downloadLocation(parsedURL.hostname, parsedURL.port,
                                   parsedURL.path, parsedURL.query, outputFile, digestSha)

        else:
            appLogger.debug(response.headers)
            raise ConnectionError(f'Failed to download layer: "{response.status}"')

        return True

    @staticmethod
    def getArch() -> str:
        '''
        Get the architecture of the system
        '''
        if platform.machine().lower() in ['amd64', 'x86_64']:
            return 'amd64'
        elif platform.machine().lower() in ['aarch64', 'arm64']:
            return 'arm64'

    def getDigest(self, manifest : str) -> tuple:
        '''
        Get the digest for the layers in the manifest
        '''

        digestList = []
        thisConfig = ''

        ## '.fsLayers[]' | jq -r '.blobSum'
        ## Read the blobSum and return

        ## '.layers[0]' | jq -r '.digest'
        ## Read the digest from the layers and return
        #appLogger.debug('Manifest: %s', manifest)

        if 'errors' in manifest:
            errs = manifest['errors']
            raise Exception(f'Error in Manifest: {errs}') # pylint: disable=W0719

        if 'layers' in manifest:
            for thisLayer in manifest['layers']:
                digestList.append({'mediaType': thisLayer['mediaType'],
                                    'digest': thisLayer['digest']})
        if 'fsLayers' in manifest:
            for thisLayer in manifest['fsLayers']:
                digestList.append({'mediaType': 'application/vnd.docker.image.rootfs.diff.tar.gzip',
                                    'digest': thisLayer['blobSum']})

        if 'config' in manifest:
            thisConfig = manifest['config']['digest']

        ## '.manifest[0]' | jq -r '.digest'
        ## Read the manifest, get the correct digests and return
        elif 'manifests' in manifest:
            thisArch = self.getArch()
            appLogger.debug('Detected System arch: %s', thisArch)
            for _manifest in manifest['manifests']:
                if _manifest['platform']['architecture'] == thisArch:
                    thisCSum = _manifest['digest']

                    imageManifest = self.getManifest(thisCSum)
                    appLogger.debug('Image Manifest: %s', imageManifest)
                    return self.getDigest(json.loads(imageManifest))

        #raise Exception('here')
        return digestList, thisConfig

    def getConfigHash(self) -> str:
        '''
        Get the hash for the config
        '''
        imageManifest = self.getManifest()
        _, digest = self.getDigest(json.loads(imageManifest))

        appLogger.debug('Config: %s', digest)

        configPath = self.getLayerFileName(digest)[:-7]

        return configPath, digest

    def getConfig(self) -> dict:
        '''
        Get the config for the image
        '''

        _content = {}

        configPath, digest = self.getConfigHash()

        if not os.path.exists(configPath):
            self._downloadConfig(digest)

        with open(configPath, 'r', encoding="utf-8") as _file:
            _content = json.loads(_file.read())
            #appLogger.debug('Config Content: %s', _content)

        appLogger.debug('Config _content: %s', _content)
        appLogger.debug('Container ENV: %s', _content['config'].get('Env', 'NOT_DEFINED'))

        return _content

    def _downloadConfig(self, digest : str) -> None:
        '''
        Download the config for the image
        '''

        success = False
        try:
            self._downloadLayer(digest)
            success = True
        finally:
            if not success:
                try:
                    os.unlink(self.getLayerFileName(digest)+'.tmp')
                    os.unlink(self.getLayerFileName(digest))
                except FileNotFoundError:
                    pass

        os.rename(self.getLayerFileName(digest)+'.tmp', self.getLayerFileName(digest)[:-7])

    def downloadImage(self) -> list:
        '''
        Download the image layers
        '''

        imageManifest = self.getManifest()

        imageDigests, _ = self.getDigest(json.loads(imageManifest))

        self.getConfig()

        appLogger.debug('Image Digests: %s', imageDigests)

        if self.downloadLayers(imageDigests):
            appLogger.debug('Returning Image Digests: %s', imageDigests)
            return imageDigests
        else:
            return []

    def extractImage(self, overridePath : str='') -> int:
        '''
        Extract the image layers
        '''

        installPath = overridePath if overridePath else self.installPath

        if os.path.exists(installPath):
            appLogger.error("Install Path already exists: %s", installPath)
            raise FileExistsError(f'Install Path already exists: "{installPath}"')

        try:
            return self._extractLayers(installPath)
        except Exception as err: # pylint: disable=W0703
            appLogger.error('Failed to extract layers: %s', err)
            if appLogger.level == logging.DEBUG:
                raise
            if os.path.exists(installPath):
                appLogger.error('Cleaning up: %s', installPath)
                shutil.rmtree(installPath)
            return 1

    def _extractLayers(self, installPath : str) -> int:
        '''
        Extract the layers for the image
        '''

        layer_i=0
        images = self.downloadImage()
        img_num = len(images)
        for layer in images:
            layer_i+=1

            layerFile = self.getLayerFileName(layer['digest'])

            layerSize = os.path.getsize(layerFile)
            appLogger.info('Opening Layer (%s/%s): %s (%s)',
                           layer_i, img_num, layerFile, bytesToHuman(layerSize))

            with tarfile.open(layerFile, 'r:gz', errorlevel=1) as _tfile:

                #appLogger.debug('Counting...')
                total=0
                for _entry in _tfile:
                    total+=1
                appLogger.info('#%s Files/Folders', total)
                if total == 0:
                    continue
                #total = layerSize

                printBar(0, total, prefix = 'Extracting:', suffix = 'Complete', length = 50)
                i=0
                for _entry in _tfile:
                    i+=1
                    printBar(i, total, prefix = 'Extracting:', suffix = 'Complete', length = 50)
                    #total=len(_tfile.getmembers())
                    #if i%100 == 0:
                    #    appLogger.debug('Extracting: %s/%s', i, total)
                    #i+=1
                    #appLogger.debug('Extracting: {}'.format(_entry.name))
                    if _entry.isdir():
                        os.makedirs(os.path.join(installPath, _entry.name), exist_ok=True)
                    else:
                        # Check if we're overwriting a file
                        if os.path.exists(os.path.join(installPath, _entry.name)):
                            os.remove(os.path.join(installPath, _entry.name))

                        # Check path exists before extracting
                        parent = os.path.dirname(os.path.join(installPath, _entry.name))
                        os.makedirs(os.path.join(installPath, parent), exist_ok=True)

                        # Handle permissions
                        if not (_entry.issym() or _entry.islnk()):
                            current = stat.S_IMODE(os.lstat(parent).st_mode)
                            os.chmod(parent, current | stat.S_IWUSR | stat.S_IRUSR | stat.S_ISGID)

                        # Handle python security issues
                        try:
                            _tfile.extract(_entry, path=installPath, filter='fully_trusted')
                        except TypeError:
                            try:
                                _tfile.extract(_entry, path=installPath)
                            except PermissionError:
                                appLogger.debug('Permission Error on extracting file: %s',
                                                _entry.name)
                                continue
                        except PermissionError:
                            appLogger.debug('Permission Error on extracting file: %s', _entry.name)
                            continue

                        # Handle permissions again after extraction
                        if not (_entry.issym() or _entry.islnk()):
                            output = os.path.join(installPath, _entry.name)
                            current = stat.S_IMODE(os.lstat(output).st_mode)
                            os.chmod(output, current | stat.S_IWUSR | stat.S_IRUSR | stat.S_ISGID)
        return 0


class sessionManager:
    '''
    Class for managing interactive sandbox sessions
    '''

    def __init__(self, sandboxPath : str, compatV1 : bool=False,
                 addNV : bool=False, rootfs : str=''):
        '''
        Standard __init__ :)
        '''
        self.proc = None
        self.pidParent = None
        self.pidChild = None
        self.oldTTY = None
        self.sandboxPath = sandboxPath
        self.compatV1 = compatV1
        self.addNVidia = addNV

        self.stdoutM, self.stdoutS = None, None
        self.running = False

        self.proc2 = None
        self.pidSubChild, self.pidSubParent = None, None

        self.rootfs = rootfs
        self._layers = ['._appBoxLayers/overlay', '._appBoxLayers/upper', '._appBoxLayers/work']

        self.ptyMfd, self.ptySfd = None, None

    def getSandboxPath(self) -> str:
        '''
        Return the path to the sandbox
        '''
        if self.rootfs:
            rootFS = os.path.join(self.sandboxPath, '._appBoxLayers/overlay')
            #appLogger.debug('Sandbox Path: %s', rootFS)
            return rootFS
        else:
            #appLogger.debug('Sandbox Path: %s', self.sandboxPath)
            return self.sandboxPath

    def setraw(self, fd : str, when : int=termios.TCSAFLUSH) -> None:
        '''
        Put terminal into a raw mode.
        '''

        # Indexes for termios list.
        iFLAG = 0
        #OFLAG = 1
        cFLAG = 2
        lFLAG = 3
        #ISPEED = 4
        #OSPEED = 5
        cc = 6

        mode = termios.tcgetattr(fd)
        mode[iFLAG] = mode[iFLAG] & ~(termios.BRKINT | termios.ICRNL |
                                      termios.INPCK | termios.ISTRIP | termios.IXON)
        #mode[OFLAG] = mode[OFLAG] & ~(termios.OPOST)
        mode[cFLAG] = mode[cFLAG] & ~(termios.CSIZE | termios.PARENB)
        mode[cFLAG] = mode[cFLAG] | termios.CS8
        mode[lFLAG] = mode[lFLAG] & ~(termios.ECHO | termios.ICANON |
                                      termios.IEXTEN | termios.ISIG)
        mode[cc][termios.VMIN] = 1
        mode[cc][termios.VTIME] = 0
        termios.tcsetattr(fd, when, mode)

    def _wrangleTTY(self) -> None:
        '''
        This is some boiler-plate for setting up a pTTY
        '''

        # save original tty setting then set it to raw mode
        oldTTY = termios.tcgetattr(sys.stdin)
        #tty.setraw(sys.stdin.fileno())
        self.setraw(sys.stdin.fileno(), when=termios.TCSANOW)

        # open pseudo-terminal to interact with subprocess
        stdoutMfd, stdoutSfd = pty.openpty()

        size = os.get_terminal_size()
        winsize = struct.pack("HHHH", size[1], size[0], 0, 0)

        fcntl.ioctl(stdoutMfd, termios.TIOCSWINSZ, winsize)

        appLogger.debug('Opening PTY')

        self.oldTTY = oldTTY
        self.stdoutM, self.stdoutS = stdoutMfd, stdoutSfd

    def setupHostSpace(self) -> tuple:
        '''
        This sets up a 'root' namespace.
        This persists for the lifetime of this shell.
        '''

        if self.rootfs:
            for _layer in self._layers:
                thisLayer = os.path.join(self.sandboxPath, _layer)
                if not os.path.exists(thisLayer):
                    os.makedirs(thisLayer)

        backgroundTask='/bin/bash'
        appLogger.debug('Launching host namespace manager')
        hostManager=f"unshare -primf --propagation unchanged {backgroundTask}"
        appLogger.debug(hostManager)
        # pylint: disable=locally-disabled, subprocess-popen-preexec-fn
        self.proc = subprocess.Popen(hostManager,
                                     shell=True, preexec_fn=os.setsid,
                                     stdin = subprocess.PIPE,
                                     stdout = subprocess.PIPE,
                                     stderr = subprocess.PIPE,
                                     universal_newlines = True)

        appLogger.debug('Host sandbox namespace: %s', self.proc.pid)
        self.pidParent=self.proc.pid
        time.sleep(0.05)

        parentID = self.pidParent
        childID = parentID
        while True:

            appLogger.debug('Parent PID: %s', parentID)
            appLogger.debug('Child PID: %s', childID)
            try:
                parentID, childID = self.getChildID(childID)
                self.pidChild = childID
            except (OSError, ValueError) as pidErr:
                appLogger.debug('Error: %s', pidErr)
                break
            time.sleep(0.05)

            appLogger.debug('---')

        if not self.pidChild:
            raise SystemError('Cannot Fork Child Process. Are you trying to run inside appBox?')

        return self.pidParent, self.pidChild

    def _copyToFromSandbox(self, source : str, dest : str,
                           overwrite : bool=False) -> None:
        '''
        Copy files from A to B
        '''
        if overwrite:
            copyCMD = f'cp -rfHL --remove-destination {source} {dest}'
        else:
            copyCMD = f'cp -rHL {source} {dest}'

        if os.path.abspath(source) == os.path.abspath(dest):
            appLogger.debug('Source and Destination are the same: %s', source)
            return 0

        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s',
                            self.pidChild, copyCMD)

        copyProc = subprocess.Popen(
                f'nsenter --preserve-credentials --user --mount --pid -t {self.pidChild} {copyCMD}',
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        copyProc.wait()
        copyRC = copyProc.poll()
        appLogger.debug('Copy RC: %s', copyRC)
        appLogger.debug('Copy out: %s', copyProc.stdout.read())
        appLogger.debug('Copy err: %s', copyProc.stderr.read())
        del copyProc
        return copyRC

    def copyFileFromHost(self, hostFile : str, sandboxFile : str,
                         overwrite : bool=False) -> None:
        '''
        Copy a file from the host into the sandbox
        '''
        i=0
        while os.path.islink(hostFile):
            appLogger.debug('Symlink: %s -> %s', hostFile, os.readlink(hostFile))
            hostFile = os.readlink(hostFile)
            i=i+1
            if i>10:
                break
        if i>10:
            appLogger.error('Too many symlinks in file: %s', hostFile)
            return

        rc = self._copyToFromSandbox(hostFile, sandboxFile, overwrite)

        if rc != 0:
            appLogger.error('Failed to Copy File: %s -> %s', hostFile, sandboxFile)
            raise IOError('Failed to Copy File')

    def copyFileToHost(self, sandboxFile : str, hostFile : str) -> None:
        '''
        Copy a file from a Sandbox to the host
        '''
        sandboxFile = os.path.join(self.getSandboxPath(), '.'+sandboxFile)
        rc = self._copyToFromSandbox(sandboxFile, hostFile)

        if rc != 0:
            appLogger.error('Failed to Copy File: %s -> %s', hostFile, sandboxFile)
            raise IOError('Failed to Copy File')

    def removeFromSandBox(self, path : str) -> None:
        '''
        Remove a file from the sandbox
        '''
        if not os.path.exists(path):
            #appLogger.debug('Path does not exist: %s', path)
            return

        removeCMD = f'rm -rf {path}'
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s',
                            self.pidChild, removeCMD)

        removeProc = subprocess.Popen(
            f'nsenter --preserve-credentials --user --mount --pid -t {self.pidChild} {removeCMD}',
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        removeProc.wait()
        removeRC = removeProc.poll()
        appLogger.debug('Remove RC: %s', removeProc.poll())
        del removeProc

        if removeRC != 0:
            appLogger.debug('Failed to Remove Path: %s', path)
            raise IOError('Failed to Remove Path')

    def createSandboxPath(self, path : str, overridePID : int=-1) -> None:
        '''
        Create a new path within the sandbox
        '''
        if os.path.isdir(path):
            appLogger.debug('Path already exists: %s', path)
            return
        pidSpace = self.pidChild
        if overridePID > 0:
            pidSpace = overridePID
        createCMD = f'mkdir -p {os.path.abspath(path)}'
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s',
                            pidSpace, createCMD)

        createProc = subprocess.Popen(
                f'nsenter --preserve-credentials --user --mount --pid -t {pidSpace} {createCMD}',
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        createProc.wait()
        createRC = createProc.poll()
        appLogger.debug('CreatePath RC: %s', createProc.poll())
        del createProc

        if createRC != 0:
            appLogger.error('Failed to Create Path: %s', path)
            raise IOError('Failed to Create Path')

    def createSandboxEmptyFile(self, path : str) -> None:
        '''
        Create an empty 'stub' file in the sandbox
        '''
        createCMD = f'touch {os.path.abspath(path)}'

        createProc = subprocess.Popen(
            f'nsenter --preserve-credentials --user --mount --pid -t {self.pidChild} {createCMD}',
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        createProc.wait()
        createRC = createProc.poll()
        appLogger.debug('CreateFile RC: %s', createProc.poll())
        del createProc

        if createRC != 0:
            appLogger.error('Failed to Create File: %s', path)
            raise IOError('Failed to Create File')

    def getChildID(self, thisPID : int) -> tuple:
        '''
        Get the child ID of a given PID
        '''
        childPIDPath = f'/proc/{thisPID}/task/{thisPID}/children'
        appLogger.debug('Querying ID: %s', childPIDPath)
        with open(childPIDPath, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('File: "%s"', childPIDPath)
            appLogger.debug('Content: "%s"', _content)
            childPid = int(_content)
            appLogger.debug('PID: %s', childPid)

        return thisPID, childPid

    def getSharePaths(self) -> list:
        '''
        This is a list of directories to be mounted into the sandbox from the host
        '''
        _home = getHome()
        homeMount = findMountPath(_home)

        mounts = ['/afs', '/home', '/tmp', '/dev', '/cvmfs',
                  '/scratch', '/Data', '/localdisk', '/sys', '/mnt',
                  '/mnt/wsl', '/mnt/wslg']
        if _home not in mounts:
            mounts += [_home,]
        if homeMount != '/' and (homeMount not in mounts):
            mounts += [homeMount,]
        appLogger.debug('SharePaths: %s', mounts)
        if self.addNVidia:
            mounts += ['/usr/lib/wsl', '/usr/bin/nvidia-smi', '/usr/bin/nvidia-modprobe']
        return mounts

    def mountHost(self, overridePID : int=-1) -> None:
        '''
        Mount the shared paths between the host and the sandbox namespace
        '''
        hostMounts = self.getSharePaths()

        hostMounts = list(zip(hostMounts,hostMounts))
        hostMounts.append(('/', '/hostfs'))

        for hostPath, guestPath in hostMounts:

            sandboxPath = os.path.abspath(os.path.join(self.getSandboxPath(), '.' + guestPath))

            if not os.path.exists(hostPath):
                appLogger.debug('Skipping path %s, as it doesn\'t exist on the host', hostPath)
                continue

            appLogger.debug('Bind Mounting: %s as: %s', hostPath, sandboxPath)
            if os.path.isdir(hostPath):
                self.createSandboxPath(sandboxPath, overridePID)
            else:
                self.createSandboxEmptyFile(sandboxPath)

            pidSpace = self.pidChild
            mountOpts = '--rbind --make-rslave'
            if overridePID > 0:
                pidSpace = overridePID
                mountOpts = '--rbind'

            appLogger.debug(
                'nsenter --preserve-credentials --user --mount --pid -t %s mount %s %s %s',
                                pidSpace, mountOpts, hostPath, sandboxPath)

            mountCMD = 'nsenter --preserve-credentials --user --mount --pid -t'
            mountCMD = mountCMD + f' {pidSpace} mount {mountOpts} {hostPath} {sandboxPath}'
            mountProc = subprocess.Popen(
                            mountCMD,
                            stdin = subprocess.PIPE,
                            stdout = subprocess.PIPE,
                            stderr = subprocess.PIPE,
                            shell=True)
            mountProc.wait()
            mountRC = mountProc.poll()
            appLogger.debug('MountHost RC: %s', mountProc.poll())
            del mountProc

            if mountRC == 32:
                appLogger.warning('Failed to Mount Host Path: %s as %s', hostPath, sandboxPath)
                appLogger.warning('Continuing...')
                continue

            if mountRC != 0:
                appLogger.error('Failed to Mount Host Path: %s as %s', hostPath, sandboxPath)
                raise IOError('Failed to Mount Host Path')

    def mountrootfs(self, rootfs : str) -> None:
        '''
        Mount the ROOTFS for the sandbox from a RO source
        '''

        rootfsPath = os.path.realpath(os.path.abspath(os.path.join(rootfs)))

        neededLayers = ['._appBoxLayers/overlay', '._appBoxLayers/upper', '._appBoxLayers/work']

        layerPaths = []
        for _layer in neededLayers:

            layerPath = os.path.abspath(os.path.join(self.sandboxPath, _layer))

            if not os.path.exists(layerPath):
                os.makedirs(layerPath)

            layerPaths.append(layerPath)

        rootfsMountCMD = 'fuse-overlayfs -o squash_to_root -o'
        rootfsMountCMD = rootfsMountCMD + f' lowerdir={rootfsPath},upperdir={layerPaths[1]}'
        rootfsMountCMD = rootfsMountCMD + f',workdir={layerPaths[2]} {layerPaths[0]}'

        appLogger.debug('Mounting rootfs via: %s', rootfsMountCMD)

        mountProc = subprocess.Popen(
        f'nsenter --preserve-credentials --user --mount --pid -t {self.pidChild} {rootfsMountCMD}',
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        mountProc.wait()
        mountRC = mountProc.poll()
        appLogger.debug('Mount RC: %s', mountProc.poll())
        del mountProc

        if mountRC != 0:
            appLogger.error('Failed to Mount RootFS: %s', rootfs)
            raise IOError('Failed to Mount RootFS')

    def cleanupSpaces(self) -> None:
        '''
        Cleanup the 'persistent' spaces which have been created
        '''
        # restore tty settings back
        try:
            #os.write(sys.stdin.fileno(), '\n\r'.encode())
            # Restore the stdin back to what it used to be
            #termios.tcsetattr(sys.stdin, termios.TCSANOW, self.oldTTY)
            if getattr(self, 'proc', None) and self.proc.pid:
                os.killpg(os.getpgid(self.proc.pid), signal.SIGKILL)
            sys.stdin.flush()
            sys.stdout.flush()
        except (IOError, OSError) as delErr:
            appLogger.debug('Deletion Error: %s', delErr)

    def setupSubSpace(self, asRoot : bool=False) -> tuple:
        '''
        Create a subSpace within the root space of the host
        '''
        appLogger.debug('Setting up SubSpace')

        chrootCMD = self._getSandboxCmd(None, asRoot)
        # pylint: disable=locally-disabled, subprocess-popen-preexec-fn
        self.proc2 = subprocess.Popen(chrootCMD,
                                     shell=True, preexec_fn=os.setsid,
                                     stdin = subprocess.PIPE,
                                     stdout = subprocess.PIPE,
                                     stderr = subprocess.PIPE,
                                     universal_newlines = True)

        appLogger.debug('PID of subSpace: %s', self.proc2.pid)

        self.pidSubParent=self.proc2.pid

        time.sleep(0.05)

        with open(f'/proc/{self.pidSubParent}/task/{self.pidSubParent}/children',
                  'r', encoding='utf-8') as _file:
            self.pidSubChild=int(_file.read())
            appLogger.debug('Child PID: %s', self.pidSubChild)

        return (self.pidSubParent, self.pidSubChild)

    def _getSandboxCmd(self, command : str='', asRoot : bool=False) -> str:
        '''
        Get the command to run inside the sandbox (i.e. the shell)
        '''

        # Calling env bash vs bash directly means that bash respects
        # an external SIGHUP call used to 'deactivate' our sandbox

        if not command:
            if self.rootfs:
                commandPath = os.path.join(self.rootfs, 'bin/bash')
            else:
                commandPath = os.path.join(self.sandboxPath, 'bin/bash')
            if os.path.exists(commandPath):
                command = 'env -i /bin/bash -l -i -c "true; env /bin/bash '
                command += ' --rcfile /etc/profile -l ; exit $?"'
            else:
                command = 'env -i /bin/sh'
        else:
            if not self.compatV1:
                commandPath = os.path.join(self.sandboxPath, 'bin/bash')
                if os.path.exists(commandPath):
                    command = f'env -i /bin/bash --rcfile /etc/profile -l -i -c "true; {command}" '
                else:
                    pass
            else:
                command = f'env -i /bin/bash --rcfile /etc/profile -l -i -c \'true; {command}\''
        #command = '/bin/bash -l'

        if not self.compatV1:
            # Continue as Normal and use good hosts unshare
            if asRoot:
                chrootCMD  = '/bin/bash --rcfile /etc/profile -c '
                chrootCMD += f'\'mount -t tmpfs tmpfs {self.getSandboxPath()}/run; '
                chrootCMD += 'unshare -priUmf --mount --mount-proc -R '
                chrootCMD += f'{self.getSandboxPath()} --propagation=unchanged '
                chrootCMD += f'{command};\' exit $?'
            else:
                chrootCMD  = f'unshare -piUmf --mount --mount-proc -R {self.getSandboxPath()} '
                chrootCMD += f'--propagation=unchanged {command}'
        else:
            # Use the older compatibility mode for the sandbox,
            # use chroot and drop the '-R' unshare arg...
            # TBF for HEP it was clear as day AL9 was going to be the way forward,
            # but some people are still on CO8/R8... _sigh_ ...

            # I absolutely could not find a way without unshare -R to drop down to
            # a non-priviledged anon user using chroot...
            # This could simply be me mis-understanding something about sandboxes
            # and their inheritance, or my mistake...
            # Given I don't really _want_ to support running on such an old
            # host I think we can just say for now:

            if not asRoot:
                appLogger.warning('Compatability with older Hosts doesn\'t work,')
                appLogger.warning('if dropping into a \'non-root\' sandbox.')
                appLogger.warning('Running as "root" in sandbox')

            chrootCMD = ' /bin/bash --rcfile /etc/profile -c '
            chrootCMD +='"export PATH=/bin:/sbin:/usr/sbin:/usr/bin:/usr/local/bin:/usr/local/sbin;'
            chrootCMD += '/bin/mount -t tmpfs tmpfs /run;'
            chrootCMD += f'/bin/mount -t proc proc /proc; sleep 1; chroot {self.getSandboxPath()} '
            chrootCMD += f'{command}"; exit $?'

        return chrootCMD

    def read_from_master(self, process : subprocess.Popen) -> None:
        '''
        Read from the master PTY file descriptor and print to stdout.
        '''
        try:
            while True:
                rlist, _, _ = select.select([self.ptyMfd], [], [], 0.1)
                if self.ptyMfd in rlist:
                    data = os.read(self.ptyMfd, 1024)
                    if data:
                        sys.stdout.write(data.decode(errors='replace'))
                        sys.stdout.flush()
                    else:
                        break
                if process.poll() is not None:
                    break
        except OSError:
            pass
        finally:
            if process.poll() is None:
                process.terminate()
            try:
                os.close(self.ptyMfd)
            except OSError:
                pass

    def write_to_master(self, process : subprocess.Popen) -> None:
        '''
        Write user input to the master PTY file descriptor.
        '''
        old_settings = termios.tcgetattr(sys.stdin)
        try:
            tty.setraw(sys.stdin)
            while True:
                rlist, _, _ = select.select([sys.stdin], [], [], 0.1)
                if sys.stdin in rlist:
                    user_input = os.read(sys.stdin.fileno(), 1024)
                    if not user_input:
                        break
                    os.write(self.ptyMfd, user_input)
                if process.poll() is not None:
                    break
        except OSError:
            pass
        finally:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
            try:
                os.close(self.ptyMfd)
            except OSError:
                pass

    def handle_sigwinch(self, signum : int, frame : any) -> None: # pylint: disable=locally-disabled, unused-argument
        '''
        Handle window resize signal and adjust the PTY window size.
        '''
        s = struct.pack('HHHH', 0, 0, 0, 0)
        rows, cols, xpixels, ypixels = struct.unpack('HHHH',
                                                fcntl.ioctl(sys.stdout, termios.TIOCGWINSZ, s))
        fcntl.ioctl(self.ptyMfd, termios.TIOCSWINSZ,
                    struct.pack('HHHH', rows, cols, xpixels, ypixels))

    def spawn_bash_terminal(self, command : str, asRoot : bool=False) -> int:
        '''
        Spawn a bash terminal in a new PTY.
        '''
        # Open a new pseudo-terminal pair
        self.ptyMfd, self.ptySfd = pty.openpty()

        # Set up signal handler for window resize
        signal.signal(signal.SIGWINCH, self.handle_sigwinch)
        try:
            self.handle_sigwinch(None, None)  # Set initial window size
        except OSError as err:
            appLogger.debug('Error: %s', err)

        chrootCMD = self._getSandboxCmd(command, asRoot)

        appLogger.debug('About to execute')
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s ; exit $?;',
                                self.pidChild, chrootCMD)

        procCMD = 'nsenter --preserve-credentials --user --mount --pid -t'
        procCMD = procCMD + f' {self.pidChild} {chrootCMD}; exit $?;'

        # Needed for Ubuntu and Debian related screwiness.
        # EL based distros HAVE NO ISSUE WITH BASH WORKING OUT THAT PID 1 MEANS
        # YOU WILL BE IN CHARGE OF SUBPROCESSES
        # Debian on the other hand is a special snowflake which causes issues
        # Someone is patching code somewhere OOB and it makes me unhappy :(
        procCMD = ['/bin/bash', '-c', procCMD]

        appLogger.debug('Running: %s', procCMD)
        # Start the subprocess with the slave side of the PTY as its stdin, stdout, and stderr
        # pylint: disable=locally-disabled, subprocess-popen-preexec-fn
        interactiveProc = subprocess.Popen(
            procCMD,
            preexec_fn = os.setsid,  # Start a new session
            stdin = self.ptySfd,
            stdout = self.ptySfd,
            stderr = self.ptySfd,
            close_fds=True, universal_newlines=True
        )

        # Close the slave_fd in the parent since it's now handled by the child
        os.close(self.ptySfd)

        # Interact with the master side of the PTY
        try:
            read_thread = threading.Thread(target=self.read_from_master, args=(interactiveProc,))
            read_thread.start()

            write_thread = threading.Thread(target=self.write_to_master, args=(interactiveProc,))
            write_thread.start()

            read_thread.join()
            write_thread.join()
        except OSError:
            pass
        finally:
            try:
                os.close(self.ptyMfd)
            except OSError:
                pass
            interactiveProc.wait()
            # Not 'perfect' to have all of the return from the users code here, but this works well
            return interactiveProc.returncode #pylint: disable=W0134,W0150

    def runCommand(self, command : str, asRoot : bool=False) -> int:
        '''
        Run Said command inside the sandbox env

        This approach has 2 limitations:
        1. No clean/nice way of intercepting PTY resize events
        2. Minor issues with Debian based systems which I don't want to get into
        '''

        chrootCMD = self._getSandboxCmd(command, asRoot)

        appLogger.debug('About to execute')
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s ; exit $?;',
                                self.pidChild, chrootCMD)

        self._wrangleTTY()
        procCMD = 'nsenter --preserve-credentials --user --mount --pid -t'
        procCMD = procCMD + f' {self.pidChild} {chrootCMD}; exit $?;'
        # pylint: disable=locally-disabled, subprocess-popen-preexec-fn
        interactiveProc = subprocess.Popen(
                procCMD,
                stdin = self.stdoutS,
                stdout = self.stdoutS,
                stderr = self.stdoutS,
                shell = True, universal_newlines = True, preexec_fn=os.setsid
                )

        i=0
        timeLimit=100

        while i<= timeLimit:
            time.sleep(0.05)  # Total 5s chance for child to spawn on a healthy system
            i=i+1             # Obviously 5s+work-time, but I'm assuming accessing proc is cheap

            parentID = interactiveProc.pid
            childID = parentID

            try:
                # If the process is unknown or in a zombie state
                if self.procState(interactiveProc.pid) in ['Z', 'E']:
                    break
            except PermissionError as permissionErr:
                appLogger.debug('Error: %s', permissionErr)

            while True:

                appLogger.debug('Parent PID: %s', parentID)
                appLogger.debug('Child PID: %s', childID)
                try:
                    parentID, childID = self.getChildID(childID)
                    #self.pidChild = childID
                except (OSError, ValueError) as pidErr:
                    appLogger.debug('Error: %s', pidErr)
                    break
                time.sleep(0.05)

                appLogger.debug('---')

            if parentID != childID and childID:
                if self.compatV1:
                    self.mountHost(childID)
                break

        if i>timeLimit:
            raise RuntimeError('Failed to spawn child process to launch shell or run command.')

        readable = [sys.stdin, self.stdoutM]
        while True:

            self.running = True
            shouldContinue = self._shellFwdBck(interactiveProc, readable)

            if not shouldContinue:
                break
        self.running=False

        rc = interactiveProc.poll()

        appLogger.debug('Return Code: %s', rc)

        return rc

    def procState(self, pid : int) -> str:
        '''
        Return the state of a given PID in linux
        '''
        # Only on Linux
        for _line in open(f"/proc/{pid}/status", encoding='utf-8').readlines():
            if _line.startswith("State:"):
                entry = _line.split(":")[1].strip()
                value = entry.rstrip()[0]
                return value
        # Unknown
        return 'E'

    def _shellFwdBck(self, interactiveProc : subprocess.PIPE, readable : list) -> bool:
        '''
        This is the component for handling sending data in/out of the pty
        '''

        try:
            # If the process is unknown or in a zombie state
            if self.procState(interactiveProc.pid) in ['Z', 'E']:
                return False
        except PermissionError as permissionErr:
            appLogger.debug('Error: %s', permissionErr)
            return False

	    # Poll for input/output
        if interactiveProc and interactiveProc.poll() is None:
            r, _w, _e = select.select(readable, [], [], 0.01)

            for _in in r:
                if _in is sys.stdin:
                    d = os.read(sys.stdin.fileno(), 10240)
                    #if d.decode() in ['\x04',]:
                    #    self._should_stop = True
                    #    return False
                    os.write(self.stdoutM, d)
                elif _in is self.stdoutM:
                    try:
                        o = os.read(self.stdoutM, 10240)
                    except OSError as e:
                        appLogger.debug('Error: %s', e)
                        return False
                    if o:
                        os.write(sys.stdout.fileno(), o)
                else:
                    raise RuntimeError('Help')
            return True
        else:
            return False


class sandboxFixes:
    '''
    Class to handle the fixes needed for the sandbox
    '''

    def __init__(self, addNV : bool, sandboxInstance : sessionManager, iManager : imageManager):
        '''
        '''

        self.addNVidia = addNV
        self.sandboxInstance = sandboxInstance
        self.iManager = iManager

        self.tmpPath = '/tmp'

    def applyAllFixes(self) -> None:
        '''
        Apply all of the fixes to this sandbox
        '''
        appLogger.debug('Applying Permission Fixes')
        self.fixFilePermissions()
        appLogger.debug('Applying Apt Fixes')
        self.fixAptSandboxing()
        appLogger.debug('Applying DNF Fixes')
        self.fixDnfSandboxing()
        appLogger.debug('Fixing Missing Paths')
        self.fixMissingPaths()
        appLogger.debug('Fixing Missing Stubs')
        self.fixMissingStubs()
        appLogger.debug('Fixing User Accounts')
        self.fixUserAccounts()
        appLogger.debug('Fixing Aliases')
        self.fixAliases()
        appLogger.debug('Fixing Environment')
        self.fixEnvironment()
        appLogger.debug('Installing AppBox')
        self.installAppBox()
        appLogger.debug('Copying from Host')
        self.copyFromHost()
        appLogger.debug('Fixing bad tools')
        self.fixForLies()
        appLogger.debug('Fixing missing Env')
        self.applyImageEnv()
        appLogger.debug('Cache Manifest within sandbox')
        self.cacheManifest()
        appLogger.debug('Installing sandbox data')
        self.stampSandbox()

    def copyFromHost(self) -> None:
        '''
        Copy certain configs from the host to the sandbox so things work
        '''

        fileList = ['/etc/resolv.conf', '/etc/hostname', '/etc/hosts',
                    '/etc/localtime', '/etc/timezone', '/etc/vimrc']

        for _file in fileList:
            if not os.path.exists(_file):
                appLogger.debug('Skipping: %s', _file)
                continue
            self.sandboxInstance.removeFromSandBox(
                os.path.abspath(os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_file)))
            self.sandboxInstance.copyFileFromHost(_file,
                    os.path.abspath(os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_file)))

    def fixFilePermissions(self) -> None:
        '''
        Fix the permissions of a given path
        '''

        #stampFile = os.path.join(self.sandboxInstance.getSandboxPath(), '.appBox')
        #if os.path.exists(stampFile):
        #    return

        if self.sandboxInstance.rootfs:
            return
        for root, dirs, files in os.walk(self.sandboxInstance.getSandboxPath(), topdown=True):
            for _dir in dirs:
                thisPath = os.path.join(root,_dir)
                if not os.path.islink(thisPath):
                    current = stat.S_IMODE(os.lstat(thisPath).st_mode)
                    os.chmod(thisPath, current | stat.S_IWUSR | stat.S_IRUSR | stat.S_ISGID)
            for _file in files:
                thisPath = os.path.join(root,_file)
                if not os.path.islink(thisPath):
                    current = stat.S_IMODE(os.lstat(thisPath).st_mode)
                    os.chmod(os.path.join(root,_file), current | stat.S_IWUSR | stat.S_IRUSR)

    def _getPathList(self) -> list:
        '''
        Return the list of paths we want to mount into the sandbox
        '''
        # This is a good fraction of the lsb because not all images follow the lsb...
        # which means...
        # well...
        # yeah...
        basePathList = ['/afs', '/dev', '/etc', '/cvmfs', '/scratch', '/Data', '/localdisk',
                          '/sys', '/tmp', '/home', '/proc', '/mnt']

        if self.addNVidia:
            basePathList.append('/usr/lib/wsl')

        return basePathList

    def fixMissingPaths(self) -> None:
        '''
        Fix potentially missing paths in the sandbox
        '''
        neededSandboxPaths = self._getPathList()

        absPaths = []
        for _path in neededSandboxPaths:
            absPaths.append(os.path.abspath(
                        os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_path)))

        for _path in absPaths:
            self.sandboxInstance.createSandboxPath(_path)

    def _getStubList(self) -> list:
        '''
        Make stubs for files to be mounted in from the host
        '''
        baseStubs = ['/etc/resolv.conf', '/etc/hostname', ]

        if self.addNVidia:
            baseStubs.append('/usr/bin/nvidia-smi')
            baseStubs.append('/usr/bin/nvidia-modprobe')

        return baseStubs

    def fixMissingStubs(self) -> None:
        '''
        Create the stubs needed for the sandbox
        '''
        neededStubs = self._getStubList()

        absPaths = []
        for _path in neededStubs:
            absPaths.append(os.path.abspath(
                        os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_path)))

        for _path in absPaths:
            try:
                if os.path.exists(_path) or os.path.islink(_path):
                    self.sandboxInstance.removeFromSandBox(_path)
                self.sandboxInstance.createSandboxEmptyFile(_path)
            except IOError as err:
                appLogger.debug('Error making stub: %s', err)

    def getAnonUIDGID(self) -> tuple:
        '''
        Return the Anon UID and GID for the sandbox
        In principle this can change based on the system, but for now it's fixed
        '''
        # TODO work out if we need to detect/change this
        return (65534, 65534)

    def fixUserAccounts(self) -> None:
        '''
        Fix the user accounts within the sandbox
        '''
        tmpPasswdFile = os.path.join(self.tmpPath, f'passwd_{str(uuid.uuid4())[:8]}')
        try:
            self._fixPasswd(tmpPasswdFile)
        finally:
            os.unlink(tmpPasswdFile)
        tmpGroupFile = os.path.join(self.tmpPath, f'group_{str(uuid.uuid4())[:8]}')
        try:
            self._fixGroup(tmpGroupFile)
        finally:
            os.unlink(tmpGroupFile)
        try:
            tmpShadowFile = os.path.join(self.tmpPath, f'gshadow_{str(uuid.uuid4())[:8]}')
            self._fixGShadow(tmpShadowFile)
        except IOError as err:
            appLogger.debug('Error: %s', err)
        finally:
            try:
                os.unlink(tmpShadowFile)
            except FileNotFoundError as err:
                appLogger.debug('Error: %s', err)

    def _fixPasswd(self, tmpPasswdFile : str) -> None:
        '''
        Fix the passwd config so the user mappings make sense
        '''
        self.sandboxInstance.copyFileToHost('/etc/passwd', tmpPasswdFile)

        with open(tmpPasswdFile, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('File: "%s"', tmpPasswdFile)
            appLogger.debug('Content: "%s"', _content)

        newContent = 'root:x:0:0:root:/root:/bin/bash\n'
        newContent += f'{getUN()}:x:65534:65534:{getUN()}:{getHome()}:/bin/bash\n'

        aUID, aGID = self.getAnonUIDGID()

        for _line in _content.split('\n'):
            if _line:
                _user, _, _uid, _gid, _name, _home, _shell = _line.split(':')
                if _user in ['root', getUN(), 'fax', 'input', 'kvm', 'render']:
                    continue
                if _user.startswith('systemd'):
                    # A dirty trick to keep apt 'content' on Ubuntu systems
                    continue
                appLogger.debug(
                    'User: "%s", UID: "%s", GID: "%s", Name: "%s", Home: "%s", Shell: "%s"',
                                    _user, _uid, _gid, _name, _home, _shell)

                newContent += f'{_user}:x:{aUID}:{aGID}:{_name}:{_home}:{_shell}\n'

        with open(tmpPasswdFile, 'w+', encoding='utf-8') as _file:
            _file.write(newContent)

        self.sandboxInstance.copyFileFromHost(tmpPasswdFile,
                            os.path.join(self.sandboxInstance.getSandboxPath(), './etc/passwd'))

    def _fixGroup(self, tmpGroupFile : str) -> None:
        '''
        Fix the group permissions so that mappings make sense
        '''
        self.sandboxInstance.copyFileToHost('/etc/group', tmpGroupFile)

        with open(tmpGroupFile, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('File: "%s"', tmpGroupFile)
            appLogger.debug('Content: "%s"', _content)

        _, aGID = self.getAnonUIDGID()

        newContent = 'root:x:0:\n'
        newContent += f'{getUN()}:x:{aGID}:\n'

        for _line in _content.split('\n'):
            if _line:
                _group, _, _gid, _users = _line.split(':')
                if _group in ['root', getUN(), 'fax', 'input', 'kvm', 'render']:
                    continue
                if _group.startswith('systemd'):
                    # A dirty trick to keep apt 'content' on Ubuntu systems
                    continue
                appLogger.debug('Group: "%s", GID: "%s", Users: "%s"', _group, _gid, _users)

                newContent += f'{_group}:x:{aGID}:{_users}\n'

        with open(tmpGroupFile, 'w+', encoding='utf-8') as _file:
            _file.write(newContent)

        self.sandboxInstance.copyFileFromHost(tmpGroupFile,
                                os.path.join(self.sandboxInstance.getSandboxPath(), './etc/group'))

    def _fixGShadow(self, tmpShadowFile : str) -> None:
        '''
        This fixes the gshadow config, mainly for debian systems
        '''
        if not os.path.exists(os.path.join(
                self.sandboxInstance.getSandboxPath(), './etc/gshadow')):
            return
        self.sandboxInstance.copyFileToHost('/etc/gshadow', tmpShadowFile)
        with open(tmpShadowFile, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('File: "%s"', tmpShadowFile)
            appLogger.debug('Content: "%s"', _content)

        newContent = ''

        for _line in _content.split('\n'):
            if _line:
                _pass = True
                for check in ['fax', 'voice', 'sudo', 'dip', 'operator', 'src',
                              'shadow', 'sasl', 'plugdev', 'staff', 'nogroup']:
                    if _line.startswith(check):
                        _pass = False
                        break
                if not _pass:
                    continue
                newContent += _line + '\n'

        with open(tmpShadowFile, 'w+', encoding='utf-8') as _file:
            _file.write(newContent)

        self.sandboxInstance.copyFileFromHost(tmpShadowFile,
                            os.path.join(self.sandboxInstance.getSandboxPath(), './etc/gshadow'))

    def fixAliases(self) -> None:
        '''
        Fix the aliases in the sandbox
        '''

        self.sandboxInstance.createSandboxPath(
                    os.path.join(self.sandboxInstance.getSandboxPath(), './etc/profile.d'))

        def fixDeactivate() -> None:
            '''
            Fix the deactivate script
            '''
            tmpDeacScript = os.path.join(self.tmpPath, f'deactivate_{str(uuid.uuid4())[:8]}')
            with open(tmpDeacScript, 'w+', encoding='utf-8') as _file:
                _file.write(
                    '#!/bin/bash\nfor i in $(seq 100); do kill -s 1 ${i} 2>&1 | true ; done\n')
            try:
                st = os.stat(tmpDeacScript)
                os.chmod(tmpDeacScript, st.st_mode | stat.S_IEXEC)
                self.sandboxInstance.copyFileFromHost(tmpDeacScript,
                        os.path.join(self.sandboxInstance.getSandboxPath(), './bin/deactivate'))
            finally:
                os.unlink(tmpDeacScript)

        fixDeactivate()

    def cacheManifest(self) -> None:
        '''
        Caching the manifest at the time that this sandbox was created
        '''
        cachePath = os.path.join(self.sandboxInstance.getSandboxPath(), '.cache')
        os.makedirs(cachePath, exist_ok=True)
        appLogger.debug('Caching Manifest at: %s', cachePath)
        self.iManager.cacheManifest(cachePath)
        appLogger.debug('Caching Config at: %s', cachePath)
        self.iManager.cacheConfig(cachePath)

    def fixEnvironment(self) -> None:
        '''
        Fix missing env vars at 'login' which includes wsl linkage
        '''

        if self.addNVidia:
            self.sandboxInstance.createSandboxPath(
                os.path.join(self.sandboxInstance.getSandboxPath(), './etc/ld.so.conf.d'))
            tmpLDPath = os.path.join(self.tmpPath, f'ld.wsl.conf_{str(uuid.uuid4())[:8]}')
            with open(tmpLDPath, 'w+', encoding='utf-8') as _file:
                _file.write('/usr/lib/wsl/lib')
            try:
                self.sandboxInstance.copyFileFromHost(tmpLDPath,
                    os.path.join(self.sandboxInstance.getSandboxPath(),
                                 './etc/ld.so.conf.d/wsl.conf'))
            finally:
                os.unlink(tmpLDPath)

        def setEnvVar(tmpENVFile : str) -> None:
            '''
            Build the env vars which we want to expose users to
            '''

            envs  = 'export PATH="${PATH}:/sbin:/usr/sbin:/usr/games"\n'
            envs += 'export DEBIAN_FRONTEND="noninteractive"\n'
            host_lang = os.environ.get('LANG', 'en_GB.UTF-8')
            envs += f'export LANG="{host_lang}"\n'
            host_lang2 = os.environ.get('LANGUAGE', 'en_GB:en')
            envs += f'export LANGUAGE="{host_lang2}"\n'
            host_term = os.environ.get('TERM', 'xterm-256color')
            envs += 'export LC_ALL="C"\n'
            envs += f'export TERM="{host_term}"\n'
            host_home = getHome()
            envs += 'export HOME=$( [ $(id -u) -eq 0 ] && echo "/root" ||'
            envs += f'echo "{host_home}" )\n'
            envs += f'export HOSTNAME={socket.gethostname()}\n'
            host_display = os.environ.get('DISPLAY', ':0')
            envs += f'export DISPLAY="{host_display}"\n'
            host_wayland = os.environ.get('WAYLAND_DISPLAY', 'wayland-0')
            envs += f'export WAYLAND_DISPLAY="{host_wayland}"\n'
            host_user = os.environ.get('USER', getUN())
            envs += f'export USER="{host_user}"\n'
            envs += 'if [ $(id -u) -eq 0 ]; then USR_MSG="\033[1;31mAS ROOT\033[0m";'
            envs += 'else USR_MSG="\033[32mas $(whoami)\033[0m"; fi\n'
            envs += 'alias nvidia-smi="ldconfig; nvidia-smi"\n'
            envs += 'alias nvidia-modprobe="ldconfig; nvidia-modprobe"\n'
            envs += 'if [ "${APPBOX}" == "1" ]; then return; fi\n'
            envs += 'echo "\n Now Running \033[31m[\033[33ma\033[32mp'
            envs += '\033[36mp\033[32mB\033[36mo\033[34mx\033[m\033[35m]\033[0m ! '
            envs += f'(sandbox based on image: \033[1;31m{self.iManager.userPath}\033[0m) '
            envs += ' ${USR_MSG}\n"\n'
            envs += 'export APPBOX=1\n'
            with open(tmpENVFile, 'w+', encoding='utf-8') as _file:
                _file.write(envs)
            self.sandboxInstance.copyFileFromHost(tmpENVFile,
                    os.path.join(self.sandboxInstance.getSandboxPath(),
                                 './etc/profile.d/zz_appBoxEnv.sh'))

        tmpENVFile = os.path.join(self.tmpPath, f'env.sh_{str(uuid.uuid4())[:8]}')
        try:
            setEnvVar(tmpENVFile)
        finally:
            os.unlink(tmpENVFile)

    def fixAptSandboxing(self) -> None:
        '''
        Fix issues related to installing packages on Debian in a single-user-sandbox...
        '''

        appConfPath = os.path.join(self.sandboxInstance.getSandboxPath(), './etc/apt/apt.conf.d/')
        self.sandboxInstance.createSandboxPath(appConfPath)

        layerPath = os.path.join(self.sandboxInstance.sandboxPath, './etc/apt/apt.conf.d/')
        if os.path.exists(layerPath):
            # Only want to apply this 'fix' in sandboxes where apt is installed

            fixApt  = 'APT::Sandbox::User "root";\nAPT::Sandbox::Verify "0";\n'
            fixApt += 'APT::Sandbox::Verify::IDs "0";\nAPT::Sandbox::Verify::Groups "0";\n'
            fixApt += 'APT::Sandbox::Verify::Regain "0";'

            tmpSandbox = os.path.join(self.tmpPath, f'sandbox-disable_{str(uuid.uuid4())[:8]}')
            with open(tmpSandbox, 'w+', encoding='utf-8') as _file:
                _file.write(fixApt)

            try:
                self.sandboxInstance.copyFileFromHost(tmpSandbox, os.path.join(appConfPath,
                                                                               '99appBox'))
            finally:
                os.unlink(tmpSandbox)

            ## Hack of a hack...
            ## cp /bin/true /usr/bin/dpkg-statoverride

            shutil.copyfile(os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/true'),
                os.path.join(self.sandboxInstance.getSandboxPath(), 'usr/bin/dpkg-statoverride'))

            shutil.copyfile(os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/true'),
                    os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/dpkg-statoverride'))

    def fixDnfSandboxing(self) -> None:
        '''
        Fix issues with Fedora sandboxing since we're now in a competition to do this...
        '''

        appConfPath = os.path.join(self.sandboxInstance.getSandboxPath(), './etc/dnf/')
        self.sandboxInstance.createSandboxPath(appConfPath)

        layerPath = os.path.join(self.sandboxInstance.sandboxPath, './etc/dnf/')
        if os.path.exists(layerPath):
            # Only want to apply this 'fix' in sandboxes where apt is installed

            fixDNF  = '[main]\n'
            fixDNF += 'gpgcheck=True\n'
            fixDNF += 'installonly_limit=3\n'
            fixDNF += 'clean_requirements_on_remove=True\n'
            fixDNF += 'best=False\n'
            fixDNF += 'skip_if_unavailable=True\n'
            fixDNF += 'tsflags=nodocs\n'
            fixDNF += 'excludepkgs=rpm-plugin-ima,ima-evm-utils\n' # <- the main fix(!)

            tmpSandbox = os.path.join(self.tmpPath, f'dnf.conf_{str(uuid.uuid4())[:8]}')
            with open(tmpSandbox, 'w+', encoding='utf-8') as _file:
                _file.write(fixDNF)

            try:
                self.sandboxInstance.copyFileFromHost(tmpSandbox, os.path.join(appConfPath,
                                                                               'dnf.conf'))
            finally:
                os.unlink(tmpSandbox)

    def installAppBox(self) -> None:
        '''
        Install the appBox tool into the sandbox
        '''

        currentInstance = os.path.abspath(__file__)
        if not os.path.exists(os.path.join(self.sandboxInstance.sandboxPath, './bin')):
            os.makedirs(os.path.join(self.sandboxInstance.sandboxPath, './bin'))
        installInstance = os.path.join(self.sandboxInstance.sandboxPath, './bin/appBox')

        self.sandboxInstance.copyFileFromHost(currentInstance, installInstance, overwrite=True)

        cvmfsArgs = ''
        if self.sandboxInstance.rootfs:
            cvmfsArgs = f'-cvmfs {os.path.abspath(self.sandboxInstance.rootfs)}'

        for _ in ['user', 'root', 'debug', 'rdebug']:
            if _ == 'root':
                asString = '-rcr "${cmd}"'
                scriptName = 'bin/activate-asroot'
            elif _ == 'user':
                asString = '-rc "${cmd}"'
                scriptName = 'bin/activate'
            elif _ == 'rdebug':
                asString = '-rcr "${cmd}"'
                scriptName = 'bin/activate-asroot-debug'
            else:
                asString = '-d -rc "${cmd}"'
                scriptName = 'bin/activate-debug'

            activateScript = """#!/bin/bash

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

if [ "$#" -eq 0 ]; then
  cmd="env /bin/bash --rcfile /etc/profile -l"
else
  cmd="$*"
fi

/bin/env python3 ${SCRIPT_DIR}/appBox """
            activateScript  = activateScript + cvmfsArgs
            activateScript += " -l ${SCRIPT_DIR}/.."
            activateScript += " -layerCache ${SCRIPT_DIR}/../.cache/ " + asString

            activatePath = os.path.join(self.sandboxInstance.sandboxPath, f'./{scriptName}')
            with open(activatePath, 'w+', encoding='utf-8') as _file:
                _file.write(activateScript)

            for _file in [installInstance, activatePath, ]:
                st = os.stat(_file)
                os.chmod(_file, st.st_mode | stat.S_IEXEC)

    def fixForLies(self) -> None:
        '''
        Override some commands to stop people doing bad things by accident,
        or on-purpose to themselves
        '''

        ## T O D O decide if this is a bad idea or not...
        ## Intention here is to 'stop' automated tooling from trying to do something
        ## bad within the sandbox. This has the side-effect of stopping people changing
        ## a file so that they can't so anything with it without magic cmdline-fu (d'oh!)
        ## Also provides some safety over apt/rpm scripts calling these when people
        ## install packages themselves...
        ## Remember: "You're a user Harry..."

        for _file in ['/usr/bin/chown', '/bin/chown',
                      '/usr/bin/su', '/bin/su', '/usr/bin/sudo', '/bin/sudo']:
            try:
                if os.path.islink(os.path.join(
                                self.sandboxInstance.getSandboxPath(), '.'+_file)):
                    self.sandboxInstance.removeFromSandBox(os.path.join(
                                self.sandboxInstance.getSandboxPath(), '.'+_file))
                self.sandboxInstance.copyFileFromHost(
                            os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/true'),
                            os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_file))
            except IOError as err:
                appLogger.debug('Error: %s', err)

    def applyImageEnv(self) -> None:
        '''
        Construct the image env as defined in the manifest config
        '''

        self._implicitImageEnv()
        self._explicitImageEnv()

    def _implicitImageEnv(self) -> None:
        '''
        Sometimes image makers are lazy and don't set the environment variables
        Do it for them...
        '''

        thisConfig = self.iManager.getConfig()

        implicit_env = ""

        for _step in thisConfig['history']:
            if _step.get('created_by',False):
                if _step['created_by'].startswith('ARG'):
                    _env = _step['created_by'][4:]
                    appLogger.debug('Setting Environment %s', _env)
                    implicit_env += f"export \"{_env}\"\n"

        tmpENVFile = os.path.join(self.tmpPath, f'env.sh_{str(uuid.uuid4())[:8]}')
        with open(tmpENVFile, 'w+', encoding='utf-8') as _file:
            _file.write(implicit_env)
        try:
            self.sandboxInstance.copyFileFromHost(tmpENVFile,
                    os.path.join(self.sandboxInstance.getSandboxPath(),
                                 './etc/profile.d/imageEnv01.sh'))
        finally:
            os.unlink(tmpENVFile)

    def _explicitImageEnv(self) -> None:
        '''
        Apply the environment variables from the image to the sandbox
        '''

        thisConfig = self.iManager.getConfig()

        thisEnv = thisConfig['config'].get('Env', 'NOT_DEFINED')
        if thisEnv == 'NOT_DEFINED':
            return

        all_envs = ""
        for _env in thisConfig['config']['Env']:

            appLogger.debug('Setting Environment %s', _env)
            all_envs += f"export \"{_env}\"\n"

        all_envs += 'alias deactivate=/bin/deactivate\n'

        tmpENVFile = os.path.join(self.tmpPath, f'env.sh_{str(uuid.uuid4())[:8]}')
        with open(tmpENVFile, 'w+', encoding='utf-8') as _file:
            _file.write(all_envs)
        try:
            self.sandboxInstance.copyFileFromHost(tmpENVFile,
                    os.path.join(self.sandboxInstance.getSandboxPath(),
                                 './etc/profile.d/imageEnv02.sh'))
        finally:
            os.unlink(tmpENVFile)

    def stampSandbox(self) -> None:
        '''
        Stamp the sandbox with the details of the image
        '''

        stampFile = os.path.join(self.sandboxInstance.getSandboxPath(), '.appBox')
        if os.path.exists(stampFile):
            return

        appBoxData = {}
        appBoxData['version'] = appBoxVersion
        appBoxData['image'] = self.iManager.userPath
        appBoxData['createTime'] = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        appBoxData['originalSandboxPath'] = self.sandboxInstance.getSandboxPath()
        appBoxData['originalUser'] = getUN()
        appBoxData['originalUIDGID'] = f"{os.getuid()}:{os.getgid()}"

        with open(stampFile, 'w', encoding='utf-8') as _file:
            _file.write(json.dumps(appBoxData, indent=4))


class appBoxManager:
    '''
    Class for general helper functions
    '''

    def setLogLevel(self, level : int) -> None:
        '''
        Set the log level of the global logger
        '''

        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        if level == logging.DEBUG:
            console_formatter = logging.Formatter(
            "\033[1;32m%(asctime)s.%(msecs)03d';%(levelname)s: %(message)s\033[0m", "%Y-%m-%d %H:%M:%S")
        else:
            console_formatter = logging.Formatter('%(message)s')
        console_handler.setFormatter(console_formatter)
        appLogger.setLevel(level)
        appLogger.addHandler(console_handler)
        for handler in appLogger.handlers:
            handler.setLevel(level)

        # Set up logging with the custom handler
        handler = OneLineProgressHandler(sys.stdout)
        formatter = logging.Formatter('\033[1;32m%(message)s')  # Simple message output
        handler.setFormatter(formatter)
        barLogger.setLevel(level)
        barLogger.addHandler(handler)  # Replace default handlers with our custom handler
        for handler in barLogger.handlers:
            handler.setLevel(level)


class cmdLineParser:
    '''
    Class for parsing command line arguments
    '''

    @staticmethod
    def getArgsParser() -> argparse.ArgumentParser:
        '''
        Parse the Args passed to this instance
        '''

        #class BlankLinesHelpFormatter(argparse.HelpFormatter):
        class blankLinesHelpFormatter(argparse.RawDescriptionHelpFormatter):
            '''
            Class to keep extra lines in help text
            '''
            def _split_lines(self, text, width):
                '''
                Keep the extra lines
                '''
                return super()._split_lines(text, width) + ['']

        un = getUN()
        epilog = f"""
------------------------------------------------------------------------------------------

Example Usage for this might be:
--------------------------------

# Usage 1 (Download, extract, setup then manuall source) #
##########################################################

RH> ./appBox -ii ubuntu:20.04 -ip /scratch/appBox_{un}/Ubuntu20
RH> source /scratch/appBox_{un}/Ubuntu20/bin/activate
...
Ubuntu>

# Usage 2 (Download, extract, setup and drop me into a root shell) #
####################################################################

RH7> ./appBox -ii docker://almalinux:9 -ip /scratch/appBox_{un}/AL9 -rar
...
RH9# dnf update -y
...

# Usage 3 (Download, ..., then run a command and exit) #
########################################################

RH7> ./appBox -ii ubuntu:22.04 -ip /scratch/appBox_{un}/Ubuntu22 -q -rcr 'echo /etc/os-release'
PRETTY_NAME="Ubuntu 22.04.4 LTS"
NAME="Ubuntu"
VERSION_ID="22.04"
VERSION="22.04.4 LTS (Jammy Jellyfish)"
VERSION_CODENAME=jammy
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=jammy
RH7> 

------------------------------------------------------------------------------------------

"""


        parser = argparse.ArgumentParser(
                        prog='appBox', formatter_class=blankLinesHelpFormatter,
        description='This is a tool to install a custom container as a sandbox like "virtualenv".',
                        epilog=epilog)

        parser.add_argument('-rc', '--run-command',
                            help='Run a given command inside a sandbox.')

        parser.add_argument('-rp', '--run-path',
        help='Path to look for an installed image (extracted sandbox) to use as a run-environment.')

        parser.add_argument('-rcr', '--run-command-root',
                            help='Run a given command AS ROOT inside a sandbox.')

        if os.path.exists('/scratch'):
            leadingPath = '/scratch'
        else:
            leadingPath = '/tmp'

        defaultRoot = f'{leadingPath}/appBox_{getUN()}/sandbox'

        #default_image = 'almalinux:9'
        defaultImage = 'centos:7'

        parser.add_argument('-ii', '--install-image',
                            default=defaultImage,
                help=f'Image to install, or short-hand of image from "{sys.argv[0]} -li"')

        parser.add_argument('-ip', '--install-path',
                            default=defaultRoot,
        help='Install path, path to "install" an image to on disk. (Path to extract to on disk)')

        parser.add_argument('-ra', '--run-after', action='store_true',
                            help='Should we drop into the new sandbox after installing.')

        parser.add_argument('-rar', '--run-after-root', action='store_true',
                            help='Should we drop into the new sandbox AS ROOT after installing.')


        parser.add_argument('-q', '--quiet', action='store_true',
                            help='Quiet')

        parser.add_argument('-d', '--debug', action='store_true',
                            help='Debugging on.')

        parser.add_argument('-l', '--launch',
                            help='Launch Interactive environment from ...')

        parser.add_argument('-lr', '--launch-root',
                            help='Launch Interactive environment AS ROOT, from ...')

        parser.add_argument('-compat', '--compatV1', action='store_true',
            help='Use the older compatibility mode for the sandbox. Allows a CO8 host.')

        parser.add_argument('-rmNV', '--remove-nvidia', action='store_true',
                            help='Remove the nvidia-smi binary to the sandbox.')

        parser.add_argument('-tmp', action='store_true',
                            help='The environment will be destroyed on exit. (Temporary Sandbox)')

        parser.add_argument('-online', action='store_true',
                            help='Always try to get the latest online version of an image.')

        parser.add_argument('-layerCache',
                            help='Path to a directory to store the image layers for future use.')

        # Disabling the cvmfs tooling for now as it's not production ready/tested yet.
        #parser.add_argument('-cvmfs', '--use-cvmfs',
        #                    help='Use uncompressed image from this CVMFS path.')

        return parser


def runCommand(iManager : imageManager, sandboxPath : str, command : str, asRoot : bool,
               compatV1 : bool=False, addNV : bool=False, rootfs : str='',
               runCMD : bool=True) -> int:
    '''
    Run a command within a sandbox
    '''

    appLogger.debug('RunCommand: %s, %s, %s, %s', compatV1, addNV, rootfs, runCMD)

    try:
        thisSandbox = sessionManager(sandboxPath, compatV1, addNV, rootfs)
        thisSandbox.setupHostSpace()

        if rootfs:
            thisSandbox.mountrootfs(rootfs)
            #time.sleep(1.0)

        thisSandbox.mountHost()

        theseFixes = sandboxFixes(addNV, thisSandbox, iManager)
        theseFixes.applyAllFixes()

        if runCMD:
            appLogger.debug('Running Command: %s', command)
            rc = thisSandbox.spawn_bash_terminal(command, asRoot)
        else:
            appLogger.debug('Just Returning, Huzzah!')
            rc = 0

        return rc

    except BaseException as globalErr: # pylint: disable=broad-except
        appLogger.error('Exception during running appBox Shell: %s', globalErr)
        thisSandbox.cleanupSpaces()
        if appLogger.level == logging.DEBUG:
            raise
        sys.exit(131)
    finally:
        thisSandbox.cleanupSpaces()


def main() -> None:
    '''
    Main :) Hello
    '''

    ### Parse our args and steer
    parser = cmdLineParser.getArgsParser()
    parsedArgs = parser.parse_args(sys.argv[1:])

    if parsedArgs.quiet:
        appBoxManager().setLogLevel(logging.ERROR)
    elif parsedArgs.debug:
        appBoxManager().setLogLevel(logging.DEBUG)
    else:
        appBoxManager().setLogLevel(logging.INFO)

    commandToRun = None
    asRoot = False
    compatV1 = False
    wantedDest = None
    shouldRun = False
    needToInstall = False
    addNV = not parsedArgs.remove_nvidia
    appLogger.debug('Add NV: %s', addNV)

    forceUpdate = parsedArgs.online
    layerCache = parsedArgs.layerCache
    if layerCache:
        layerCache = os.path.abspath(layerCache)
    else:
        layerCache = None

    lowerLayer = None

    if parsedArgs.compatV1:
        compatV1 = True

    wantedImage = parsedArgs.install_image
    if parsedArgs.install_path:
        wantedDest = os.path.abspath(parsedArgs.install_path)
        needToInstall = True

    if parsedArgs.run_command:
        commandToRun = parsedArgs.run_command
        shouldRun = True
    if parsedArgs.run_command_root:
        commandToRun = parsedArgs.run_command_root
        asRoot = True
        shouldRun = True

    if parsedArgs.launch:
        wantedDest = parsedArgs.launch
        shouldRun = True
        wantedImage = None
    if parsedArgs.launch_root:
        wantedDest = parsedArgs.launch_root
        asRoot = True
        shouldRun = True
        wantedImage = None

    if parsedArgs.run_after:
        shouldRun = True
    if parsedArgs.run_after_root:
        asRoot = True
        shouldRun = True

    # TODO fix cvmfs fusermount alternative approach
    #if parsedArgs.use_cvmfs:
    #    lowerLayer = parsedArgs.use_cvmfs
    #    shouldRun = True
    #    #cvmfs_sandbox(parsedArgs.use_cvmfs, wantedDest, None, True)
    #    #sys.exit(-200)


    if not (shouldRun or commandToRun):
        # Lets change the output colour ;) (Green)
        msg  = '\033[31m[\033[1;33mA\033[1;32mp\033[1;36mp'
        msg += f'\033[1;32mB\033[1;36mo\033[1;34mx\033[1;35m]{bgColour}: '
        msg += f'\033[1;30m{__version__}{bgColour}'
        appLogger.info(msg)

    appLogger.debug('')
    appLogger.debug('Debugging Enabled. Jolan tru.')
    appLogger.debug('')

    def platformDetection():
        platStr = platform.platform()
        detected = False
        for _str in ['centos-7', '3.10.', '4.18.0', ]:
            if _str in platStr:
                detected = True
                break
        return detected

    if platformDetection() and not compatV1:
        appLogger.warning('Detected older platform than EL9/UB22 defaulting to compatability mode.')
        appLogger.warning('You won\'t be able to use anonymous user-mapping for this session.')
        appLogger.warning('To disable this warning, use the -compat cmd arg.')
        compatV1 = True


    wantedDest = os.path.abspath(wantedDest)

    appLogger.debug('Looking in path: "%s"', wantedDest)

    if parsedArgs.run_path:
        wantedDest = parsedArgs.run_path
        shouldRun = True

    if not os.path.exists(wantedDest):
        msg = f'Sandbox: \033[1;34m"{wantedDest}"{bgColour} does not exist.'
        appLogger.info(msg)
        if not lowerLayer:
            if wantedImage is None:
                appLogger.error('Please install before trying to launch a sandbox.')
                sys.exit(132)
            msg  = f'{bgColour}Installing: \033[1;33m"{wantedImage}"{bgColour}'
            msg += f' at \033[1;34m"{wantedDest}"{bgColour}'
            appLogger.info(msg)
            needToInstall = True
        else:
            appLogger.info('Using CVMFS: "%s"', lowerLayer)
            needToInstall = False

    rc = 0
    if needToInstall and not lowerLayer and wantedImage:

        ## TODO
        ## Add some way of handling images from other sources
        ## This should identify docker images from docker://
        ## This will probably involve adding additional classes for Quay, Singularity, etc.
        ## Can safely default to assume **most** users want a docker image from dockerhub/gitlab


        imageLower = wantedImage.lower()
        if wantedImage != imageLower:
            appLogger.debug('Changing search string to be lower-case! %s', imageLower)
            wantedImage = imageLower

        # Construct Manager
        iManager = imageManager(wantedImage, wantedDest, layerCache, forceUpdate)

        appLogger.debug('Looking for image: "%s"', wantedImage)

        # Extract the image to the destination path
        try:
            if os.path.exists(wantedDest):
                appLogger.info('Path: "%s" already exists. Assuming it\'s a sandbox.', wantedDest)
                rc = 0
            else:
                rc = iManager.extractImage()
            if rc != 0:
                appLogger.error('Failed to extract image: "%s"', wantedImage)
                return rc
            runCMD=False
            rc = runCommand(iManager, wantedDest, commandToRun, asRoot, compatV1,
                            addNV, lowerLayer, runCMD)
            if rc != 0:
                appLogger.debug('Command failed with RC: %s', rc)
            if not commandToRun and not shouldRun:
                msg  = f'Image: \033[1;33m"{wantedImage}"{bgColour}'
                msg += f' installed at: \033[1;34m"{wantedDest}"{bgColour}\n\n'
                msg += 'To launch this sandbox, use:\n'
                msg += f'\t\t\t\t\033[1;31msource {wantedDest}/bin/activate{bgColour}'
                appLogger.info(msg)

        except PermissionError as permissionErr:
            appLogger.error('Permission Denied.')
            appLogger.error('Normally this means we don\'t have write access to: "%s"', wantedDest)
            appLogger.debug('Permission Error: %s', permissionErr)
            if appLogger.level == logging.DEBUG:
                raise permissionErr
            sys.exit(133)

    if shouldRun:

        try:
            with open(os.path.join(wantedDest, '.appBox'), 'r', encoding='utf-8') as _file:
                _content = _file.read()
        except FileNotFoundError as fileErr:
            _ = fileErr
            appLogger.error('Path: "%s" is not a valid appBox sandbox.', wantedDest)
            sys.exit(142)

        imageData = json.loads(_content)
        appLogger.debug('Sandbox Data: %s', imageData)

        if not layerCache:
            layerCache = os.path.join(wantedDest, '.cache')

        iManager = imageManager(imageData['image'], wantedDest, layerCache, forceUpdate)

        # We now plan to run a command or launch a shell
        rc = runCommand(iManager, wantedDest, commandToRun, asRoot, compatV1,
                        addNV, lowerLayer)

    if parsedArgs.tmp:
        shutil.rmtree(wantedDest)

    return rc


if __name__ == '__main__':
    try:
        RC = main()
    except KeyboardInterrupt as keyboardErr:
        if appLogger:
            appLogger.error('Aborting due to user request.')
            if appLogger.level == logging.DEBUG:
                appLogger.debug(keyboardErr)
        else:
            print('Aborting due to user request.')
        sys.exit(129)
    except BaseException as mainErr: # pylint: disable=broad-except
        if appLogger:
            appLogger.error('Exception: %s', mainErr)
            if appLogger.level == logging.DEBUG:
                raise
        else:
            print('Exception: %s', mainErr)
        sys.exit(130)
    sys.exit(RC)
