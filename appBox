#!/bin/env python3
# -*- coding: utf-8 -*-
# vim:fileencoding=utf-8
# pylint: disable=C0302,C0111,C0103
#
#   ▄▀▀█▄   ▄▀▀▄▀▀▀▄  ▄▀▀▄▀▀▀▄  ▄▀▀█▄▄   ▄▀▀▀▀▄   ▄▀▀▄  ▄▀▄
#  ▐ ▄▀ ▀▄ █   █   █ █   █   █ ▐ ▄▀   █ █      █ █    █   █
#    █▄▄▄█ ▐  █▀▀▀▀  ▐  █▀▀▀▀    █▄▄▄▀  █      █ ▐     ▀▄▀
#   ▄▀   █    █         █        █   █  ▀▄    ▄▀      ▄▀ █
#  █   ▄▀   ▄▀        ▄▀        ▄▀▄▄▄▀    ▀▀▀▀       █  ▄▀
#  ▐   ▐   █         █         █    ▐              ▄▀  ▄▀
#          ▐         ▐         ▐                  █    ▐
# - Written by Rob Currie <rob.currie(at)ed.ac.uk>
#
# This tool is designed to simplify the life of users looking to use
# container-like sandbox environments to do work, testing, hacking
# or just to have a play around.
# This was written to address several issues which all have the same solution,
# but the existing implementations are, well... ugly.
#
# USAGE:
#   Come one come all,
#     See appBox -h or README.md for some examples short&long, good&bad
#
# A tool for building&initializing sandboxes;
# fixing common gotchas
# and generaly allowing users to do more with what they have.
#
# Distributed under the GPLv2 only, but please don't remove attribution when using/modifying this.
#

import argparse
import datetime
import fcntl
from functools import wraps
import http.client
import json
import hashlib
import logging
import math
import os
import platform
import pty
import pwd
import re
import select
import shutil
import signal
import socket
import stat
import struct
import subprocess
import sys
import tarfile
import termios
import threading
import time
import tty
import urllib.request
import urllib.error
from urllib.parse import urlparse
import uuid


__version__ = '3.0.0'
appBoxVersion = __version__


# Global Logger
appLogger = logging.getLogger('appBox')
barLogger = logging.getLogger('barLogger')


class OneLineProgressHandler(logging.StreamHandler):
    def emit(self, record):
        """
        Emit a record with carriage return to overwrite the current line.
        """
        message = self.format(record)
        stream = self.stream
        stream.write(f'\r{message}')  # Overwrite the current line
        stream.flush()


def getUN():
    '''
    Return the username of this account
    '''
    return pwd.getpwuid(os.getuid())[0]


def getHome():
    '''
    Return the home directory of this account
    '''
    return pwd.getpwuid(os.getuid())[5]


def findMountPath(path):
    path = os.path.abspath(path)
    while not os.path.ismount(path):
        path = os.path.dirname(path)
    return path


def printBar(iteration, total, prefix='', suffix='', length=50, fill='█'):
    """
    Call in a loop to create terminal progress bar
    @params:
        iteration   - Required  : current iteration (Int)
        total       - Required  : total iterations (Int)
        prefix      - Optional  : prefix string (Str)
        suffix      - Optional  : suffix string (Str)
        length      - Optional  : character length of bar (Int)
        fill        - Optional  : bar fill character (Str)
    """
    if total<=0:
        total = 1
    percent = 100 * (iteration / float(total))
    percent = f"{round(percent, 2)}"
    filled_length = int(length * iteration // total)
    barStr = fill * filled_length + '-' * (length - filled_length)
    #if appLogger.level <= logging.INFO:
    #barLogger.info(f'{prefix} |{bar}| {percent}% {suffix}')
    barLogger.info('%s |%s| %s%% %s', prefix, barStr, percent, suffix)
    # Print New Line on Complete
    if iteration == total:
        barLogger.info('\n')


def bytesToHuman(num_bytes):
    # Define size units
    units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
    size = num_bytes
    unit_index = 0

    # Loop to determine the appropriate unit
    while size >= 1024 and unit_index < len(units) - 1:
        size /= 1024.0
        unit_index += 1

    # Format the result to 2 decimal places
    return f"{size:.2f} {units[unit_index]}"


class downloadTokenAuthenticator:

    def __init__(self, repoURL="https://example.com", imagePath="project/image"):
        #
        #
        #
        self.token = ""
        self.repoURL = repoURL
        self.imagePath = imagePath
        self.tokenRequired = True
        self.authRealm = ""
        self.authService = ""
        self.authScope = ""
        self.manifestPath = f"/v2/{self.imagePath}/manifests/latest"
        self.tokenExpiry = time.time() - 300  # Assume token is valid for 5min
        #self.getNewToken()

    def _getAuthnService(self):
        #
        #
        appLogger.debug("1) Getting Authn Service: %s", self.repoURL)
        parsedURL = urllib.parse.urlsplit(self.repoURL)
        if (parsedURL.hostname is None) and (parsedURL.netloc is not None):
            remoteHost = parsedURL.netloc
        else:
            remoteHost = parsedURL.hostname
        appLogger.debug(parsedURL)
        appLogger.debug("2) Getting Authn Service: %s", remoteHost)
        conn = http.client.HTTPSConnection(remoteHost,
                                           port=parsedURL.port if parsedURL.port else 443)
        appLogger.debug("Querying Authn Service: %s", self.manifestPath)
        conn.request("GET", self.manifestPath)
        response = conn.getresponse()
        if response.status == 401:
            authHeader = response.getheader('www-authenticate')
            appLogger.debug("Auth Header: %s", authHeader)
            if authHeader:
                match = re.match('[ \t]*([^ \t]+)[ \t]+realm="([^"]*)"', authHeader)
                scheme, realm = match.groups()
                if scheme.lower() != 'bearer':
                    raise ConnectionError(
                        f'Unknown Auth Scheme: "{scheme}" Returned by: "{self.repoURL}"')

                match = re.match('.*service="([^"]*)"', authHeader)
                service = match.groups()[0]
                match = re.match('.*scope="([^"]*)"', authHeader)
                scope = match.groups()[0]

                self.authRealm = realm
                self.authService = service
                self.authScope = scope

        elif response.status >=200 and response.status <= 299:
            self.tokenRequired = False

        elif response.status in [307, 308]:

            raise ConnectionError(f'Redirected to: "{response.getheader("Location")}"')

        return

    def _getDownloadToken(self):

        fullTokenURL = f'{self.authRealm}?service={self.authService}&scope={self.authScope}'
        parsedURL = urllib.parse.urlsplit(fullTokenURL)

        appLogger.debug('token: "%s", "%s"', fullTokenURL, parsedURL)
        if (parsedURL.hostname is None) and (parsedURL.netloc is not None):
            remoteHost = parsedURL.netloc
        else:
            remoteHost = parsedURL.hostname
        appLogger.debug("3) Getting Authn Service: %s", remoteHost)
        conn = http.client.HTTPSConnection(remoteHost,
                                           port=parsedURL.port if parsedURL.port else 443)
        appLogger.debug("Querying Authn Service: %s?%s", parsedURL.path, parsedURL.query)
        conn.request("GET", parsedURL.path + '?' + parsedURL.query)
        response = conn.getresponse()
        tokenResponse = response.read()

        #appLogger.debug("Querying Token: %s", fullTokenURL)
        #tokenResponse = urllib.request.urlopen(urllib.request.Request(
        #    fullTokenURL,
        #)).read()
        #appLogger.debug("Token Response: %s", tokenResponse)

        self.token = json.loads(tokenResponse.decode())['token']

        appLogger.debug("Token: %s",self.token)

    def getNewToken(self):

        if self.tokenRequired:
            self._getAuthnService()
            self._getDownloadToken()
        else:
            return

    def isTokenValid(self):
        return time.time() < self.tokenExpiry

    def refreshToken(self):
        if self.tokenRequired:
            if not self.isTokenValid():
                self.getNewToken()
        else:
            self.token = None

        self.tokenExpiry = time.time() + 300


class imageManager:

    def __init__(self, imagePath="centos:7",
                 installPath=None, layerCacheFolder=None, forceUpdate=False):

        self.userPath = imagePath
        self.imgHash = hashlib.sha256(imagePath.encode()).hexdigest()
        if forceUpdate:
            self.imgHash = 'forceUpdate'

        appLogger.debug('Image Hash: %s', self.imgHash)

        parsedImage = imageManager.parseImgString(imagePath)
        appLogger.debug('Using image String: %s', imagePath)
        appLogger.debug('Parsed Image: %s', parsedImage)
        self.downloadService = parsedImage[0] + '://' + parsedImage[1]
        self.imagePath = parsedImage[2]
        self.imageTag = parsedImage[3]

        userName = pwd.getpwuid(os.getuid())[0]
        if layerCacheFolder is None:
            self.layerCacheFolder = os.path.join(os.path.join('/tmp', 'appBox_'+userName),
                                                 'layerCache')
        else:
            self.layerCacheFolder = layerCacheFolder

        if not os.path.exists(self.layerCacheFolder):
            os.makedirs(self.layerCacheFolder)

        if installPath is None:
            self.installPath = os.path.join(os.path.join('/scratch', 'appBox_'+userName), 'sandbox')
        else:
            self.installPath = installPath

        self.authenticator = downloadTokenAuthenticator(self.downloadService, self.imagePath)

    @staticmethod
    def isUrl(candidate):
        """Check if the given string is a URL, even if it doesn't have a protocol."""
        urlPattern = re.compile(
            r'^(https?|ftp)?(:\/\/)?'
            r'(([a-zA-Z0-9_-]+\.)+[a-zA-Z]{2,6})'
            r'(:\d+)?(/.*)?$'
        )
        return re.match(urlPattern, candidate) is not None

    @staticmethod
    def isLabel(candidate):
        """Check if the given string is a DockerHub label."""
        dockerhubLabelPattern = re.compile(
            r'^[a-z0-9]+([._-][a-z0-9]+)*(/[a-z0-9]+([._-][a-z0-9]+)*)?(:[a-zA-Z0-9_.-]+)?$'
        )
        return re.match(dockerhubLabelPattern, candidate) is not None

    @staticmethod
    def parseImgString(image):
        '''
        Method to parse strings for images, urls, dockerhub label:tags, etc... 
        '''

        imgUrl = imageManager.isUrl(image)
        imgLabel = imageManager.isLabel(image)

        if (not imgLabel) and (not imgUrl):
            raise ValueError(f'Image: "{image}" is not a valid image string')

        if imgLabel and not imgUrl:
            image = 'https://registry-1.docker.io/' + image

        if imgUrl and '://' not in image:
            image = 'https://' + image

        appLogger.debug('Using URL: %s', image)

        parsedURI = urlparse(image)
        appLogger.debug('Parsed URI: %s', parsedURI)

        if parsedURI.scheme != "":
            realScheme = parsedURI.scheme
        else:
            realScheme = 'https'

        appLogger.debug('Adjusted Parsed URI: %s', parsedURI)

        realNetLoc = parsedURI.netloc
        if realNetLoc == "":
            realNetLoc = 'registry-1.docker.io'

        urlPath = parsedURI.path
        if urlPath.startswith('/'):
            urlPath = urlPath[1:]

        imageData = urlPath.split(':')
        imageLabel = imageData[0]

        if len(imageData) == 1:
            tag = 'latest'
        else:
            tag = imageData[1]

        if len(imageLabel.split('/')) == 1:
            imageLabel = 'library/' + imageLabel

        appLogger.debug('Image: %s, Scheme: %s, Netloc: %s, Label: %s, Tag: %s',
                        image, realScheme, realNetLoc, imageLabel, tag)

        return realScheme, realNetLoc, imageLabel, tag

    #@staticmethod This makes Python 3.9 unhappy
    def tokenRequired(func): # pylint: disable=E0213, because of P39
        '''
        '''
        @wraps(func)
        def decorated_function(*args, **kwargs):
            self = args[0]
            self.authenticator.refreshToken()
            return func(*args, **kwargs) # pylint: disable=E1102, because of P39
        return decorated_function

    @staticmethod
    def getHeaders(token):
        returnable = {
                 "Accept":
        "application/vnd.docker.distribution.manifest.v2+json,"+
        "application/vnd.oci.image.manifest.v1+json," +
        "application/vnd.oci.image.config.v1+json,"+
        "application/vnd.docker.distribution.manifest.v1+prettyjws",
                 "Authorization": f"Bearer {token}",
                 "Content-Type": "application/json",
                 "User-Agent": "curl/8.0.1",
        }
        if token is None:
            del returnable['Authorization']
        return returnable

    def getManifest(self, manifestVer=None):

        manCache = os.path.join(self.layerCacheFolder, self.imgHash)

        if manifestVer is None:
            manifestVer = self.imageTag

        contents = {}

        if os.path.exists(manCache):
            with open(manCache, 'r', encoding="utf-8") as _file:
                contents = json.loads(_file.read())
                appLogger.debug('Manifest Cache: %s', contents)

            if manifestVer in contents:
                return contents[manifestVer]
            else:
                remoteMan = self.getRemoteManifest(manifestVer)

        else:
            remoteMan = self.getRemoteManifest(manifestVer)

        contents[manifestVer] = remoteMan

        with open(manCache, 'w', encoding="utf-8") as _file:
            _file.write(json.dumps(contents))

        return contents[manifestVer]

    @tokenRequired
    def getRemoteManifest(self, manifestVer=None):

        if manifestVer is None:
            manifestVer = self.imageTag

        parsedURL = urlparse(self.downloadService)
        manifestPath = f"/v2/{self.imagePath}/manifests/{manifestVer}"

        appLogger.debug("Connecting to Manifest Service: %s", parsedURL.netloc)
        conn = http.client.HTTPSConnection(parsedURL.netloc)

        appLogger.debug("Querying Manifest Service: %s", manifestPath)
        headers = imageManager.getHeaders(self.authenticator.token)

        appLogger.debug("Headers: %s", headers)
        conn.request("GET", manifestPath, headers=headers)

        response = conn.getresponse()
        thisResponse = response.read()
        appLogger.debug("Manifest Response: %s", thisResponse)

        return thisResponse.decode('utf-8')

    @staticmethod
    def checkDownloadIntegrity(downloadLocation, refShasum):

        def compute_sha256(filepath):
            sha256_hash = hashlib.sha256()
            with open(filepath, "rb") as file:
                # Read the file in chunks to handle large files
                # Try reading with 16k blocks
                # TODO add adjustments for block size on error
                for byte_block in iter(lambda: file.read(16384), b""):
                    sha256_hash.update(byte_block)
                return sha256_hash.hexdigest()

        def verify_file_sha256(filepath, reference_sha256):
            computed_sha256 = compute_sha256(filepath)
            if computed_sha256 == reference_sha256:
                appLogger.debug("The file's SHA256 checksum matches the reference.")
                return True
            else:
                appLogger.error("The file's SHA256 checksum does NOT match the reference.")
                appLogger.error("Computed SHA256: %s", computed_sha256)
                appLogger.error("Reference SHA256: %s", reference_sha256)
                return False

        return verify_file_sha256(downloadLocation, refShasum)

    def getLayerFileName(self, digest):
        return os.path.join(self.layerCacheFolder, f"{digest}.tar.gz")

    @tokenRequired
    def downloadLayers(self, digests, retry=True, retryCount=3, retryDelay=0):

        i=0
        for images in digests:
            i+=1

            appLogger.info('Downloading Layer: %s of %s', i, len(digests))
            digest = images['digest']
            retryNum = retryCount

            success = False
            skipped = False
            outputFile = self.getLayerFileName(digest)
            try:
                if os.path.exists(outputFile):
                    appLogger.info("Layer already downloaded: %s", outputFile)
                    skipped = True
                    continue
                else:
                    while retry and (retryNum > 0):
                        try:
                            appLogger.debug('Download Attempt: %s', retryNum)
                            retryNum -= 1
                            _ = self._downloadLayer(digest)
                            success = True
                            break
                        except Exception as err: # pylint: disable=W0703
                            appLogger.debug('Exception raised when downloading: %s', err)
                            time.sleep(retryDelay)
                            self.authenticator.refreshToken()
                        except KeyboardInterrupt as err:
                            appLogger.error('Download Cancelled by User')
                            appLogger.debug('Exception raised when downloading: %s', err)
                            return False
            finally:
                if not success:
                    try:
                        os.unlink(outputFile+'.tmp')
                        os.unlink(outputFile)
                    except FileNotFoundError:
                        pass
                else:
                    appLogger.debug('Successfully Downloaded Layer: %s', digest)
                    if not skipped:
                        os.rename(outputFile+'.tmp', outputFile)
        return True


    def _downloadLocation(self, host, port, path, query, outputFile, digestSha):

        conn = http.client.HTTPSConnection(host, port=port if port else 443)
        appLogger.debug("Querying Authn Service: %s", path)
        appLogger.debug("Query: %s", query)

        if 'X-Amz-SignedHeaders' in query:
            appLogger.debug("Using AWS Signed Query for Auth'n")
            conn.request("GET", path+'?'+query)
        else:
            appLogger.debug("Using Standard Headers for Auth'n")
            conn.request("GET", path+'?'+query,
                     headers=imageManager.getHeaders(self.authenticator.token))
        response = conn.getresponse()

        contentLength = response.getheader('Content-Length')
        if contentLength is not None:
            contentLength = int(contentLength)

        appLogger.info("Downloading Layer %s Size: %s", digestSha, bytesToHuman(contentLength))

        if response.status == 200:
            total=math.ceil(contentLength/4096)
            # Initial call to print 0% progress
            printBar(0, total, prefix = 'Downloading:', suffix = 'Complete', length = 50)
            # Open the output file for writing
            with open(outputFile, 'wb') as file:
                # Read the response in blocks and write to the file
                i=0
                while True:
                    block = response.read(4096)
                    if not block:
                        break
                    file.write(block)
                    i+=1
                    printBar(i, total, prefix = 'Downloading:',
                             suffix = 'Complete', length = 50)
        else:
            appLogger.debug("Failed to download layer: %s", response.read())
            raise ConnectionError(f'Failed to download layer: "{response.status}"')

        if not imageManager.checkDownloadIntegrity(outputFile, digestSha):
            raise ConnectionError('Failed to download layer: "checksum failure"')



    def _downloadLayer(self, digest):

        digestSha = digest.split(':')[1]

        outputFile = self.getLayerFileName(digest) + '.tmp'

        imagePath = f"/v2/{self.imagePath}/blobs/{digest}"

        appLogger.debug("Connecting to Download Service: %s",
                        self.downloadService)
        parsedURL = urllib.parse.urlsplit(self.downloadService)
        conn = http.client.HTTPSConnection(parsedURL.hostname,
                                           port=parsedURL.port if parsedURL.port else 443)
        appLogger.debug("Querying Authn Service: %s", imagePath)

        conn.request("GET", imagePath,
                     headers=imageManager.getHeaders(self.authenticator.token))
        response = conn.getresponse()

        if response.status == 200:
            self._downloadLocation(parsedURL.hostname, parsedURL.port,
                                   imagePath, '', outputFile, digestSha)
        elif response.status == 307:

            appLogger.debug("Redirected to: %s", response.getheader("Location"))
            relocated = response.getheader("Location")

            appLogger.debug("Connecting to Download Service: %s", relocated)
            parsedURL = urllib.parse.urlsplit(relocated)

            self._downloadLocation(parsedURL.hostname, parsedURL.port,
                                   parsedURL.path, parsedURL.query, outputFile, digestSha)

        else:
            raise ConnectionError(f'Failed to download layer: "{response.status}"')

        return True

    @staticmethod
    def getArch():
        if platform.machine().lower() in ['amd64', 'x86_64']:
            return 'amd64'
        elif platform.machine().lower() in ['aarch64', 'arm64']:
            return 'arm64'

    def getDigest(self, manifest):
        '''
        Get the digest for the layers in the manifest
        '''

        digestList = []
        thisConfig = ''

        ## '.fsLayers[]' | jq -r '.blobSum'
        ## Read the blobSum and return

        ## '.layers[0]' | jq -r '.digest'
        ## Read the digest from the layers and return
        appLogger.debug('Manifest: %s', manifest)

        if 'errors' in manifest:
            errs = manifest['errors']
            raise Exception(f'Error in Manifest: {errs}') # pylint: disable=W0719

        if 'layers' in manifest:
            for thisLayer in manifest['layers']:
                digestList.append({'mediaType': thisLayer['mediaType'],
                                    'digest': thisLayer['digest']})
        if 'fsLayers' in manifest:
            for thisLayer in manifest['fsLayers']:
                digestList.append({'mediaType': 'application/vnd.docker.image.rootfs.diff.tar.gzip',
                                    'digest': thisLayer['blobSum']})

        if 'config' in manifest:
            thisConfig = manifest['config']['digest']

        ## '.manifest[0]' | jq -r '.digest'
        ## Read the manifest, get the correct digests and return
        elif 'manifests' in manifest:
            thisArch = self.getArch()
            appLogger.debug('Detected System arch: %s', thisArch)
            for _manifest in manifest['manifests']:
                if _manifest['platform']['architecture'] == thisArch:
                    thisCSum = _manifest['digest']

                    imageManifest = self.getManifest(thisCSum)
                    appLogger.debug('Image Manifest: %s', imageManifest)
                    return self.getDigest(json.loads(imageManifest))

        #raise Exception('here')
        return digestList, thisConfig

    def getConfig(self):

        imageManifest = self.getManifest()
        _, digest = self.getDigest(json.loads(imageManifest))

        appLogger.debug('Config: %s', digest)

        _content = {}

        configPath = self.getLayerFileName(digest)[:-7]

        if not os.path.exists(configPath):
            self._downloadConfig(digest)

        with open(configPath, 'r', encoding="utf-8") as _file:
            _content = json.loads(_file.read())
            appLogger.debug('Config Content: %s', _content)

        appLogger.debug('Container ENV: %s', _content['config']['Env'])

        return _content

    def _downloadConfig(self, digest):

        success = False
        try:
            self._downloadLayer(digest)
            success = True
        finally:
            if not success:
                try:
                    os.unlink(self.getLayerFileName(digest)+'.tmp')
                    os.unlink(self.getLayerFileName(digest))
                except FileNotFoundError:
                    pass

        os.rename(self.getLayerFileName(digest)+'.tmp', self.getLayerFileName(digest)[:-7])

    def downloadImage(self):

        imageManifest = self.getManifest()

        imageDigests, _ = self.getDigest(json.loads(imageManifest))

        self.getConfig()

        appLogger.debug('Image Digests: %s', imageDigests)

        if self.downloadLayers(imageDigests):
            appLogger.debug('Returning Image Digests: %s', imageDigests)
            return imageDigests
        else:
            return []

    def extractImage(self, overridePath=None):

        installPath = overridePath if overridePath else self.installPath

        if os.path.exists(installPath):
            appLogger.error("Install Path already exists: %s", installPath)
            raise FileExistsError(f'Install Path already exists: "{installPath}"')

        try:
            return self._extractLayers(installPath)
        except Exception as err: # pylint: disable=W0703
            appLogger.error('Failed to extract layers: %s', err)
            if appLogger.level == logging.DEBUG:
                raise
            if os.path.exists(installPath):
                appLogger.error('Cleaning up: %s', installPath)
                shutil.rmtree(installPath)
            return 1

    def _extractLayers(self, installPath):

        for layer in self.downloadImage():

            layerFile = self.getLayerFileName(layer['digest'])

            layerSize = os.path.getsize(layerFile)
            appLogger.info('Opening Layer: %s (%s)', layerFile, bytesToHuman(layerSize))

            with tarfile.open(layerFile, 'r:gz', errorlevel=1) as _tfile:

                total=0
                for _entry in _tfile:
                    total+=1
                appLogger.info('#%s Files/Folders', total)
                if total == 0:
                    break

                printBar(0, total, prefix = 'Extracting:', suffix = 'Complete', length = 50)
                i=0
                for _entry in _tfile:
                    i+=1
                    printBar(i, total, prefix = 'Extracting:', suffix = 'Complete', length = 50)
                    #total=len(_tfile.getmembers())
                    #if i%100 == 0:
                    #    appLogger.debug('Extracting: %s/%s', i, total)
                    #i+=1
                    #appLogger.debug('Extracting: {}'.format(_entry.name))
                    if _entry.isdir():
                        os.makedirs(os.path.join(installPath, _entry.name), exist_ok=True)
                    else:
                        if os.path.exists(os.path.join(installPath, _entry.name)):
                            os.remove(os.path.join(installPath, _entry.name))
                        parent = os.path.dirname(os.path.join(installPath, _entry.name))
                        os.makedirs(os.path.join(installPath, parent), exist_ok=True)
                        if not (_entry.issym() or _entry.islnk()):
                            current = stat.S_IMODE(os.lstat(parent).st_mode)
                            os.chmod(parent, current | stat.S_IWUSR | stat.S_IRUSR | stat.S_ISGID)
                        try:
                            _tfile.extract(_entry, path=installPath, filter='fully_trusted')
                        except TypeError:
                            _tfile.extract(_entry, path=installPath)
                        if not (_entry.issym() or _entry.islnk()):
                            output = os.path.join(installPath, _entry.name)
                            current = stat.S_IMODE(os.lstat(output).st_mode)
                            os.chmod(output, current | stat.S_IWUSR | stat.S_IRUSR | stat.S_ISGID)
        return 0


class sandboxFixes:
    '''
    Class to handle the fixes needed for the sandbox
    '''

    def __init__(self, addNV, sandboxInstance, iManager):
        '''
        '''

        self.addNVidia = addNV
        self.sandboxInstance = sandboxInstance
        self.iManager = iManager

        self.tmpPath = '/tmp'

    def applyAllFixes(self):
        '''
        Apply all of the fixes to this sandbox
        '''
        self.fixFilePermissions()
        self.fixAptSandboxing()
        self.fixDnfSandboxing()
        self.fixMissingPaths()
        self.fixMissingStubs()
        self.fixUserAccounts()
        self.fixAliases()
        self.fixEnvironment()
        self.installAppBox()
        self.copyFromHost()
        self.fixForLies()
        self.applyImageEnv()
        self.stampSandbox()

    def copyFromHost(self):
        '''
        Copy certain configs from the host to the sandbox so things work
        '''

        fileList = ['/etc/resolv.conf', '/etc/hostname',
                    '/etc/localtime', '/etc/timezone', '/etc/vimrc']

        for _file in fileList:
            self.sandboxInstance.copyFileFromHost(_file,
                    os.path.abspath(os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_file)))

    def fixFilePermissions(self):
        '''
        Fix the permissions of a given path
        '''
        if self.sandboxInstance.rootfs:
            return
        for root, dirs, files in os.walk(self.sandboxInstance.getSandboxPath(), topdown=True):
            for _dir in dirs:
                thisPath = os.path.join(root,_dir)
                if not os.path.islink(thisPath):
                    current = stat.S_IMODE(os.lstat(thisPath).st_mode)
                    os.chmod(thisPath, current | stat.S_IWUSR | stat.S_IRUSR | stat.S_ISGID)
            for _file in files:
                thisPath = os.path.join(root,_file)
                if not os.path.islink(thisPath):
                    current = stat.S_IMODE(os.lstat(thisPath).st_mode)
                    os.chmod(os.path.join(root,_file), current | stat.S_IWUSR | stat.S_IRUSR)

    def _getPathList(self):
        '''
        Return the list of paths we want to mount into the sandbox
        '''
        # This is a good fraction of the lsb because not all images follow the lsb...
        # which means...
        # well...
        # yeah...
        basePathList = ['/afs', '/dev', '/etc', '/cvmfs', '/scratch', '/Data', '/localdisk',
                          '/sys', '/tmp', '/home', '/proc', f'/tmp/{getUN()}', '/mnt']

        if self.addNVidia:
            basePathList.append('/usr/lib/wsl')

        return basePathList

    def fixMissingPaths(self):
        '''
        Fix potentially missing paths in the sandbox
        '''
        neededSandboxPaths = self._getPathList()

        absPaths = []
        for _path in neededSandboxPaths:
            absPaths.append(os.path.abspath(
                        os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_path)))

        for _path in absPaths:
            self.sandboxInstance.createSandboxPath(_path)

    def _getStubList(self):
        '''
        Make stubs for files to be mounted in from the host
        '''
        baseStubs = ['/etc/resolv.conf', '/etc/hostname']

        if self.addNVidia:
            baseStubs.append('/usr/bin/nvidia-smi')
            baseStubs.append('/usr/bin/nvidia-modprobe')

        return baseStubs

    def fixMissingStubs(self):
        '''
        Create the stubs needed for the sandbox
        '''
        neededStubs = self._getStubList()

        absPaths = []
        for _path in neededStubs:
            absPaths.append(os.path.abspath(
                        os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_path)))

        for _path in absPaths:
            self.sandboxInstance.createSandboxEmptyFile(_path)

    def getAnonUIDGID(self):
        '''
        Return the Anon UID and GID for the sandbox
        In principle this can change based on the system, but for now it's fixed
        '''
        # TODO work out if we need to detect/change this
        return (65534, 65534)

    def fixUserAccounts(self):
        '''
        Fix the user accounts within the sandbox
        '''
        tmpPasswdFile = os.path.join(self.tmpPath, f'passwd_{str(uuid.uuid4())[:8]}')
        try:
            self._fixPasswd(tmpPasswdFile)
        finally:
            os.unlink(tmpPasswdFile)
        tmpGroupFile = os.path.join(self.tmpPath, f'group_{str(uuid.uuid4())[:8]}')
        try:
            self._fixGroup(tmpGroupFile)
        finally:
            os.unlink(tmpGroupFile)
        tmpShadowFile = os.path.join(self.tmpPath, f'gshadow_{str(uuid.uuid4())[:8]}')
        try:
            self._fixGShadow(tmpShadowFile)
        finally:
            os.unlink(tmpShadowFile)

    def _fixPasswd(self, tmpPasswdFile):
        '''
        Fix the passwd config so the user mappings make sense
        '''
        self.sandboxInstance.copyFileToHost('/etc/passwd', tmpPasswdFile)

        with open(tmpPasswdFile, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('File: "%s"', tmpPasswdFile)
            appLogger.debug('Content: "%s"', _content)

        newContent = 'root:x:0:0:root:/root:/bin/bash\n'
        newContent += f'{getUN()}:x:65534:65534:{getUN()}:{getHome()}:/bin/bash\n'

        aUID, aGID = self.getAnonUIDGID()

        for _line in _content.split('\n'):
            if _line:
                _user, _, _uid, _gid, _name, _home, _shell = _line.split(':')
                if _user in ['root', getUN(), 'fax', 'input', 'kvm', 'render']:
                    continue
                if _user.startswith('systemd'):
                    # A dirty trick to keep apt 'content' on Ubuntu systems
                    continue
                appLogger.debug(
                    'User: "%s", UID: "%s", GID: "%s", Name: "%s", Home: "%s", Shell: "%s"',
                                    _user, _uid, _gid, _name, _home, _shell)

                newContent += f'{_user}:x:{aUID}:{aGID}:{_name}:{_home}:{_shell}\n'

        with open(tmpPasswdFile, 'w+', encoding='utf-8') as _file:
            _file.write(newContent)

        self.sandboxInstance.copyFileFromHost(tmpPasswdFile,
                            os.path.join(self.sandboxInstance.getSandboxPath(), './etc/passwd'))

    def _fixGroup(self, tmpGroupFile):
        '''
        Fix the group permissions so that mappings make sense
        '''
        self.sandboxInstance.copyFileToHost('/etc/group', tmpGroupFile)

        with open(tmpGroupFile, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('File: "%s"', tmpGroupFile)
            appLogger.debug('Content: "%s"', _content)

        _, aGID = self.getAnonUIDGID()

        newContent = 'root:x:0:\n'
        newContent += f'{getUN()}:x:{aGID}:\n'

        for _line in _content.split('\n'):
            if _line:
                _group, _, _gid, _users = _line.split(':')
                if _group in ['root', getUN(), 'fax', 'input', 'kvm', 'render']:
                    continue
                if _group.startswith('systemd'):
                    # A dirty trick to keep apt 'content' on Ubuntu systems
                    continue
                appLogger.debug('Group: "%s", GID: "%s", Users: "%s"', _group, _gid, _users)

                newContent += f'{_group}:x:{aGID}:{_users}\n'

        with open(tmpGroupFile, 'w+', encoding='utf-8') as _file:
            _file.write(newContent)

        self.sandboxInstance.copyFileFromHost(tmpGroupFile,
                                os.path.join(self.sandboxInstance.getSandboxPath(), './etc/group'))

    def _fixGShadow(self, tmpShadowFile):
        '''
        This fixes the gshadow config, mainly for debian systems
        '''
        self.sandboxInstance.copyFileToHost('/etc/gshadow', tmpShadowFile)
        with open(tmpShadowFile, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('File: "%s"', tmpShadowFile)
            appLogger.debug('Content: "%s"', _content)

        newContent = ''

        for _line in _content.split('\n'):
            if _line:
                _pass = True
                for check in ['fax', 'voice', 'sudo', 'dip', 'operator', 'src',
                              'shadow', 'sasl', 'plugdev', 'staff', 'nogroup']:
                    if _line.startswith(check):
                        _pass = False
                        break
                if not _pass:
                    continue
                newContent += _line + '\n'

        with open(tmpShadowFile, 'w+', encoding='utf-8') as _file:
            _file.write(newContent)

        self.sandboxInstance.copyFileFromHost(tmpShadowFile,
                            os.path.join(self.sandboxInstance.getSandboxPath(), './etc/gshadow'))

    def fixAliases(self):
        '''
        Fix the aliases in the sandbox
        '''

        self.sandboxInstance.createSandboxPath(
                    os.path.join(self.sandboxInstance.getSandboxPath(), './etc/profile.d'))

        def fixDeactivate():
            tmpDeacScript = os.path.join(self.tmpPath, f'deactivate_{str(uuid.uuid4())[:8]}')
            with open(tmpDeacScript, 'w+', encoding='utf-8') as _file:
                _file.write('#!/bin/bash\nfor i in $(seq 100); do kill -s 1 ${i} 2>&1 | true ; done\n')
            try:
                st = os.stat(tmpDeacScript)
                os.chmod(tmpDeacScript, st.st_mode | stat.S_IEXEC)
                self.sandboxInstance.copyFileFromHost(tmpDeacScript,
                        os.path.join(self.sandboxInstance.getSandboxPath(), './usr/bin/deactivate'))
            finally:
                os.unlink(tmpDeacScript)

        fixDeactivate()

    def fixEnvironment(self):
        '''
        Fix missing env vars at 'login' which includes wsl linkage
        '''

        if self.addNVidia:
            self.sandboxInstance.createSandboxPath(
                os.path.join(self.sandboxInstance.getSandboxPath(), './etc/ld.so.conf.d'))
            tmpLDPath = os.path.join(self.tmpPath, f'ld.wsl.conf_{str(uuid.uuid4())[:8]}')
            with open(tmpLDPath, 'w+', encoding='utf-8') as _file:
                _file.write('/usr/lib/wsl/lib')
            try:
                self.sandboxInstance.copyFileFromHost(tmpLDPath,
                    os.path.join(self.sandboxInstance.getSandboxPath(), './etc/ld.so.conf.d/wsl.conf'))
            finally:
                os.unlink(tmpLDPath)

        def setEnvVar(tmpENVFile):
            '''
            Build the env vars which we want to expose users to
            '''

            _home = getHome()
            envs  = 'export DEBIAN_FRONTEND="noninteractive"\n'
            envs += 'export TERM=xterm-256color\n'
            envs += 'export HOME=$( [ $(id -u) -eq 0 ] && echo "/root" ||'
            envs += f'echo "{_home}" )\n'
            envs += f'export HOSTNAME={socket.gethostname()}\n'
            envs += 'export DISPLAY=:0\n'
            envs += 'export WAYLAND_DISPLAY=wayland-0\n'
            envs += 'if [ $(id -u) -eq 0 ]; then USR_MSG="\033[1;31mAS ROOT\033[0m"; else USR_MSG="\033[32mas $(whoami)\033[0m"; fi\n'
            envs += 'echo "\n Now Running \033[31m[\033[33ma\033[32mp'
            envs += '\033[36mp\033[32mB\033[36mo\033[34mx\033[m]\033[0m ! '
            envs += f'(sandbox based on image: \033[1;31m{self.iManager.userPath}\033[0m) '
            envs += ' ${USR_MSG}\n"\n'
            envs += '/usr/sbin/ldconfig\n'
            with open(tmpENVFile, 'w+', encoding='utf-8') as _file:
                _file.write(envs)
            self.sandboxInstance.copyFileFromHost(tmpENVFile,
                    os.path.join(self.sandboxInstance.getSandboxPath(), './etc/profile.d/env.sh'))

        tmpENVFile = os.path.join(self.tmpPath, f'env.sh_{str(uuid.uuid4())[:8]}')
        try:
            setEnvVar(tmpENVFile)
        finally:
            os.unlink(tmpENVFile)

    def fixAptSandboxing(self):
        '''
        Fix issues related to installing packages on Debian in a single-user-sandbox...
        '''

        appConfPath = os.path.join(self.sandboxInstance.getSandboxPath(), './etc/apt/apt.conf.d/')
        self.sandboxInstance.createSandboxPath(appConfPath)

        layerPath = os.path.join(self.sandboxInstance.sandboxPath, './etc/apt/apt.conf.d/')
        if os.path.exists(layerPath):
            # Only want to apply this 'fix' in sandboxes where apt is installed

            fixApt  = 'APT::Sandbox::User "root";\nAPT::Sandbox::Verify "0";\n'
            fixApt += 'APT::Sandbox::Verify::IDs "0";\nAPT::Sandbox::Verify::Groups "0";\n'
            fixApt += 'APT::Sandbox::Verify::Regain "0";'

            tmpSandbox = os.path.join(self.tmpPath, f'sandbox-disable_{str(uuid.uuid4())[:8]}')
            with open(tmpSandbox, 'w+', encoding='utf-8') as _file:
                _file.write(fixApt)

            try:
                self.sandboxInstance.copyFileFromHost(tmpSandbox, os.path.join(appConfPath, '99appBox'))
            finally:
                os.unlink(tmpSandbox)

            ## Hack of a hack...
            ## cp /bin/true /usr/bin/dpkg-statoverride

            shutil.copyfile(os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/true'),
                os.path.join(self.sandboxInstance.getSandboxPath(), 'usr/bin/dpkg-statoverride'))

            shutil.copyfile(os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/true'),
                    os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/dpkg-statoverride'))

    def fixDnfSandboxing(self):
        '''
        Fix issues with Fedora sandboxing since we're now in a competition to do this...
        '''

        appConfPath = os.path.join(self.sandboxInstance.getSandboxPath(), './etc/dnf/')
        self.sandboxInstance.createSandboxPath(appConfPath)

        layerPath = os.path.join(self.sandboxInstance.sandboxPath, './etc/dnf/')
        if os.path.exists(layerPath):
            # Only want to apply this 'fix' in sandboxes where apt is installed

            fixDNF  = '[main]\n'
            fixDNF += 'gpgcheck=True\n'
            fixDNF += 'installonly_limit=3\n'
            fixDNF += 'clean_requirements_on_remove=True\n'
            fixDNF += 'best=False\n'
            fixDNF += 'skip_if_unavailable=True\n'
            fixDNF += 'tsflags=nodocs\n'
            fixDNF += 'excludepkgs=rpm-plugin-ima,ima-evm-utils\n' # <- the main fix(!)

            tmpSandbox = os.path.join(self.tmpPath, f'dnf.conf_{str(uuid.uuid4())[:8]}')
            with open(tmpSandbox, 'w+', encoding='utf-8') as _file:
                _file.write(fixDNF)

            try:
                self.sandboxInstance.copyFileFromHost(tmpSandbox, os.path.join(appConfPath, 'dnf.conf'))
            finally:
                os.unlink(tmpSandbox)

    def installAppBox(self):
        '''
        Install the appBox tool into the sandbox
        '''

        currentInstance = os.path.abspath(__file__)
        if not os.path.exists(os.path.join(self.sandboxInstance.sandboxPath, './bin')):
            os.makedirs(os.path.join(self.sandboxInstance.sandboxPath, './bin'))
        installInstance = os.path.join(self.sandboxInstance.sandboxPath, './bin/appBox')

        self.sandboxInstance.copyFileFromHost(currentInstance, installInstance)

        cvmfsArgs = ''
        if self.sandboxInstance.rootfs:
            cvmfsArgs = f'-cvmfs {os.path.abspath(self.sandboxInstance.rootfs)}'

        for _ in ['user', 'root']:
            if _ == 'root':
                asString = '-rcr "${cmd}"'
                scriptName = 'activate-asroot'
            else:
                asString = '-rc "${cmd}"'
                scriptName = 'activate'

            activateScript = """#!/bin/bash

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

if [ "$#" -eq 0 ]; then
  cmd="env -i --default-signal=SIGHUP /bin/bash -l "
else
  cmd="$*"
fi

/bin/env python3 ${SCRIPT_DIR}/appBox """
            activateScript = activateScript + cvmfsArgs
            activateScript = activateScript + " -l ${SCRIPT_DIR}/../ """ + asString

            activatePath = os.path.join(self.sandboxInstance.sandboxPath, f'./bin/{scriptName}')
            with open(activatePath, 'w+', encoding='utf-8') as _file:
                _file.write(activateScript)

            for _file in [installInstance, activatePath, ]:
                st = os.stat(_file)
                os.chmod(_file, st.st_mode | stat.S_IEXEC)

    def fixForLies(self):
        '''
        Override some commands to stop people doing bad things by accident,
        or on-purpose to themselves
        '''

        ## TODO decide if this is a bad idea or not...
        ## Intention here is to 'stop' automated tooling from trying to do something
        ## bad within the sandbox. This has the side-effect of stopping people changing
        ## a file so that they can't so anything with it without magic cmdline-fu (d'oh!)

        for _file in ['/usr/bin/chown', '/bin/chown',
                      '/usr/bin/su', '/bin/su', '/usr/bin/sudo', '/bin/sudo']:
            self.sandboxInstance.copyFileFromHost(
                            os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/true'),
                            os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_file))
            self.sandboxInstance.copyFileFromHost(
                            os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/true'),
                            os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_file))

    def applyImageEnv(self):

        thisConfig = self.iManager.getConfig()

        all_envs = ""
        for _env in thisConfig['config']['Env']:

            appLogger.debug('Setting Environment %s', _env)
            k, v = _env.split('=')
            all_envs += f"export {k}=\"{v}\"\n"

        all_envs += 'alias deactivate=/bin/deactivate\n'

        tmpENVFile = os.path.join(self.tmpPath, f'env.sh_{str(uuid.uuid4())[:8]}')
        with open(tmpENVFile, 'w+', encoding='utf-8') as _file:
            _file.write(all_envs)
        try:
            self.sandboxInstance.copyFileFromHost(tmpENVFile,
                    os.path.join(self.sandboxInstance.getSandboxPath(), './etc/profile.d/imageEnv.sh'))
        finally:
            os.unlink(tmpENVFile)

    def stampSandbox(self):

        stampFile = os.path.join(self.sandboxInstance.getSandboxPath(), '.appBox')

        appBoxData = {}
        appBoxData['version'] = appBoxVersion
        appBoxData['image'] = self.iManager.userPath
        appBoxData['createTime'] = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        appBoxData['originalSandboxPath'] = self.sandboxInstance.getSandboxPath()
        appBoxData['originalUser'] = getUN()
        appBoxData['originalUIDGID'] = f"{os.getuid()}:{os.getgid()}"


        with open(stampFile, 'w', encoding='utf-8') as _file:
            _file.write(json.dumps(appBoxData, indent=4))

class sessionManager:
    '''
    Class for managing interactive sandbox sessions
    '''

    def __init__(self, sandboxPath, compatV1=False, addNV=False, rootfs=None):
        '''
        Standard __init__ :)
        '''
        self.proc = None
        self.pidParent = None
        self.pidChild = None
        self.oldTTY = None
        self.sandboxPath = sandboxPath
        self.compatV1 = compatV1
        self.addNVidia = addNV

        self.stdoutM, self.stdoutS = None, None
        self.running = False

        self.proc2 = None
        self.pidSubChild, self.pidSubParent = None, None

        self.rootfs = rootfs
        self._layers = ['._appBoxLayers/overlay', '._appBoxLayers/upper', '._appBoxLayers/work']

        self.ptyMfd, self.ptySfd = None, None

    def getSandboxPath(self):
        '''
        Return the path to the sandbox
        '''
        if self.rootfs:
            rootFS = os.path.join(self.sandboxPath, '._appBoxLayers/overlay')
            appLogger.debug('Sandbox Path: %s', rootFS)
            return rootFS
        else:
            appLogger.debug('Sandbox Path: %s', self.sandboxPath)
            return self.sandboxPath

    def setraw(self, fd, when=termios.TCSAFLUSH):
        """Put terminal into a raw mode."""

        # Indexes for termios list.
        iFLAG = 0
        #OFLAG = 1
        cFLAG = 2
        lFLAG = 3
        #ISPEED = 4
        #OSPEED = 5
        cc = 6

        mode = termios.tcgetattr(fd)
        mode[iFLAG] = mode[iFLAG] & ~(termios.BRKINT | termios.ICRNL |
                                      termios.INPCK | termios.ISTRIP | termios.IXON)
        #mode[OFLAG] = mode[OFLAG] & ~(termios.OPOST)
        mode[cFLAG] = mode[cFLAG] & ~(termios.CSIZE | termios.PARENB)
        mode[cFLAG] = mode[cFLAG] | termios.CS8
        mode[lFLAG] = mode[lFLAG] & ~(termios.ECHO | termios.ICANON |
                                      termios.IEXTEN | termios.ISIG)
        mode[cc][termios.VMIN] = 1
        mode[cc][termios.VTIME] = 0
        termios.tcsetattr(fd, when, mode)

    def _wrangleTTY(self):
        '''
        This is some boiler-plate for setting up a pTTY
        '''

        # save original tty setting then set it to raw mode
        oldTTY = termios.tcgetattr(sys.stdin)
        #tty.setraw(sys.stdin.fileno())
        self.setraw(sys.stdin.fileno(), when=termios.TCSANOW)

        # open pseudo-terminal to interact with subprocess
        stdoutMfd, stdoutSfd = pty.openpty()

        size = os.get_terminal_size()
        winsize = struct.pack("HHHH", size[1], size[0], 0, 0)

        fcntl.ioctl(stdoutMfd, termios.TIOCSWINSZ, winsize)

        appLogger.debug('Opening PTY')

        self.oldTTY = oldTTY
        self.stdoutM, self.stdoutS = stdoutMfd, stdoutSfd

    def setupHostSpace(self):
        '''
        This sets up a 'root' namespace.
        This persists for the lifetime of this shell.
        '''

        if self.rootfs:
            for _layer in self._layers:
                thisLayer = os.path.join(self.sandboxPath, _layer)
                if not os.path.exists(thisLayer):
                    os.makedirs(thisLayer)

        backgroundTask='/bin/bash'
        appLogger.debug('Launching host namespace manager')
        hostManager=f"unshare -primf --propagation unchanged {backgroundTask}"
        appLogger.debug(hostManager)
        # pylint: disable=locally-disabled, subprocess-popen-preexec-fn
        self.proc = subprocess.Popen(hostManager,
                                     shell=True, preexec_fn=os.setsid,
                                     stdin = subprocess.PIPE,
                                     stdout = subprocess.PIPE,
                                     stderr = subprocess.PIPE,
                                     universal_newlines = True)

        appLogger.debug('Host sandbox namespace: %s', self.proc.pid)
        self.pidParent=self.proc.pid
        time.sleep(0.1)

        parentID = self.pidParent
        childID = parentID
        while True:

            appLogger.debug('Parent PID: %s', parentID)
            appLogger.debug('Child PID: %s', childID)
            try:
                parentID, childID = self.getChildID(childID)
                self.pidChild = childID
            except (OSError, ValueError) as pidErr:
                appLogger.debug('Error: %s', pidErr)
                break
            time.sleep(0.1)

            appLogger.debug('---')

        if not self.pidChild:
            raise SystemError('Cannot Fork Child Process. Are you trying to run inside appBox?')

        return self.pidParent, self.pidChild

    def _copyToFromSandbox(self, source, dest):
        '''
        Copy files from A to B
        '''
        copyCMD = f'cp -rfHL --remove-destination {source} {dest}'
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s',
                            self.pidChild, copyCMD)

        copyProc = subprocess.Popen(
                f'nsenter --preserve-credentials --user --mount --pid -t {self.pidChild} {copyCMD}',
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        ## TODO add better error checking here
        copyProc.wait()
        copyRC = copyProc.poll()
        appLogger.debug('Copy RC: %s', copyRC)
        del copyProc

    def copyFileFromHost(self, hostFile, sandboxFile):
        '''
        Copy a file from the host into the sandbox
        '''
        i=0
        while os.path.islink(hostFile):
            appLogger.debug('Symlink: %s -> %s', hostFile, os.readlink(hostFile))
            hostFile = os.readlink(hostFile)
            i=i+1
            if i>10:
                break
        if i>10:
            appLogger.error('Too many symlinks in file: %s', hostFile)
            return
        #if self.compatV1:
        #    sandboxFile = os.path.join(self.getSandboxPath(), '.'+sandboxFile)
        self._copyToFromSandbox(hostFile, sandboxFile)

    def copyFileToHost(self, sandboxFile, hostFile):
        '''
        Copy a file from a Sandbox to the host
        '''
        #if self.compatV1:
        sandboxFile = os.path.join(self.getSandboxPath(), '.'+sandboxFile)
        self._copyToFromSandbox(sandboxFile, hostFile)

    def createSandboxPath(self, path, overridePID=None):
        '''
        Create a new path within the sandbox
        '''
        pidSpace = self.pidChild
        if overridePID:
            pidSpace = overridePID
        createCMD = f'mkdir -p {os.path.abspath(path)}'
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s',
                            pidSpace, createCMD)

        createProc = subprocess.Popen(
                f'nsenter --preserve-credentials --user --mount --pid -t {pidSpace} {createCMD}',
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        ## TODO add better error checking here
        createProc.wait()
        appLogger.debug('CreatePath RC: %s', createProc.poll())
        del createProc

    def createSandboxEmptyFile(self, path):
        '''
        Create an empty 'stub' file in the sandbox
        '''
        createCMD = f'touch {os.path.abspath(path)}'

        createProc = subprocess.Popen(
            f'nsenter --preserve-credentials --user --mount --pid -t {self.pidChild} {createCMD}',
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        ## TODO add better error checking here
        createProc.wait()
        appLogger.debug('CreateFile RC: %s', createProc.poll())
        del createProc

    def getChildID(self, thisPID):
        '''
        Get the child ID of a given PID
        '''
        childPIDPath = f'/proc/{thisPID}/task/{thisPID}/children'
        appLogger.debug('Querying ID: %s', childPIDPath)
        with open(childPIDPath, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('File: "%s"', childPIDPath)
            appLogger.debug('Content: "%s"', _content)
            childPid = int(_content)
            appLogger.debug('PID: %s', childPid)

        return thisPID, childPid

    def getSharePaths(self):
        '''
        This is a list of directories to be mounted into the sandbox from the host
        '''
        _home = getHome()
        homeMount = findMountPath(_home)

        mounts = ['/afs', '/home', '/tmp', '/dev', '/cvmfs',
                  '/scratch', '/Data', '/localdisk', '/sys', '/mnt',
                  '/mnt/wsl', '/mnt/wslg']
        if _home not in mounts:
            mounts += [_home,]
        if homeMount != '/' and (homeMount not in mounts):
            mounts += [homeMount,]
        appLogger.debug('SharePaths: %s', mounts)
        if self.addNVidia:
            mounts += ['/usr/lib/wsl', '/usr/bin/nvidia-smi', '/usr/bin/nvidia-modprobe']
        return mounts

    def mountHost(self, overridePID=None):
        '''
        Mount the shared paths between the host and the sandbox namespace
        '''
        hostMounts = self.getSharePaths()

        for hostPath in hostMounts:

            sandboxPath = os.path.abspath(os.path.join(self.getSandboxPath(), '.' + hostPath))

            if not os.path.exists(hostPath):
                appLogger.debug('Skipping path %s, as it doesn\'t exist on the host', hostPath)
                continue

            appLogger.debug('Bind Mounting: %s as: %s', hostPath, sandboxPath)
            if os.path.isdir(hostPath):
                self.createSandboxPath(sandboxPath, overridePID)
            else:
                self.createSandboxEmptyFile(sandboxPath)

            pidSpace = self.pidChild
            mountOpts = '--rbind --make-rslave'
            if overridePID:
                pidSpace = overridePID
                mountOpts = '--rbind'

            appLogger.debug(
                'nsenter --preserve-credentials --user --mount --pid -t %s mount %s %s %s',
                                pidSpace, mountOpts, hostPath, sandboxPath)

            mountCMD = 'nsenter --preserve-credentials --user --mount --pid -t'
            mountCMD = mountCMD + f' {pidSpace} mount {mountOpts} {hostPath} {sandboxPath}'
            mountProc = subprocess.Popen(
                            mountCMD,
                            stdin = subprocess.PIPE,
                            stdout = subprocess.PIPE,
                            stderr = subprocess.PIPE,
                            shell=True)
            mountProc.wait()
            ## TODO add better error checking here
            appLogger.debug('MountHost RC: %s', mountProc.poll())
            del mountProc

    def mountrootfs(self, rootfs):
        '''
        Mount the ROOTFS for the sandbox from a RO source
        '''

        rootfsPath = os.path.realpath(os.path.abspath(os.path.join(rootfs)))

        neededLayers = ['._appBoxLayers/overlay', '._appBoxLayers/upper', '._appBoxLayers/work']

        layerPaths = []
        for _layer in neededLayers:

            layerPath = os.path.abspath(os.path.join(self.sandboxPath, _layer))

            if not os.path.exists(layerPath):
                os.makedirs(layerPath)

            layerPaths.append(layerPath)

        rootfsMountCMD = 'fuse-overlayfs -o squash_to_root -o'
        rootfsMountCMD = rootfsMountCMD + f' lowerdir={rootfsPath},upperdir={layerPaths[1]}'
        rootfsMountCMD = rootfsMountCMD + f',workdir={layerPaths[2]} {layerPaths[0]}'

        appLogger.debug('Mounting rootfs via: %s', rootfsMountCMD)

        mountProc = subprocess.Popen(
        f'nsenter --preserve-credentials --user --mount --pid -t {self.pidChild} {rootfsMountCMD}',
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        ## TODO add better error checking here
        mountProc.wait()
        appLogger.debug('Mount RC: %s', mountProc.poll())
        del mountProc

    def cleanupSpaces(self):
        '''
        Cleanup the 'persistent' spaces which have been created
        '''
        # restore tty settings back
        try:
            #os.write(sys.stdin.fileno(), '\n\r'.encode())
            # Restore the stdin back to what it used to be
            #termios.tcsetattr(sys.stdin, termios.TCSANOW, self.oldTTY)
            if getattr(self, 'proc', None) and self.proc.pid:
                os.killpg(os.getpgid(self.proc.pid), signal.SIGKILL)
            sys.stdin.flush()
            sys.stdout.flush()
        except (IOError, OSError) as delErr:
            appLogger.debug('Deletion Error: %s', delErr)

    def setupSubSpace(self, asRoot):
        '''
        Create a subSpace within the root space of the host
        '''
        appLogger.debug('Setting up SubSpace')

        chrootCMD = self._getSandboxCmd(None, asRoot)
        # pylint: disable=locally-disabled, subprocess-popen-preexec-fn
        self.proc2 = subprocess.Popen(chrootCMD,
                                     shell=True, preexec_fn=os.setsid,
                                     stdin = subprocess.PIPE,
                                     stdout = subprocess.PIPE,
                                     stderr = subprocess.PIPE,
                                     universal_newlines = True)

        appLogger.debug('PID of subSpace: %s', self.proc2.pid)

        self.pidSubParent=self.proc2.pid

        time.sleep(0.1)

        with open(f'/proc/{self.pidSubParent}/task/{self.pidSubParent}/children',
                  'r', encoding='utf-8') as _file:
            self.pidSubChild=int(_file.read())
            appLogger.debug('Child PID: %s', self.pidSubChild)

        return (self.pidSubParent, self.pidSubChild)

    def _getSandboxCmd(self, command=None, asRoot=False):
        '''
        Get the command to run inside the sandbox (i.e. the shell)
        '''

        if command is None:
            if self.rootfs:
                commandPath = os.path.join(self.rootfs, 'bin/bash')
            else:
                commandPath = os.path.join(self.sandboxPath, 'bin/bash')
            if os.path.exists(commandPath):
                command = 'env -i --default-signal=SIGHUP /bin/bash -c "sleep 1; env -i --default-signal=SIGHUP /bin/bash --rcfile /etc/profile -l; exit $?"'
            else:
                command = 'env -i /bin/sh'
        else:
            if not self.compatV1:
                commandPath = os.path.join(self.sandboxPath, 'bin/bash')
                if os.path.exists(commandPath):
                    command = f'env -i --default-signal=SIGHUP /bin/bash --rcfile /etc/profile -c "sleep 1; {command}" '
                else:
                    pass
            else:
                command = f'env -i --default-signal=SIGHUP /bin/bash --rcfile /etc/profile -c \'sleep 1; {command}\''
        #command = '/bin/bash -l'

        if not self.compatV1:
            # Continue as Normal and use good hosts unshare
            if asRoot:
                chrootCMD = f'/bin/bash -c \'mount -t tmpfs tmpfs {self.getSandboxPath()}/run; '
                chrootCMD = chrootCMD + 'unshare -priUmf --mount --mount-proc -R '
                chrootCMD = chrootCMD + f'{self.getSandboxPath()} --propagation=unchanged '
                chrootCMD = chrootCMD + f'{command};\' exit $?'
            else:
                chrootCMD = f'unshare -piUmf --mount --mount-proc -R {self.getSandboxPath()} '
                chrootCMD = chrootCMD + f'--propagation=unchanged {command}'
        else:
            # Use the older compatibility mode for the sandbox,
            # use chroot and drop the '-R' unshare arg...
            # TBF for HEP it was clear as day AL9 was going to be the way forward,
            # but some people are still on CO8/R8... _sigh_ ...

            # I absolutely could not find a way without unshare -R to drop down to
            # a non-priviledged anon user using chroot...
            # This could simply be me mis-understanding something about sandboxes
            # and their inheritance, or my mistake...
            # Given I don't really _want_ to support running on such an old
            # host I think we can just say for now:

            if not asRoot:
                appLogger.warning('Compatability with older Hosts doesn\'t work,')
                appLogger.warning('if dropping into a \'non-root\' sandbox.')
                appLogger.warning('Running as "root" in sandbox')

            chrootCMD = ' /bin/bash -c '
            chrootCMD +='"export PATH=/bin:/sbin:/usr/sbin:/usr/bin:/usr/local/bin:/usr/local/sbin;'
            chrootCMD += '/bin/mount -t tmpfs tmpfs /run;'
            chrootCMD += f'/bin/mount -t proc proc /proc; sleep 1; chroot {self.getSandboxPath()} '
            chrootCMD += f'{command}"; exit $?'

        return chrootCMD

    def read_from_master(self, process):
        """Read from the master PTY file descriptor and print to stdout."""
        try:
            while True:
                rlist, _, _ = select.select([self.ptyMfd], [], [], 0.1)
                if self.ptyMfd in rlist:
                    data = os.read(self.ptyMfd, 1024)
                    if data:
                        sys.stdout.write(data.decode(errors='replace'))
                        sys.stdout.flush()
                    else:
                        break
                if process.poll() is not None:
                    break
        except OSError:
            pass
        finally:
            if process.poll() is None:
                process.terminate()
            try:
                os.close(self.ptyMfd)
            except OSError:
                pass

    def write_to_master(self, process):
        """Write user input to the master PTY file descriptor."""
        old_settings = termios.tcgetattr(sys.stdin)
        try:
            tty.setraw(sys.stdin)
            while True:
                rlist, _, _ = select.select([sys.stdin], [], [], 0.1)
                if sys.stdin in rlist:
                    user_input = os.read(sys.stdin.fileno(), 1024)
                    if not user_input:
                        break
                    os.write(self.ptyMfd, user_input)
                if process.poll() is not None:
                    break
        except OSError:
            pass
        finally:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
            try:
                os.close(self.ptyMfd)
            except OSError:
                pass

    def handle_sigwinch(self, signum, frame): # pylint: disable=locally-disabled, unused-argument
        """Handle window resize signal and adjust the PTY window size."""
        s = struct.pack('HHHH', 0, 0, 0, 0)
        rows, cols, xpixels, ypixels = struct.unpack('HHHH',
                                                fcntl.ioctl(sys.stdout, termios.TIOCGWINSZ, s))
        fcntl.ioctl(self.ptyMfd, termios.TIOCSWINSZ,
                    struct.pack('HHHH', rows, cols, xpixels, ypixels))

    def spawn_bash_terminal(self, command, asRoot=False):
        """Spawn a bash terminal in a new PTY."""
        # Open a new pseudo-terminal pair
        self.ptyMfd, self.ptySfd = pty.openpty()

        # Set up signal handler for window resize
        signal.signal(signal.SIGWINCH, self.handle_sigwinch)
        try:
            self.handle_sigwinch(None, None)  # Set initial window size
        except OSError as err:
            appLogger.debug('Error: %s', err)

        chrootCMD = self._getSandboxCmd(command, asRoot)

        appLogger.debug('About to execute')
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s ; exit $?;',
                                self.pidChild, chrootCMD)

        procCMD = 'nsenter --preserve-credentials --user --mount --pid -t'
        procCMD = procCMD + f' {self.pidChild} {chrootCMD}; exit $?;'

        # Needed for Ubuntu and Debian related screwiness.
        # EL based distros HAVE NO ISSUE WITH BASH WORKING OUT THAT PID 1 MEANS
        # YOU WILL BE IN CHARGE OF SUBPROCESSES
        # Debian on the other hand is a special snowflake which causes issues
        # Someone is patching code somewhere OOB and it makes me unhappy :(
        procCMD = ['/bin/bash', '-c', procCMD]

        appLogger.debug('Running: %s', procCMD)
        # Start the subprocess with the slave side of the PTY as its stdin, stdout, and stderr
        # pylint: disable=locally-disabled, subprocess-popen-preexec-fn
        interactiveProc = subprocess.Popen(
            procCMD,
            preexec_fn = os.setsid,  # Start a new session
            stdin = self.ptySfd,
            stdout = self.ptySfd,
            stderr = self.ptySfd,
            close_fds=True, universal_newlines=True
        )

        # Close the slave_fd in the parent since it's now handled by the child
        os.close(self.ptySfd)

        # Interact with the master side of the PTY
        try:
            read_thread = threading.Thread(target=self.read_from_master, args=(interactiveProc,))
            read_thread.start()

            write_thread = threading.Thread(target=self.write_to_master, args=(interactiveProc,))
            write_thread.start()

            read_thread.join()
            write_thread.join()
        except OSError:
            pass
        finally:
            try:
                os.close(self.ptyMfd)
            except OSError:
                pass
            interactiveProc.wait()
            # Not 'perfect' to have all of the return from the users code here, but this works well
            return interactiveProc.returncode #pylint: disable=W0134,W0150

    def runCommand(self, command, asRoot=False):
        '''
        Run Said command inside the sandbox env

        This approach has 2 limitations:
        1. No clean/nice way of intercepting PTY resize events
        2. Minor issues with Debian based systems which I don't want to get into
        '''

        chrootCMD = self._getSandboxCmd(command, asRoot)

        appLogger.debug('About to execute')
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s ; exit $?;',
                                self.pidChild, chrootCMD)

        self._wrangleTTY()
        procCMD = 'nsenter --preserve-credentials --user --mount --pid -t'
        procCMD = procCMD + f' {self.pidChild} {chrootCMD}; exit $?;'
        # pylint: disable=locally-disabled, subprocess-popen-preexec-fn
        interactiveProc = subprocess.Popen(
                procCMD,
                stdin = self.stdoutS,
                stdout = self.stdoutS,
                stderr = self.stdoutS,
                shell = True, universal_newlines = True, preexec_fn=os.setsid
                )

        i=0
        timeLimit=100

        while i<= timeLimit:
            time.sleep(0.1)  # Total 10s chance for child to spawn on a healthy system
            i=i+1            # Obviously 10s+work-time, but I'm assuming accessing proc is cheap

            parentID = interactiveProc.pid
            childID = parentID

            try:
                # If the process is unknown or in a zombie state
                if self.procState(interactiveProc.pid) in ['Z', 'E']:
                    break
            except PermissionError as permissionErr:
                appLogger.debug('Error: %s', permissionErr)

            while True:

                appLogger.debug('Parent PID: %s', parentID)
                appLogger.debug('Child PID: %s', childID)
                try:
                    parentID, childID = self.getChildID(childID)
                    #self.pidChild = childID
                except (OSError, ValueError) as pidErr:
                    appLogger.debug('Error: %s', pidErr)
                    break
                time.sleep(0.1)

                appLogger.debug('---')

            if parentID != childID and childID:
                if self.compatV1:
                    self.mountHost(childID)
                break

        if i>timeLimit:
            raise RuntimeError('Failed to spawn child process to launch shell or run command.')

        readable = [sys.stdin, self.stdoutM]
        while True:

            self.running = True
            shouldContinue = self._shellFwdBck(interactiveProc, readable)

            if not shouldContinue:
                break
        self.running=False

        rc = interactiveProc.poll()

        appLogger.debug('Return Code: %s', rc)

        return rc

    def procState(self, pid):
        '''
        Return the state of a given PID in linux
        '''
        # Only on Linux
        for _line in open(f"/proc/{pid}/status", encoding='utf-8').readlines():
            if _line.startswith("State:"):
                entry = _line.split(":")[1].strip()
                value = entry.rstrip()[0]
                return value
        # Unknown
        return 'E'

    def _shellFwdBck(self, interactiveProc, readable):
        '''
        This is the component for handling sending data in/out of the pty
        '''

        try:
            # If the process is unknown or in a zombie state
            if self.procState(interactiveProc.pid) in ['Z', 'E']:
                return False
        except PermissionError as permissionErr:
            appLogger.debug('Error: %s', permissionErr)
            return False

	    # Poll for input/output
        if interactiveProc and interactiveProc.poll() is None:
            r, _w, _e = select.select(readable, [], [], 0.01)

            for _in in r:
                if _in is sys.stdin:
                    d = os.read(sys.stdin.fileno(), 10240)
                    #if d.decode() in ['\x04',]:
                    #    self._should_stop = True
                    #    return False
                    os.write(self.stdoutM, d)
                elif _in is self.stdoutM:
                    try:
                        o = os.read(self.stdoutM, 10240)
                    except OSError as e:
                        appLogger.debug('Error: %s', e)
                        return False
                    if o:
                        os.write(sys.stdout.fileno(), o)
                else:
                    raise RuntimeError('Help')
            return True
        else:
            return False


class appBoxManager:
    '''
    Class for general helper functions
    '''

    def setLogLevel(self, level):
        '''
        Set the log level of the global logger
        '''

        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        if level == logging.DEBUG:
            console_formatter = logging.Formatter(
                "%(asctime)s;%(levelname)s: %(message)s", "%Y-%m-%d %H:%M:%S")
        else:
            console_formatter = logging.Formatter('%(message)s')
        console_handler.setFormatter(console_formatter)
        appLogger.setLevel(level)
        appLogger.addHandler(console_handler)
        for handler in appLogger.handlers:
            handler.setLevel(level)

        # Set up logging with the custom handler
        handler = OneLineProgressHandler(sys.stdout)
        formatter = logging.Formatter('%(message)s')  # Simple message output
        handler.setFormatter(formatter)
        barLogger.setLevel(level)
        barLogger.addHandler(handler)  # Replace default handlers with our custom handler
        for handler in barLogger.handlers:
            handler.setLevel(level)


class cmdLineParser:
    '''
    Class for parsing command line arguments
    '''

    @staticmethod
    def getArgsParser():
        '''
        Parse the Args passed to this instance
        '''

        #class BlankLinesHelpFormatter(argparse.HelpFormatter):
        class blankLinesHelpFormatter(argparse.RawDescriptionHelpFormatter):
            '''
            Class to keep extra lines in help text
            '''
            def _split_lines(self, text, width):
                '''
                Keep the extra lines
                '''
                return super()._split_lines(text, width) + ['']

        un = getUN()
        epilog = f"""
------------------------------------------------------------------------------------------

Example Usage for this might be:
--------------------------------

# Usage 1 (Download, extract, setup then manuall source) #
##########################################################

RH> ./appBox -ii Ubuntu20 -ip /scratch/appBox_{un}/Ubuntu20
RH> source /scratch/appBox_{un}/Ubuntu20/bin/activate
...
Ubuntu>

# Usage 2 (Download, extract, setup and drop me into a root shell) #
####################################################################

RH7> ./appBox -ii docker://almalinux:9 -ip /scratch/appBox_{un}/AL9 -rar
...
RH9# dnf update -y
...

# Usage 3 (Download, ..., then run a command and exit) #
########################################################

RH7> ./appBox -ii Ubuntu22 -ip /scratch/appBox_{un}/Ubuntu22 -q -rcr 'echo /etc/os-release'
PRETTY_NAME="Ubuntu 22.04.4 LTS"
NAME="Ubuntu"
VERSION_ID="22.04"
VERSION="22.04.4 LTS (Jammy Jellyfish)"
VERSION_CODENAME=jammy
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=jammy
RH7> 

------------------------------------------------------------------------------------------

"""


        parser = argparse.ArgumentParser(
                        prog='appBox', formatter_class=blankLinesHelpFormatter,
        description='This is a tool to install a custom container as a sandbox like "virtualenv".',
                        epilog=epilog)

        parser.add_argument('-rc', '--run-command',
                            help='Run a given command inside a sandbox.')

        parser.add_argument('-rp', '--run-path',
        help='Path to look for an installed image (extracted sandbox) to use as a run-environment.')

        parser.add_argument('-rcr', '--run-command-root',
                            help='Run a given command AS ROOT inside a sandbox.')

        if os.path.exists('/scratch'):
            leadingPath = '/scratch'
        else:
            leadingPath = '/tmp'

        defaultRoot = f'{leadingPath}/appBox_{getUN()}/sandbox'

        #default_image = 'almalinux:9'
        defaultImage = 'centos:7'

        parser.add_argument('-ii', '--install-image',
                            default=defaultImage,
                help=f'Image to install, or short-hand of image from "{sys.argv[0]} -li"')

        parser.add_argument('-ip', '--install-path',
                            default=defaultRoot,
        help='Install path, path to "install" an image to on disk. (Path to extract to on disk)')

        parser.add_argument('-ra', '--run-after', action='store_true',
                            help='Should we drop into the new sandbox after installing.')

        parser.add_argument('-rar', '--run-after-root', action='store_true',
                            help='Should we drop into the new sandbox AS ROOT after installing.')


        parser.add_argument('-q', '--quiet', action='store_true',
                            help='Quiet')

        parser.add_argument('-d', '--debug', action='store_true',
                            help='Debugging on.')

        parser.add_argument('-l', '--launch',
                            help='Launch Interactive environment from ...')

        parser.add_argument('-lr', '--launch-root',
                            help='Launch Interactive environment AS ROOT, from ...')

        parser.add_argument('-compat', '--compatV1', action='store_true',
            help='Use the older compatibility mode for the sandbox. Allows a CO8 host.')

        parser.add_argument('-rmNV', '--remove-nvidia', action='store_true',
                            help='Remove the nvidia-smi binary to the sandbox.')

        parser.add_argument('-tmp', action='store_true',
                            help='The environment will be destroyed on exit. (Temporary Sandbox)')

        parser.add_argument('-online', action='store_true',
                            help='Always try to get the latest online version of an image.')

        parser.add_argument('-layerCache',
                            help='Path to a directory to store the image layers for future use.')

        # Disabling the cvmfs tooling for now as it's not production ready/tested yet.
        #parser.add_argument('-cvmfs', '--use-cvmfs',
        #                    help='Use uncompressed image from this CVMFS path.')

        return parser


def runCommand(iManager, sandboxPath, command, asRoot,
               compatV1=False, addNV=False, rootfs=None, runCMD=True):
    '''
    Run a command within a sandbox
    '''

    appLogger.debug('RunCommand: %s, %s, %s, %s', compatV1, addNV, rootfs, runCMD)

    try:
        thisSandbox = sessionManager(sandboxPath, compatV1, addNV, rootfs)
        thisSandbox.setupHostSpace()

        if rootfs:
            thisSandbox.mountrootfs(rootfs)
            #time.sleep(1.0)

        thisSandbox.mountHost()

        theseFixes = sandboxFixes(addNV, thisSandbox, iManager)
        theseFixes.applyAllFixes()

        if runCMD:
            rc = thisSandbox.spawn_bash_terminal(command, asRoot)
        else:
            rc = 0

        return rc

    except BaseException as globalErr: # pylint: disable=broad-except
        appLogger.error('Exception during running appBox Shell: %s', globalErr)
        thisSandbox.cleanupSpaces()
        if appLogger.level == logging.DEBUG:
            raise
        sys.exit(131)
    finally:
        thisSandbox.cleanupSpaces()


def main():
    '''
    Main :) Hello
    '''

    ### Parse our args and steer
    parser = cmdLineParser.getArgsParser()
    parsedArgs = parser.parse_args(sys.argv[1:])

    if parsedArgs.quiet:
        appBoxManager().setLogLevel(logging.ERROR)
    elif parsedArgs.debug:
        appBoxManager().setLogLevel(logging.DEBUG)
    else:
        appBoxManager().setLogLevel(logging.INFO)

    appLogger.debug('')
    appLogger.debug('Debugging Enabled. Jolan tru.')
    appLogger.debug('')


    commandToRun = None
    asRoot = False
    compatV1 = False
    wantedDest = None
    shouldRun = False
    needToInstall = False
    addNV = not parsedArgs.remove_nvidia
    appLogger.debug('Add NV: %s', addNV)

    forceUpdate = parsedArgs.online
    layerCache = parsedArgs.layerCache
    if layerCache:
        layerCache = os.path.abspath(layerCache)
    else:
        layerCache = None

    lowerLayer = None

    if parsedArgs.compatV1:
        compatV1 = True

    wantedImage = parsedArgs.install_image
    if parsedArgs.install_path:
        wantedDest = os.path.abspath(parsedArgs.install_path)
        needToInstall = True

    if parsedArgs.run_command:
        commandToRun = parsedArgs.run_command
        shouldRun = True
    if parsedArgs.run_command_root:
        commandToRun = parsedArgs.run_command_root
        asRoot = True
        shouldRun = True

    if parsedArgs.launch:
        wantedDest = parsedArgs.launch
        shouldRun = True
        wantedImage = None
    if parsedArgs.launch_root:
        wantedDest = parsedArgs.launch_root
        asRoot = True
        shouldRun = True
        wantedImage = None

    if parsedArgs.run_after:
        shouldRun = True
    if parsedArgs.run_after_root:
        asRoot = True
        shouldRun = True

    # TODO fix cvmfs fusermount alternative approach
    #if parsedArgs.use_cvmfs:
    #    lowerLayer = parsedArgs.use_cvmfs
    #    shouldRun = True
    #    #cvmfs_sandbox(parsedArgs.use_cvmfs, wantedDest, None, True)
    #    #sys.exit(-200)


    def platformDetection():
        platStr = platform.platform()
        detected = False
        for _str in ['centos-7', '3.10.', '4.18.0', ]:
            if _str in platStr:
                detected = True
                break
        return detected

    if platformDetection() and not compatV1:
        appLogger.warning('Detected older platform than EL9/UB22 defaulting to compatability mode.')
        appLogger.warning('You won\'t be able to use anonymous user-mapping for this session.')
        appLogger.warning('To disable this warning, use the -compat cmd arg.')
        compatV1 = True


    wantedDest = os.path.abspath(wantedDest)

    appLogger.debug('Looking in path: "%s"', wantedDest)

    if parsedArgs.run_path:
        wantedDest = parsedArgs.run_path
        shouldRun = True

    if not os.path.exists(wantedDest):
        appLogger.info('Sandbox: "%s" does not exist.', wantedDest)
        if not lowerLayer:
            if wantedImage is None:
                appLogger.error('Please install before trying to launch a sandbox.')
                sys.exit(132)
            appLogger.info('Installing: "%s" at "%s"', wantedImage, wantedDest)
            needToInstall = True
        else:
            appLogger.info('Using CVMFS: "%s"', lowerLayer)
            needToInstall = False


    rc = 0
    if needToInstall and not lowerLayer and wantedImage:

        ## TODO
        ## Add some way of handling images from other sources
        ## This should identify docker images from docker://
        ## This will probably involve adding additional classes for Quay, Singularity, etc.
        ## Can safely default to assume most users just want a docker image


        imageLower = wantedImage.lower()
        if wantedImage != imageLower:
            appLogger.debug('Changing search string to be lower-case! %s', imageLower)
            wantedImage = imageLower

        # Construct Manager
        iManager = imageManager(wantedImage, wantedDest, layerCache, forceUpdate)

        appLogger.debug('Looking for image: "%s"', wantedImage)

        # Extract the image to the destination path
        try:
            if os.path.exists(wantedDest):
                appLogger.info('Path: "%s" already exists. Assuming it\'s a sandbox.', wantedDest)
                rc = 0
            else:
                rc = iManager.extractImage()
            if rc != 0:
                return rc
            runCMD=False
            rc = runCommand(iManager, wantedDest, commandToRun, asRoot, compatV1,
                            addNV, lowerLayer, runCMD)
            if rc != 0:
                return rc

        except PermissionError as permissionErr:
            appLogger.error('Permission Denied.')
            appLogger.error('Normally this means we don\'t have write access to: "%s"', wantedDest)
            appLogger.debug('Permission Error: %s', permissionErr)
            if appLogger.level == logging.DEBUG:
                raise permissionErr
            sys.exit(133)

    if shouldRun:

        try:
            with open(os.path.join(wantedDest, '.appBox'), 'r', encoding='utf-8') as _file:
                _content = _file.read()
        except FileNotFoundError as fileErr:
            _ = fileErr
            appLogger.error('Path: "%s" is not a valid appBox sandbox.', wantedDest)
            sys.exit(142)

        imageData = json.loads(_content)
        appLogger.debug('Sandbox Data: %s', imageData)

        iManager = imageManager(imageData['image'], wantedDest, layerCache, forceUpdate)

        # We now plan to run a command or launch a shell
        rc = runCommand(iManager, wantedDest, commandToRun, asRoot, compatV1,
                        addNV, lowerLayer)
        if parsedArgs.tmp:
            shutil.rmtree(wantedDest)
        return rc

    return 0


if __name__ == '__main__':
    try:
        RC = main()
    except KeyboardInterrupt as keyboardErr:
        if appLogger:
            appLogger.error('Aborting due to user request.')
            if appLogger.level == logging.DEBUG:
                print(keyboardErr)
        else:
            print('Aborting due to user request.')
        sys.exit(129)
    except BaseException as mainErr: # pylint: disable=broad-except
        if appLogger:
            appLogger.error('Exception: %s', mainErr)
            if appLogger.level == logging.DEBUG:
                raise
        else:
            print('Exception: %s', mainErr)
        sys.exit(130)
    sys.exit(RC)
