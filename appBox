#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import fcntl
import json
import logging
import os
import pprint
import pty
import pwd
import select
import signal
import stat
import struct
import subprocess
import sys
import termios
import threading
import time
import tty

# Global Logger
appLogger = None

# ENV var for loading settings from JSON file
APPBOX_ENV = 'APPBOX_SETTINGS'

def getUN():
    '''
    Return the username of this account
    '''
    return pwd.getpwuid(os.getuid())[0]


class SettingsManager():
    ''' This is a class for grouping the tools related to the settings of appBox '''

    settings = None

    def get_default_bind_mounts():
        '''
        Return a list of mounts on this system which we can/should bind-mount from host to sandbox
        '''
        bind_mount_paths = ['/cvmfs','/scratch', '/localdisk', '/Data', '/mnt', '/exports']

        found_paths = []

        for subpath in bind_mount_paths:
            if not os.path.exists(subpath):
                if appLogger:
                    appLogger.debug('PATH: {} not found so won\'t attempt to mount into contaier.'.format(subpath))
                continue

            found_paths.append(subpath)

        return found_paths

    def load_env_settings():
        '''
        This is a method for loading the appBox settings from an (optional) on-disk JSON
        '''
        appbox_env_file = os.environ.get(APPBOX_ENV, '')

        if appbox_env_file:
            if os.path.exits(appbox_env_file):
                with open(appbox_env_file, 'r') as _settings:
                    return json.load(_settings)
        return {}

    def set_setting(setting, value):
        '''
        A short method for allowing externally setting/modifying a setting in code
        '''
        _ = SettingsManager.get_settings()

        SettingsManager.settings[setting] = value

    def get_settings():
        '''
        Return the settings as a JSON object
        '''

        if SettingsManager.settings:       
            return SettingsManager.settings

        _settings = {
             'apptainer_cmd': SettingsManager.get_singularity_cmd(),
             'bind_mount_paths': SettingsManager.get_default_bind_mounts(),
             'copy_from_host': ['LC_ALL', 'LANG', 'LANGUAGE', 'PS1'],
             'default_fuse_lib_preload': SettingsManager.get_cvmfs_fuse(),
             'default_image_wrk_path': SettingsManager.get_default_scratch(),
             'default_img': 'docker://centos:centos7',
             'default_mappings': {
                                   'CO6':      'docker://centos:centos6',
                                   'CO7':      'docker://centos:centos7',
                                   'SL7':      'docker://centos:centos7',
                                   'EL7':      'docker://centos:centos7',
                                   'CO8':      'docker://almalinux:8',
                                   'EL8':      'docker://almalinux:8',
                                   'Alma8':    'docker://almalinux:8',
                                   'EL9':      'docker://almalinux:9',
                                   'Alma9':    'docker://almalinux:9',
                                   'Rocky8':   'docker://rockylinux:8',
                                   'Rocky9':   'docker://rockylinux:9',
                                   'Ubuntu':   'docker://ubuntu:22.04',
                                   'Ubuntu22': 'docker://ubuntu:22.04',
                                   'Ubuntu20': 'docker://ubuntu:20.04',
                                   'TF216':    'docker://tensorflow/tensorflow:2.16.1-gpu-jupyter',
                                   'TF215':    'docker://tensorflow/tensorflow:2.15.0-gpu-jupyter',
                                   'TF214':    'docker://tensorflow/tensorflow:2.14.0-gpu-jupyter',
                                   'PyTorch22CUDA12': 'docker://pytorch/pytorch:2.2.2-cuda12.1-cudnn8-runtime',
                                   'PyTorch22CUDA11': 'docker://pytorch/pytorch:2.2.2-cuda11.8-cudnn8-runtime',
                                   'PyTorch21CUDA12': 'docker://pytorch/pytorch:2.1.2-cuda12.1-cudnn8-runtime',
                                   'PyTorch21CUDA11': 'docker://pytorch/pytorch:2.2.2-cuda11.8-cudnn8-runtime',
                                 },
             'default_sandbox_path': os.path.join(SettingsManager.get_default_scratch(), 'appBox'),
             'exec_as_root_by_default': False,
             'interactive_command': ['/bin/bash', '-i'],
             'timeout': 0.05,
            }

        json_settings = SettingsManager.load_env_settings()

        for k, v in _settings.items():
            if k in json_settings.keys():
                _settings[k] = json_settings[k]

        SettingsManager.settings = _settings

        return SettingsManager.settings

    def get_default_scratch():
        '''
        Get the default path for some apptainer temp folders
        '''
        if os.path.exists('/scratch'):
            default_scratch_path = os.path.join('/scratch', 'appBox_'+str(getUN()))
        else:
            default_scratch_path = os.path.join('/tmp', 'appBox_'+str(getUN()))
        return default_scratch_path

    def get_cvmfs_fuse():
        '''
        Get the fuse library from cvmfs to resolve fuse symbols
        (this is to satisfy resolving symbols on systems which don't have all userland fuse installed)
        '''

        if os.path.exists('/usr/lib/libcvmfs_fuse.so'):
            return 'export LD_PRELOAD="/usr/lib/libcvmfs_fuse.so"'
        elif os.path.exists('/usr/lib64/libcvmfs_fuse.so'):
            return 'export LD_PRELOAD="/usr/lib64/libcvmfs_fuse.so"'
        else:
            return ''

    def get_singularity_cmd(s_path=None, s_cmd=None):
        '''
        Return the path for singularity tool
        '''

        if not s_path:
            cvmfs_path = '/cvmfs/atlas.cern.ch/repo/containers/sw/apptainer/x86_64-el8/current/bin/'
            if os.path.exists(cvmfs_path):
                path = cvmfs_path
            else:
                path = '/usr/bin'
        else:
            path = s_path
        if not s_cmd:
            cmd = 'apptainer'
        else:
            cmd = s_cmd

        return os.path.join(path, cmd)

    def load_settings(settings_path):
        '''
        Need to build some way of loading the settings
        '''
        pass

    def save_settings(settings_path):
        '''
        Need to build some way of saving the settings
        '''
        pass

    cmd_env = {}

    def get_bind_paths():
        '''
        Get paths which are to be bind mounted from host to sandbox
        '''

        path_str = ''
        for subpath in SettingsManager.get_settings()['bind_mount_paths']:
            path_str+=subpath+':'+subpath+','

        return path_str

    def get_app_env():
        '''
        Get the environment variables which need to be set for the apptainer sandbox
        '''

        CMD_ENV = SettingsManager.cmd_env

        if len(CMD_ENV.keys())==0:

            CMD_ENV['SCRATCH_ROOT']=SettingsManager.get_settings()['default_image_wrk_path']
            CMD_ENV['APPTAINER_BIND']=SettingsManager.get_bind_paths()
            for app_env in ['', 'APPTAINERENV_', 'APPTAINERENV_APPTAINERENV_']:
                for wrk_folder in [('TMPDIR', 'TMP'), ('CACHEDIR', 'CACHE'), ('PULLFOLDER', 'PULL')]:
                    CMD_ENV[app_env + 'APPTAINER_' + wrk_folder[0]]=os.path.join(CMD_ENV['SCRATCH_ROOT'],wrk_folder[1])
                CMD_ENV[app_env + 'BIND']=SettingsManager.get_bind_paths()

            for host_env_var in SettingsManager.get_settings()['copy_from_host']:
                host_env = os.environ
                if host_env_var in host_env:
                    for app_env in ['', 'APPTAINERENV_', 'APPTAINERENV_APPTAINERENV_']:
                        CMD_ENV[app_env + host_env_var] = host_env[host_env_var]
                else:
                    appLogger.debug('Ignoring env var "{}" as not found on "host"'.format(host_env_var))

        return CMD_ENV

    def get_app_scriptEnv():
        '''
        Get the env vars for apptainer in a bash-script format
        '''

        script_env = ''
        app_env = SettingsManager.get_app_env()

        for k,v in app_env.items():
            script_env+='export {}="{}"\n'.format(k,v)

        return script_env

    def get_app_pythonEnv():
        '''
        Get the env vars for apptainer in a python dict format
        '''
        return SettingsManager.get_app_env()

    def get_this_image(img_str):
        '''
        See if the provided image 'name' is a short-hand alias
        '''
        img_map = SettingsManager.get_settings()['default_mappings']
        return img_map.get(img_str, img_str)


class NonSubShell():

    def run_command(this_cmd):
        '''
        Just a small wrapper to execute Popen and to stream the output in real time
        '''

        full_cmd = ['bash', '-c', this_cmd]

        with subprocess.Popen(full_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) as process:
            for line in process.stdout:
                appLogger.error(line.decode('utf8').rstrip())

        return process.returncode


class NormalSubShell():
    '''
    This class provides some tooling for setting up a pty to execute commands in
    '''

    def __init__(self, quiet, exit_rc=True):
        '''
        This is boiler-plate
        '''
        self.p = None        
        self.quiet = quiet
        self._should_stop = False
        self.running = False

    def _wrangle_tty(self):
        '''
        This is some boiler-plate for setting up a pTTY
        '''

        # save original tty setting then set it to raw mode
        old_i_tty = termios.tcgetattr(sys.stdin)
        tty.setraw(sys.stdin.fileno())

        # open pseudo-terminal to interact with subprocess
        stdout_m_fd, stdout_s_fd = pty.openpty()

        size = os.get_terminal_size()
        winsize = struct.pack("HHHH", size[1], size[0], 0, 0)
        fcntl.ioctl(stdout_m_fd, termios.TIOCSWINSZ, winsize)

        #print('Opening PTY')

        self.old_i_tty = old_i_tty
        self.stdout_m, self.stdout_s = stdout_m_fd, stdout_s_fd

    def _launch_shell(self):
        '''
        Launch the shell which we're going to execute some commands in
        '''

        # use os.setsid() make it run in a new process group, or bash job control will not be enabled
        self.p = subprocess.Popen(SettingsManager.get_settings()['interactive_command'],
                      preexec_fn=os.setsid,
                      stdin=self.stdout_s,
                      stdout=self.stdout_s,
                      stderr=self.stdout_s,
                      universal_newlines=True)

        for s in [self.stdout_s,]:
            os.close(s)

    def run_queue(self, queued_cmds, ignore_history=True):
        '''
        Run a set of commands within a pty
        '''

        self._wrangle_tty()
        self._launch_shell()

        readable = [self.stdout_m, ]

        full_cmd = ''

        if type(queued_cmds) is str:
            queued_cmds = [queued_cmds,]
        for cmd in queued_cmds:

            if type(cmd) is not str:
                _cmd = cmd.decode()
            else:
                _cmd = cmd

            if _cmd[-1] in ['\n',]:
                _cmd = _cmd[:-1]

            if len(full_cmd)!=0:
                full_cmd+= ' && '
            full_cmd += _cmd

        full_cmd = full_cmd.replace('\n', ' && ')

        if ignore_history and self.quiet:
            full_cmd = 'set +o history; unset HISTFILE; ' + full_cmd

        full_cmd += ' ; exit $? 2> /dev/null\n'

        os.write(self.stdout_m, full_cmd.encode())

        while True:

            self.running = True
            should_continue = self._shell_fwd_bck(readable)

            if not should_continue:
                break

        self._cleanup()

    def _shell_fwd_bck(self, readable):
        '''
        This is the component for handling sending data in/out of the pty
        '''

        if self.p and self.p.poll() is None:

            r, w, e = select.select(readable, [], [], SettingsManager.get_settings()['timeout'])

            for _in in r:
                if _in is sys.stdin:
                    d = os.read(sys.stdin.fileno(), 10240)
                    if d.decode() in ['\x04',]:
                        self._should_stop = True
                        return False
                    os.write(self.stdout_m, d)
                elif _in is self.stdout_m:
                    try:
                        o = os.read(self.stdout_m, 10240)
                    except OSError as e:
                        return False
                    if o and not self.quiet:
                        os.write(sys.stdout.fileno(), o)
                else:
                    raise Exception('Help')
            return True
        else:

            return False
            
    def _cleanup(self):
        '''
        Some boiler-plate to cleanup after a shell has finished being used
        '''

        self.running = False

        # restore tty settings back
        termios.tcdrain(sys.stdin)
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.old_i_tty)
        #sys.stdin.flush()
        os.close(self.stdout_m)
        self.p = None
        self.old_i_tty = None
        self.stdout_m = None
        self.stdout_s = None
        sys.stdout.flush()


class InteractiveShell(threading.Thread, NormalSubShell):
    '''
    This class can launch a fully interactive shell within our instance
    '''

    def __init__(self):
        '''
        Setting up the requirements
        '''
        threading.Thread.__init__(self)
        NormalSubShell.__init__(self, False)

        self._wrangle_tty()
        self._launch_shell()

    def run(self):
        '''
        Start running the shell
        '''
        self.launch_interactive()

    def stop(self):
        '''
        Should we try to externally stop this pty
        '''
        self._should_stop = True

    def launch_interactive(self):
        '''
        Actual code for launching our interactive shell
        '''

        if not self.p:
            self._wrangle_tty()
            self._launch_shell()
            self._should_stop = False

        try:
            readable = [sys.stdin, self.stdout_m]

            self.running = True

            while True:

                should_continue = self._shell_fwd_bck(readable)

                if not should_continue:
                    self.p.kill()
                    self.p.terminate()
                    break

                if self._should_stop:
                    os.write(self.stdin_m, str('exit').encode())
                    self.p.kill()
                    self.p.terminate()
                    break

        finally:
            self.running = False
            self._cleanup()


class RunCommand():
    '''

    '''

    def runCommand(thisCmd):
        '''
        This is a small wrapper for just running a command
        '''

        if type(thisCmd) is list:
            _cmd = ' '.merge(thisCmd)
        else:
            _cmd = thisCmd

        _cmd = _cmd + " ; exit $?"
        full_cmd = ['bash', '-c', "{}".format(_cmd)]

        try:
            result = subprocess.run(full_cmd, stdout = subprocess.PIPE,
                                              stderr = subprocess.DEVNULL)

            stdout = result.stdout.decode()
            returncode = result.returncode
        except:
            stdout = ''
            returncode = -99

        return stdout, returncode


class SandboxInstaller():
            
    def loadSingularityJSON(install_path):

        json_path = os.path.join(install_path, '.singularity.d/labels.json')

        with open(json_path, 'r') as _jsonfile:

            json_data = json.load(_jsonfile)

        return json_data

    def build_launch_script(install_path, as_root):

        activate_script = '#!/bin/bash\n'

        for subpath in SettingsManager.get_settings()['bind_mount_paths']:
            local_path= subpath
            activate_script += 'mkdir -p ' + os.path.abspath(os.path.join(install_path, '.'+subpath)) + '\n'

        activate_script += '\n'

        activate_script += SettingsManager.get_app_scriptEnv()

        activate_script += '\n'
        activate_script += 'unset LD_PRELOAD\n'
        activate_script += '\n'

        activate_script += 'function arg_merge() {\n'
        activate_script += '  delim=";"      # join delimiter\n'
        activate_script += '  oldIFS=$IFS   # save IFS, the field separator\n'
        activate_script += '  IFS=$delim\n'
        activate_script += '  result="$*"\n'
        activate_script += '  IFS=$oldIFS   # restore IFS\n'
        activate_script += '  echo $result\n'
        activate_script += '}\n\n'

        if as_root:
            apptainer_shell_cmd = SettingsManager.get_settings()['apptainer_cmd'] + ' exec --no-mount hostfs -w -f '+install_path+' /bin/bash -l'
        else:
            apptainer_shell_cmd = SettingsManager.get_settings()['apptainer_cmd'] + ' exec --no-mount hostfs -w '+install_path+' /bin/bash -l'

        which_cmd  = "if [[ $# -eq 0 ]]; then\n"
        which_cmd += apptainer_shell_cmd + '\n'
        which_cmd += "else\n"
        which_cmd += 'argz=$(arg_merge "$@")\n'
        which_cmd += apptainer_shell_cmd + ' -c "$argz";\n'
        which_cmd += 'fi\n'

        activate_script += which_cmd

        return activate_script

    def build_activate_scripts(install_path):

        bin_dir = os.path.join(install_path, 'bin')

        def _build_script(as_root=False):

            if as_root:
                script_name = 'activate-asroot'
            else:
                script_name = 'activate'
            activate_script_path = os.path.join(bin_dir, script_name)


            if not os.path.exists(activate_script_path):

                if not os.path.exists(bin_dir):
                    os.makedirs(bin_dir)
                with open(activate_script_path, 'w') as _file:
                    _file.write(SandboxInstaller.build_launch_script(install_path, as_root))

        _build_script(as_root=False)
        _build_script(as_root=True)

    def build_singularity_env(root=None):

        if not root:
            root = os.path.dirname(SettingsManager.get_settings()['default_sandbox_path'])

        if not os.path.exists(root):
            os.makedirs(root)

        image_wrk_path = SettingsManager.get_settings()['default_image_wrk_path']

        for i in ['TMP','CACHE','PULL']:
            wrk_path = os.path.join(image_wrk_path, i)
            if not os.path.exists(wrk_path):
                os.makedirs(wrk_path)

    def checkImgStorage(install_image):

        #docker inspect -f "{{ .Size }}" 

        install_image_ver = install_image.split(':')[-1]
        try:
            install_image_name = install_image.split(':')[-2][2:]
        except:
            logger.error('Image Name malformed')
            sys.exit(11)

        try:
            img_url = "https://hub.docker.com/v2/repositories/{}/tags/{}".format(install_image_name, install_image_ver)
            appLogger.debug('Checking URL: {}'.format(img_url))
            image_size, rc = RunCommand.runCommand("curl -s {} | jq '.full_size'".format(img_url))
            if rc != 0:
                img_url = "https://hub.docker.com/v2/repositories/library/{}/tags/{}".format(install_image_name, install_image_ver)
                appLogger.debug('Checking URL: {}'.format(img_url))
                image_size, rc = RunCommand.runCommand("curl -s {} | jq '.full_size'".format(img_url))

            image_size = int(image_size.strip())
        except:
            image_size = -1

        appLogger.debug('Image size: {} bytes'.format(image_size))

        total_free_space = 0

        for i in ['TMP','CACHE','PULL']:

            subpath = os.path.join(SettingsManager.get_app_env()['SCRATCH_ROOT'], i)

            partition_data = os.statvfs(subpath)
            free_space = partition_data.f_bavail * partition_data.f_frsize

            appLogger.debug('Looking at Path: {}'.format(subpath))
            appLogger.debug('Found Free Space: {} bytes'.format(free_space))

            total_free_space = total_free_space + free_space

        if image_size>0 and total_free_space<(image_size*3):

            appLogger.error('Insufficient Space to extract image: {}'.format(install_image))
            raise Exception('Not Enough space to downlaod and extract image')
        
        appLogger.debug('Space < 3 * ImageSize')

        return (image_size, total_free_space)


    def checkPathCapacity(install_path, image_size):

        partition_data = os.statvfs(install_path)

        free_space = partition_data.f_bavail * partition_data.f_frsize

        appLogger.debug('Free Space found: {} bytes'.format(free_space))
        appLogger.debug('Free Space needed: {} bytes'.format(image_size))

        if free_space < (image_size + 10*1024*1024):

            appLogger.error('Not enough space to install.')
            raise Exception('Not enough space at: "{}" to extract image for "installation".'.format(install_path))


    def pullImage(install_image, debug):

        image_size, total_free_space = SandboxInstaller.checkImgStorage(install_image)

        appLogger.info('Pulling Image: "{}"'.format(install_image))

        shell = NormalSubShell(quiet=not debug)

        apptainer = SettingsManager.get_settings()['apptainer_cmd']

        cmd_queue = [SettingsManager.get_app_scriptEnv(), ]
        cmd_queue += [SettingsManager.get_settings()['default_fuse_lib_preload'], ]
        cmd_queue += [apptainer + ' pull "'+install_image+'"', ]
        cmd_queue += ['unset LD_PRELOAD', ]

        shell.run_queue(cmd_queue)

        del shell

        return image_size


    def buildSandbox(install_path, install_image, image_size, debug):

        SandboxInstaller.checkPathCapacity(install_path, image_size)

        appLogger.info('Building Sandbox at: "{}"'.format(install_path))

        shell = NormalSubShell(quiet=not debug)

        apptainer = SettingsManager.get_settings()['apptainer_cmd']

        cmd_queue  = [SettingsManager.get_app_scriptEnv(), ]
        cmd_queue += [SettingsManager.get_settings()['default_fuse_lib_preload'], ]
        cmd_queue += [apptainer + ' build --force --fix-perms --sandbox --fakeroot "'+install_path+'"  "'+install_image+'"', ]
        cmd_queue += ['unset LD_PRELOAD', ]

        shell.run_queue(cmd_queue)

        del shell

    def fixAPTSandbox(install_path):

        app_conf_path = os.path.join(install_path, './etc/apt/apt.conf.d/')

        if os.path.exists(app_conf_path):

            fix_apt  = 'APT::Sandbox::User "root";\nAPT::Sandbox::Verify "0";\n'
            fix_apt += 'APT::Sandbox::Verify::IDs "0";\nAPT::Sandbox::Verify::Groups "0";\n'
            fix_apt += 'APT::Sandbox::Verify::Regain "0";'

            with open(os.path.join(app_conf_path, 'sandbox-disable'), 'w+') as _file:
                _file.write(fix_apt)


    def fixCommands(install_path):

        def fixDeactivate():
            deac_script = os.path.join(install_path, 'etc/profile.d/deac.sh')
            with open(deac_script, 'w+') as _file:
                _file.write('alias deactivate=exit')

            st = os.stat(deac_script)
            os.chmod(deac_script, st.st_mode | stat.S_IEXEC)

        def fixSUDO():
            sudo_script = os.path.join(install_path, 'etc/profile.d/sudo.sh')
            with open(sudo_script, 'w+') as _file:
                _file.write('alias sudo="source '+os.path.join(install_path, 'bin/activate-asroot')+'"')
            st = os.stat(sudo_script)
            os.chmod(sudo_script, st.st_mode | stat.S_IEXEC)

        fixDeactivate()
        fixSUDO()


    def fixPaths(install_path):

        for _folder in SettingsManager.get_settings()['bind_mount_paths']:

            _folder = './'+_folder

            bind_folder = os.path.join(install_path, _folder)

            if not os.path.exists(bind_folder):
                os.makedirs(bind_folder)

        for _file in ['etc/hosts', 'etc/localtime', 'etc/resolv.conf', 'etc/passwd', 'etc/group']:
            touch_file = os.path.join(install_path, _file)
            if not os.path.exists(touch_file):
                with open(touch_file, 'a'):
                    os.utime(touch_file, None)
        for _folder in ['dev', 'proc', 'sys', 'tmp', 'var/tmp']:
            folder_path = os.path.join(install_path, _folder)
            if not os.path.exists(folder_path):
                os.makedirs(folder_path)

    def fixupSandbox(install_path):

        appLogger.info('Fixing Sandbox: "{}"'.format(install_path))

        SandboxInstaller.fixPaths(install_path)

        SandboxInstaller.build_activate_scripts(install_path)

        SandboxInstaller.fixAPTSandbox(install_path)

        SandboxInstaller.fixCommands(install_path)


class appBoxManager():

    def create_new_appenv(install_path, install_image, debug):

        if os.path.exists(install_path):
            appLogger.debug('Found Container at "{}", skipping install.'.format(install_path))
            try:
                json_data = SandboxInstaller.loadSingularityJSON(install_path)
                container_label = json_data['org.label-schema.usage.singularity.deffile.bootstrap']+'://'+json_data['org.label-schema.usage.singularity.deffile.from']
                appLogger.info('Image {}, found in container {}'.format(container_label, install_path))
            except:
                appLogger.error('Container at: "{}" malformed'.format(install_path))
                sys.exit(10)
            return

        appLogger.info('appBox Apptainer Sandbox Installer')

        # Needed for CACHE/TMP folders
        SandboxInstaller.build_singularity_env(install_path)

        def get_mount_path(path):
            path = os.path.abspath(path)
            while not os.path.ismount(path):
                path = os.path.dirname(path)
            return path

        install_mount = get_mount_path(install_path)

        if install_mount != '/':
            bind_paths = SettingsManager.get_settings()['bind_mount_paths']
            SettingsManager.set_setting('bind_mount_paths', bind_paths + [install_mount, ])

        image_size = SandboxInstaller.pullImage(install_image, debug)

        SandboxInstaller.buildSandbox(install_path, install_image, image_size, debug)

        SandboxInstaller.fixupSandbox(install_path)

        appLogger.info('Installed')

    def build_env_script():

        return SettingsManager.get_app_scriptEnv()

    def header():

        appLogger.info('                                                            ')
        appLogger.info('░░      ░░░       ░░░       ░░░       ░░░░      ░░░  ░░░░  ░')
        appLogger.info('▒  ▒▒▒▒  ▒▒  ▒▒▒▒  ▒▒  ▒▒▒▒  ▒▒  ▒▒▒▒  ▒▒  ▒▒▒▒  ▒▒▒  ▒▒  ▒▒')
        appLogger.info('▓  ▓▓▓▓  ▓▓       ▓▓▓       ▓▓▓       ▓▓▓  ▓▓▓▓  ▓▓▓▓    ▓▓▓')
        appLogger.info('█        ██  ████████  ████████  ████  ██  ████  ███  ██  ██')
        appLogger.info('█  ████  ██  ████████  ████████       ████      ███  ████  █')
        appLogger.info('████████████████████████████████████████████████████████████')
        appLogger.info('')

    def start_interactive(custom_cmd=None):

        m=InteractiveShell()

        if custom_cmd:
            if type(custom_cmd) is str:
                _cmd = custom_cmd.encode()
            else:
                _cmd = custom_cmd
            os.write(m.stdout_m, _cmd)

        m.start()
        while m.p is not None and m.p.poll() is None:
            time.sleep(0.05)
        m.stop()
        m.join()
        os.write(sys.stdout.fileno(), '\n'.encode())


    def getArgsParser():

        class BlankLinesHelpFormatter(argparse.HelpFormatter):
            def _split_lines(self, text, width):
                return super()._split_lines(text, width) + ['']

        parser = argparse.ArgumentParser(
                        prog='appBox', formatter_class=BlankLinesHelpFormatter,
                        description='This is a short tool to allow you to install a custom image like a "virtualenv".')

        default_root = SettingsManager.get_settings()['default_sandbox_path']

        parser.add_argument('-rc', '--run-command',
                            help='Run a given command inside a sandbox.')

        parser.add_argument('-rp', '--run-path',
                            help='Path to look for an installed image (extracted sandbox) to use as a run-environment.')

        parser.add_argument('-rcr', '--run-command-root',
                            help='Run a given command AS ROOT inside a sandbox.')

        parser.add_argument('-ri', '--run-interactive',
                            type=str, default=default_root,
                            help='Launch a sandbox shell from this location.')

        parser.add_argument('-rir', '--run-interactive-root',
                            type=str, default=default_root,
                            help='Launch a sandbox shell AS ROOT from this location.')

        default_image = SettingsManager.get_settings()['default_img']

        parser.add_argument('-ii', '--install-image',
                            default=default_image,
                            help='Image to install, or short-hand of image from "{} -li"'.format(sys.argv[0]))

        parser.add_argument('-ip', '--install-path',
                            default=default_root,
                            help='Install path, path to "install" an image to on disk. (The path that an image extracted to on disk)')

        parser.add_argument('-ra', '--run-after', action='store_true',
                            help='Should we drop into the new sandbox after installing.')

        parser.add_argument('-rar', '--run-after-root', action='store_true',
                            help='Should we drop into the new sandbox AS ROOT after installing.')

        parser.add_argument('-li', '--list-images', action='store_true',
                            help='List suggested images to "install".')

        parser.add_argument('-q', '--quiet', action='store_true',
                            help='Quiet')

        parser.add_argument('-d', '--debug', action='store_true',
                            help='Debugging on.')

        parser.add_argument('-ds', '--dump-settings', action='store_true',
                            help='Dump settings used by this instance.')

        parser.add_argument('-l', '--launch',
                            help='Launch Interactive environment from ...')

        parser.add_argument('-lr', '--launch-root',
                            help='Launch Interactive environment AS ROOT, from ...')

        return parser


if __name__ == '__main__':

    parser = appBoxManager.getArgsParser()

    parsed_args = parser.parse_args(sys.argv[1:])

    if parsed_args.list_images:
        pprint.pprint(SettingsManager.get_settings()['default_mappings'])
        sys.exit(0)

    if parsed_args.dump_settings:

        all_settings = SettingsManager.get_settings() 
        pprint.pprint(all_settings)
        sys.exit(0)

    def setLogLevel(level):

        global appLogger
        appLogger = logging.getLogger('appBox')

        logging.basicConfig(level=level, format='%(message)s')
        appLogger.setLevel(level)
        for handler in appLogger.handlers:
            handler.setLevel(level)

    if parsed_args.quiet:
        setLogLevel(logging.ERROR)
    elif parsed_args.debug:
        setLogLevel(logging.DEBUG)
    else:
        setLogLevel(logging.INFO)

    appLogger.debug('Debugging Enabled. Jolan tru.')
    appBoxManager.header()

    if parsed_args.launch or parsed_args.launch_root:

        install_path = parsed_args.launch or parsed_args.launch_root
        try:
            json_data = SandboxInstaller.loadSingularityJSON(install_path)
            container_label = json_data['org.label-schema.usage.singularity.deffile.bootstrap']+'://'+json_data['org.label-schema.usage.singularity.deffile.from']
            appLogger.debug('Launching "{}" from "{}"'.format(container_label, parsed_args.launch))
        except:
            pass

        _launch_cmd = 'source '+os.path.join(parsed_args.launch, 'bin/activate')
        if parsed_args.launch_root:
            _launch_cmd = _launch_cmd + '-asroot';
        _launch_cmd = _launch_cmd + ';\n'

        appBoxManager.start_interactive(_launch_cmd)
        sys.exit(0)

    this_image = SettingsManager.get_this_image(parsed_args.install_image)

    this_path = os.path.abspath(parsed_args.install_path)

    appBoxManager.create_new_appenv(this_path, this_image, parsed_args.debug)

    if parsed_args.run_after or parsed_args.run_command:
        _user_cmd = 'source '+os.path.join(parsed_args.install_path, 'bin/activate')
        if parsed_args.run_command:
            _user_cmd = _user_cmd + ' "' + parsed_args.run_command.replace('"','\\"').replace('\'','\\\'') + '"\n'
            rc = NonSubShell.run_command(_user_cmd)
            sys.exit(rc)
        else:
            _user_cmd = _user_cmd + '\n'
            appBoxManager.start_interactive(_user_cmd)
    elif parsed_args.run_after_root or parsed_args.run_command_root:
        _root_cmd = 'source '+os.path.join(parsed_args.install_path, 'bin/activate-asroot')
        if parsed_args.run_command_root:
            _root_cmd = _root_cmd + ' "' + parsed_args.run_command_root.replace('"','\\"').replace('\'','\\\'') + '"\n'
            rc = NonSubShell.run_command(_root_cmd)
            sys.exit(rc)
        else:
            _root_cmd = _root_cmd + '\n'
            appBoxManager.start_interactive(_root_cmd)

    sys.exit(0)

