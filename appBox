#!/bin/env python3
# -*- coding: utf-8 -*-
# vim:fileencoding=utf-8
# pylint: disable=C0302,C0111,C0103
#
#   ▄▀▀█▄   ▄▀▀▄▀▀▀▄  ▄▀▀▄▀▀▀▄  ▄▀▀█▄▄   ▄▀▀▀▀▄   ▄▀▀▄  ▄▀▄
#  ▐ ▄▀ ▀▄ █   █   █ █   █   █ ▐ ▄▀   █ █      █ █    █   █
#    █▄▄▄█ ▐  █▀▀▀▀  ▐  █▀▀▀▀    █▄▄▄▀  █      █ ▐     ▀▄▀
#   ▄▀   █    █         █        █   █  ▀▄    ▄▀      ▄▀ █
#  █   ▄▀   ▄▀        ▄▀        ▄▀▄▄▄▀    ▀▀▀▀       █  ▄▀
#  ▐   ▐   █         █         █    ▐              ▄▀  ▄▀
#          ▐         ▐         ▐                  █    ▐
# - Written by Rob Currie <rob.currie(at)ed.ac.uk>
#
# This tool is designed to simplify the life of users looking to use
# container-like sandbox environments to do work, testing, hacking
# or just to have a play around.
# This was written to address several issues which all have the same solution,
# but the existing implementations are, well... ugly.
#
# USAGE:
#   Come one come all,
#     See appBox -h or README.md for some examples short&long, good&bad
#
# A tool for building&initializing sandboxes;
# fixing common gotchas
# and generaly allowing users to do more with what they have.
#
# Distributed under the GPLv2 only, but please don't remove attribution when using/modifying this.
#

import argparse
import fcntl
import json
import logging
import os
import platform
import pty
import pwd
import re
import select
import shutil
import stat
import struct
import subprocess
import sys
import tarfile
import termios
import time
import urllib.request
import urllib.error
from urllib.parse import urlparse
import uuid
# Requests is made at the end for a PyLint reason I'm not sure of...
import requests


# Global Logger
appLogger = logging.getLogger('appBox')
appBoxVersion = '2.1.0'

def getUN():
    '''
    Return the username of this account
    '''
    return pwd.getpwuid(os.getuid())[0]


def getHome():
    '''
    Return the home directory of this account
    '''
    return pwd.getpwuid(os.getuid())[5]


class imageSource:
    '''
    Class to handle the source of the image
    '''

    def __init__(self, defaultCacheDir=None):
        '''
        '''
        self.proto = 'unknown'
        if defaultCacheDir:
            self.imageCacheDir = defaultCacheDir
        else:
            self.imageCacheDir = f'/tmp/appBox_{getUN()}'

        # Cached tokens during this instance
        self.token = {}
        self.manifestCache = {}
        self.layerCache = {}

    @staticmethod
    def isUrl(candidate):
        """Check if the given string is a URL, even if it doesn't have a protocol."""
        urlPattern = re.compile(
            r'^(https?|ftp)?(:\/\/)?'
            r'(([a-zA-Z0-9_-]+\.)+[a-zA-Z]{2,6})'
            r'(:\d+)?(/.*)?$'
        )
        return re.match(urlPattern, candidate) is not None

    @staticmethod
    def isLabel(candidate):
        """Check if the given string is a DockerHub label."""
        dockerhubLabelPattern = re.compile(
            r'^[a-z0-9]+([._-][a-z0-9]+)*(/[a-z0-9]+([._-][a-z0-9]+)*)?(:[a-zA-Z0-9_.-]+)?$'
        )
        return re.match(dockerhubLabelPattern, candidate) is not None

    @staticmethod
    def parseImgString(image):
        '''
        Method to parse strings for images, urls, dockerhub label:tags, etc... 
        '''

        imgUrl = imageSource.isUrl(image)
        imgLabel = imageSource.isLabel(image)

        if (not imgLabel) and (not imgUrl):
            raise ValueError(f'Image: "{image}" is not a valid image string')

        if imgLabel and not imgUrl:
            image = 'https://registry-1.docker.io/' + image

        if imgUrl and '://' not in image:
            image = 'https://' + image

        appLogger.debug('Using URL: %s', image)

        parsedURI = urlparse(image)
        appLogger.debug('Parsed URI: %s', parsedURI)

        if parsedURI.scheme != "":
            realScheme = parsedURI.scheme
        else:
            realScheme = 'https'

        appLogger.debug('Adjusted Parsed URI: %s', parsedURI)

        realNetLoc = parsedURI.netloc
        if realNetLoc == "":
            realNetLoc = 'registry-1.docker.io'

        urlPath = parsedURI.path
        if urlPath.startswith('/'):
            urlPath = urlPath[1:]

        imageData = urlPath.split(':')
        imageLabel = imageData[0]

        if len(imageData) == 1:
            tag = 'latest'
        else:
            tag = imageData[1]

        if len(imageLabel.split('/')) == 1:
            imageLabel = 'library/' + imageLabel

        appLogger.debug('Image: %s, Scheme: %s, Netloc: %s, Label: %s, Tag: %s',
                        image, realScheme, realNetLoc, imageLabel, tag)

        return realScheme, realNetLoc, imageLabel, tag


    def writeContainerInfo(self, _file, image, tag):
        '''
        Write some info about this sandbox to a file
        '''
        proto, netLoc, imageLabel, tag = self.parseImgString(image)
        try:
            manifests = self.manifestCache[imageLabel]
            layerCache = self.layerCache[imageLabel]
        except KeyError as keyErr:
            _ = keyErr
            manifests = {}
            layerCache = {}
        appBoxMetaData = { '__version__': appBoxVersion,
                            'containerName': f'{proto}://{netLoc}/{imageLabel}:{tag}',
                            'installedTime': f'{time.time()}',
                            'manifests': manifests,
                            'layers': layerCache,
                         }
        json.dump(appBoxMetaData, _file, ensure_ascii=True, indent=2)

    def dumpContainerInfo(self, metaData):
        '''
        Dump the info about this sandbox to the log
        '''
        with open(metaData, 'r', encoding='utf-8') as _file:
            appBoxData = json.loads(_file.read())

        appLogger.debug(appBoxData)

    def getArch(self):
        '''
        Get the architecture of the running system
        '''
        ## TODO add logic to determine correct string for each arch based on running system
        return 'amd64'

    def getTokenURL(self, netLoc, image):
        '''
        Get the URL corresponding to get this token for this download
        '''
        logging.getLogger('requests').setLevel(logging.ERROR)
        initialURL = f"{netLoc}/v2/{image}/manifests/latest"
        dataz = requests.get(initialURL, timeout=5)
        appLogger.debug('Request data: %s', dataz.headers)
        found=False
        for _h in dataz.headers:
            if _h.lower() == 'www-authenticate':
                found=True
        if not found:
            raise ConnectionError(f'No Auth Header Found: "{initialURL}"')
        authzHeader = dataz.headers['Www-Authenticate']
        match = re.match('[ \t]*([^ \t]+)[ \t]+realm="([^"]*)"', authzHeader)
        scheme, realm = match.groups()
        if scheme.lower() == 'bearer':
            authURL = realm
        else:
            raise ConnectionError(f'Unknown Auth Scheme: "{scheme}" Returned by: "{initialURL}"')
        match = re.match('.*service="([^"]*)"', authzHeader)

        serviceID = match.groups()[0]

        authURL = f"{realm}?scope=repository:{image}:pull&service={serviceID}"
        return authURL

    def checkToken(self, netLoc, token, image):
        '''
        Method to be over-loaded, should we check the Token?
        '''
        _, _, _ = netLoc, token, image
        return False

    def getToken(self, netLoc, image):
        '''
        Return either cached token, or request one be issued
        '''
        if image in self.token:
            thisToken = self.token[image]
            if self.checkToken(netLoc, thisToken, image):
                return thisToken

        fullTokenURL = self.getTokenURL(netLoc, image)

        appLogger.debug("Querying Token: %s", fullTokenURL)
        tokenResponse = urllib.request.urlopen(urllib.request.Request(
            fullTokenURL,
        )).read()

        token = json.loads(tokenResponse.decode())['token']

        self.token[image] = token

        return self.token[image]


class dockerRepo(imageSource):
    '''
    Class for downloading docker-style container images/layers
    '''

    def __init__(self, defaultCacheDir=None, shouldCleanup=False):

        imageSource.__init__(self, defaultCacheDir)

        self._shouldCleanUp = bool(shouldCleanup)

        self.proto = 'https'

    def checkToken(self, netLoc, token, image):
        '''
        Just try to list the manifest and return based on the authenticated or not
        '''
        try:
            _headers = self.getHeaders(token)
            _, _, imageLabel, tag = imageSource.parseImgString(image)
            _ = urllib.request.urlopen(urllib.request.Request(
                    f"{netLoc}/v2/{imageLabel}/manifests/{tag}",
                    headers = _headers,
                )).read()
            return True
        except urllib.error.HTTPError as httpErr:
            appLogger.debug(httpErr)
            return False

    def getDigest(self, netLoc, manifest, image):
        '''
        Get the digest for the layers in the manifest
        '''

        appLogger.debug('Manifest: %s', manifest)

        digestList = []

        ## '.fsLayers[]' | jq -r '.blobSum'
        ## Read the blobSum and return

        ## '.layers[0]' | jq -r '.digest'
        ## Read the digest from the layers and return
        appLogger.debug('Manifest: %s', manifest)

        manifestCache = self.manifestCache.get(image, [])
        manifestCache.append(manifest)
        self.manifestCache[image] = manifestCache

        if 'layers' in manifest:
            for thisLayer in manifest['layers']:
                digestList.append({'mediaType': thisLayer['mediaType'],
                                    'digest': thisLayer['digest']})
        if 'fsLayers' in manifest:
            for thisLayer in manifest['fsLayers']:
                digestList.append({'mediaType': 'application/vnd.docker.image.rootfs.diff.tar.gzip',
                                    'digest': thisLayer['blobSum']})

        ## '.manifest[0]' | jq -r '.digest'
        ## Read the manifest, get the correct digests and return
        elif 'manifests' in manifest:
            thisArch = self.getArch()
            for _manifest in manifest['manifests']:
                if _manifest['platform']['architecture'] == thisArch:
                    thisCSum = _manifest['digest']

                    token = self.getToken(netLoc, image)
                    _headers = self.getHeaders(token, "application/vnd.oci.image.manifest.v1+json")

                    manifestResponse = self.getManifests(netLoc, image, thisCSum, _headers)

                    manifestJSON = json.loads(manifestResponse)

                    digestList = self.getDigest(netLoc, manifestJSON, image)

                    break

        #raise Exception('here')
        return digestList

    def _assembleImage(self, imageLayers, outputImage):
        '''
        Perform the logic of 'assembling' the images into a single compressed image
        '''

        appLogger.debug('Image Layers: %s', imageLayers)

        tmpFolder = os.path.join(self.imageCacheDir, f'appBox_tmpFolder_{str(uuid.uuid4())[:8]}')
        os.makedirs(tmpFolder)

        for layer in imageLayers:
            if layer['mediaType'] in ['application/vnd.docker.image.rootfs.diff.tar.gzip',
                                      'application/vnd.oci.image.layer.v1.tar+gzip']:
                ## TODO add a tarfile filter to catch (bad image) failing mknod errors
                ## This should probably be done by a filter as
                ## we 'care' about some errors we're silencing here
                ## See Ubuntu:16.04 if you can still find it...
                with tarfile.open(layer['cacheFile'], errorlevel=0) as _tfile:
                    try:
                        _tfile.extractall(tmpFolder, filter='tar')
                    except TypeError:
                        _tfile.extractall(tmpFolder)

        current = stat.S_IMODE(os.lstat(tmpFolder).st_mode)
        os.chmod(tmpFolder, current | stat.S_IWUSR | stat.S_IRUSR)

        for (root, dirs, files) in os.walk(tmpFolder, topdown=True):
            for _dir in dirs:
                thisPath = os.path.join(root,_dir)
                if not os.path.islink(thisPath):
                    current = stat.S_IMODE(os.lstat(thisPath).st_mode)
                    os.chmod(thisPath, current | stat.S_IWUSR | stat.S_IRUSR)
            for _file in files:
                thisPath = os.path.join(root,_file)
                if not os.path.islink(thisPath):
                    current = stat.S_IMODE(os.lstat(thisPath).st_mode)
                    os.chmod(os.path.join(root,_file), current | stat.S_IWUSR | stat.S_IRUSR)

        with tarfile.open(outputImage, "w|gz") as tar:
            contents = os.listdir(tmpFolder)
            for _obj in contents:
                tar.add(os.path.join(tmpFolder,_obj), arcname=_obj)

        shutil.rmtree(tmpFolder)

        return outputImage

    def cacheImage(self, image, tag):
        '''
        This returns the path to the expected image cache
        '''
        imageCache = ''
        for _ in image.split('/'):
            imageCache = f'{imageCache}_{_}'

        return os.path.join(self.imageCacheDir, f'appBox_{imageCache}_{tag}.compressed')

    def getHeaders(self, token, accept="application/vnd.docker.distribution.manifest.v2+json"):
        '''
        Get thr headers to be used in the request
        '''
        return {"Accept": accept,
                 "Authorization": f"Bearer {token}",
                 "Content-Type": "application/json",
                 "User-Agent": "curl/8.0.1",}

    def getManifests(self, netLoc, image, tag, _headers):
        '''
        Get the manifest for this container
        '''
        appLogger.debug('Request Headers: %s', _headers)
        appLogger.debug("Querying Manifest: %s/v2/%s/manifests/%s", netLoc, image, tag)

        return urllib.request.urlopen(urllib.request.Request(
            f"{netLoc}/v2/{image}/manifests/{tag}",
            headers = _headers,
        )).read()

    def pullImage(self, image):
        '''
        Pull the requested image from a remote service
        '''
        realScheme, realNetLoc, imageLabel, tag = imageSource.parseImgString(image)

        realNetLoc = realScheme + '://' + realNetLoc

        outputImage = self.cacheImage(imageLabel, tag)

        if os.path.isfile(outputImage):
            appLogger.info('Output Image: "%s" found for image: "%s", tag: "%s"',
                                        outputImage, imageLabel, tag)
            return
        else:
            appLogger.info('Pulling Image for: %s:%s', imageLabel, tag)

        token = self.getToken(realNetLoc, imageLabel)

        _headers = self.getHeaders(token)

        appLogger.debug('Request Headers: %s', _headers)
        appLogger.debug("Querying Image: %s/v2/%s/manifests/%s", realNetLoc, imageLabel, tag)

        try:
            manifestResponse = self.getManifests(realNetLoc, imageLabel, tag, _headers)
        except urllib.error.HTTPError as httpErr:
            appLogger.error('Failed to get manifest for image: "%s", tag: "%s"', imageLabel, tag)
            appLogger.error('Error: %s', httpErr)
            if appLogger.level == logging.DEBUG:
                raise httpErr
            sys.exit(134)

        manifestJSON = json.loads(manifestResponse)

        thisDigestList = self.getDigest(realNetLoc, manifestJSON, imageLabel)

        def checkOutputLocation(outputDir):
            if not os.path.exists(outputDir):
                appLogger.debug('Creating output directory: %s', outputDir)
                os.makedirs(outputDir)

        checkOutputLocation(self.imageCacheDir)

        imageLayers = []

        for thisDigest in thisDigestList:

            digestImage = ''
            for _ in imageLabel.split('/'):
                digestImage += _ + '_'
            digestImage = digestImage[:-1]

            outputCache = f'{thisDigest["digest"]}_{digestImage}_{tag}.digest'
            outputCache = os.path.join(self.imageCacheDir, outputCache)
            imageLayers.append({'mediaType': thisDigest['mediaType'],
                                 'cacheFile': outputCache,
                                 'digest': thisDigest['digest']})

            appLogger.debug('Downloading Layer: %s', thisDigest['digest'])
            blobPath = f"{realNetLoc}/v2/{imageLabel}/blobs/{thisDigest['digest']}"

            labelCache = self.layerCache.get(imageLabel, [])
            labelCache.append(thisDigest['digest'])
            self.layerCache[imageLabel] = labelCache

            # Used to be used with urlopen which has... issues...
            #this_request = urllib.request.Request(blob_path, headers = _headers)
            with requests.get(blobPath, headers=_headers, stream=True, timeout=5) as requestData:
                requestData.raise_for_status()
                with open(outputCache, 'wb+') as _file:
                    for chunk in requestData.iter_content(chunk_size=32*1024):
                        _file.write(chunk)

        assembledImage = self._assembleImage(imageLayers, outputImage)

        appLogger.info('Image assembled at: %s', assembledImage)

        #def cleanUp(to_be_removed):
        #    ## Loop through and unlink un-needed layer and compressed layer versions
        #    while _file in to_be_removed:
        #        os.unlink(_file)

        #if self._shouldCleanUp:
        #    for _layer in image_layers:
        #        os.unlink(_layer['cacheFile'])

    def buildSandbox(self, image, dest):
        '''
        Build the sandbox from the image.
        Aka, extract the compressed image to the destination.
        '''

        appBoxFile = os.path.join(dest, '._appBoxContainer')

        realScheme, realNetloc, imageLabel, tag = imageSource.parseImgString(image)
        _, _  = realScheme, realNetloc
        appLogger.debug('Image: "%s"', imageLabel)
        thisImage = self.cacheImage(imageLabel, tag)

        appLogger.debug("Looking for Stored image at: %s", thisImage)

        if not os.path.exists(thisImage):
            appLogger.error('Expected to find (cached) image at: "%s",', thisImage)
            appLogger.error('for image: "%s", tag: "%s".', image, tag)
            appLogger.error('Did you forget to pull first?')
            return False

        if not os.path.exists(dest):
            os.makedirs(dest)
        else:
            if os.path.exists(appBoxFile):
                appLogger.info('Found appBox sandbox at: %s', dest)

                # TODO add integrity checking for sandbox

                self.dumpContainerInfo(appBoxFile)
                return False

        appLogger.info('Extracting Compressed Image.')
        appLogger.debug('Image: "%s", Dest: "%s"', thisImage, dest)
        with tarfile.open(thisImage) as _tfile:
            try:
                _tfile.extractall(dest, filter='fully_trusted')
            except TypeError:
                _tfile.extractall(dest)

        appLogger.info('Writing metaData.')
        with open(appBoxFile, 'w+', encoding='utf-8') as _file:
            self.writeContainerInfo(_file, image, tag)

        return True


class sandboxFixes():
    '''
    Class to handle the fixes needed for the sandbox
    '''

    def __init__(self, addNV, sandboxInstance):
        '''
        '''

        self.addNVidia = addNV
        self.sandboxInstance = sandboxInstance

        self.tmpPath = '/tmp'

    def applyAllFixes(self):
        '''
        Apply all of the fixes to this sandbox
        '''
        self.fixFilePermissions()
        self.fixAptSandboxing()
        self.fixMissingPaths()
        self.fixMissingStubs()
        self.fixUserAccounts()
        self.fixAliases()
        self.fixEnvironment()
        self.installAppBox()
        self.copyFromHost()
        self.fixForLies()

    def applySafeFixes(self):
        '''
        Apply only a _safe_ subset of the fixes to this sandbox
        '''
        self.fixUserAccounts()
        self.copyFromHost()

    def copyFromHost(self):
        '''
        Copy certain configs from the host to the sandbox so things work
        '''

        fileList = ['/etc/resolv.conf', '/etc/hostname',
                    '/etc/localtime', '/etc/timezone', '/etc/vimrc']

        for _file in fileList:
            self.sandboxInstance.copyFileFromHost(_file,
                    os.path.abspath(os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_file)))

    def fixFilePermissions(self):
        '''
        Fix the permissions of a given path
        '''
        if self.sandboxInstance.rootfs:
            return
        for root, dirs, files in os.walk(self.sandboxInstance.getSandboxPath(), topdown=True):
            for _dir in dirs:
                thisPath = os.path.join(root,_dir)
                if not os.path.islink(thisPath):
                    current = stat.S_IMODE(os.lstat(thisPath).st_mode)
                    os.chmod(thisPath, current | stat.S_IWUSR | stat.S_IRUSR | stat.S_ISGID)
            for _file in files:
                thisPath = os.path.join(root,_file)
                if not os.path.islink(thisPath):
                    current = stat.S_IMODE(os.lstat(thisPath).st_mode)
                    os.chmod(os.path.join(root,_file), current | stat.S_IWUSR | stat.S_IRUSR)

    def _getPathList(self):
        '''
        Return the list of paths we want to mount into the sandbox
        '''
        # This is a good fraction of the lsb because not all images follow the lsb...
        # which means...
        # well...
        # yeah...
        basePathList = ['/afs', '/dev', '/etc', '/cvmfs', '/scratch', '/Data', '/localdisk',
                          '/sys', '/tmp', '/home', '/proc', f'/tmp/{getUN()}', '/mnt']

        if self.addNVidia:
            basePathList.append('/usr/lib/wsl')

        return basePathList

    def fixMissingPaths(self):
        '''
        Fix potentially missing paths in the sandbox
        '''
        neededSandboxPaths = self._getPathList()

        absPaths = []
        for _path in neededSandboxPaths:
            absPaths.append(os.path.abspath(
                        os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_path)))

        for _path in absPaths:
            self.sandboxInstance.createSandboxPath(_path)

    def _getStubList(self):
        '''
        Make stubs for files to be mounted in from the host
        '''
        baseStubs = ['/etc/resolv.conf', '/etc/hostname']

        if self.addNVidia:
            baseStubs.append('/usr/bin/nvidia-smi')
            baseStubs.append('/usr/bin/nvidia-modprobe')

        return baseStubs

    def fixMissingStubs(self):
        '''
        Create the stubs needed for the sandbox
        '''
        neededStubs = self._getStubList()

        absPaths = []
        for _path in neededStubs:
            absPaths.append(os.path.abspath(
                        os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_path)))

        for _path in absPaths:
            self.sandboxInstance.createSandboxEmptyFile(_path)

    def getAnonUIDGID(self):
        '''
        Return the Anon UID and GID for the sandbox
        In principle this can change based on the system, but for now it's fixed
        '''
        # TODO work out if we need to detect/change this
        return (65534, 65534)

    def fixUserAccounts(self):
        '''
        Fix the user accounts within the sandbox
        '''
        tmpPasswdFile = os.path.join(self.tmpPath, f'passwd_{str(uuid.uuid4())[:8]}')
        try:
            self._fixPasswd(tmpPasswdFile)
        finally:
            os.unlink(tmpPasswdFile)
        tmpGroupFile = os.path.join(self.tmpPath, f'group_{str(uuid.uuid4())[:8]}')
        try:
            self._fixGroup(tmpGroupFile)
        finally:
            os.unlink(tmpGroupFile)
        tmpShadowFile = os.path.join(self.tmpPath, f'gshadow_{str(uuid.uuid4())[:8]}')
        try:
            self._fixGShadow(tmpShadowFile)
        finally:
            os.unlink(tmpShadowFile)

    def _fixPasswd(self, tmpPasswdFile):
        '''
        Fix the passwd config so the user mappings make sense
        '''
        self.sandboxInstance.copyFileToHost('/etc/passwd', tmpPasswdFile)

        with open(tmpPasswdFile, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('Content: "%s"', _content)

        newContent = 'root:x:0:0:root:/root:/bin/bash\n'
        newContent += f'{getUN()}:x:65534:65534:{getUN()}:{getHome()}:/bin/bash\n'

        aUID, aGID = self.getAnonUIDGID()

        for _line in _content.split('\n'):
            if _line:
                _user, _, _uid, _gid, _name, _home, _shell = _line.split(':')
                if _user in ['root', getUN(), 'fax', 'input', 'kvm', 'render']:
                    continue
                if _user.startswith('systemd'):
                    # A dirty trick to keep apt 'content' on Ubuntu systems
                    continue
                appLogger.debug(
                    'User: "%s", UID: "%s", GID: "%s", Name: "%s", Home: "%s", Shell: "%s"',
                                    _user, _uid, _gid, _name, _home, _shell)

                newContent += f'{_user}:x:{aUID}:{aGID}:{_name}:{_home}:{_shell}\n'

        with open(tmpPasswdFile, 'w+', encoding='utf-8') as _file:
            _file.write(newContent)

        self.sandboxInstance.copyFileFromHost(tmpPasswdFile,
                            os.path.join(self.sandboxInstance.getSandboxPath(), './etc/passwd'))

    def _fixGroup(self, tmpGroupFile):
        '''
        Fix the group permissions so that mappings make sense
        '''
        self.sandboxInstance.copyFileToHost('/etc/group', tmpGroupFile)

        with open(tmpGroupFile, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('Content: "%s"', _content)

        _, aGID = self.getAnonUIDGID()

        newContent = 'root:x:0:\n'
        newContent += f'{getUN()}:x:{aGID}:\n'

        for _line in _content.split('\n'):
            if _line:
                _group, _, _gid, _users = _line.split(':')
                if _group in ['root', getUN(), 'fax', 'input', 'kvm', 'render']:
                    continue
                if _group.startswith('systemd'):
                    # A dirty trick to keep apt 'content' on Ubuntu systems
                    continue
                appLogger.debug('Group: "%s", GID: "%s", Users: "%s"', _group, _gid, _users)

                newContent += f'{_group}:x:{aGID}:{_users}\n'

        with open(tmpGroupFile, 'w+', encoding='utf-8') as _file:
            _file.write(newContent)

        self.sandboxInstance.copyFileFromHost(tmpGroupFile,
                                os.path.join(self.sandboxInstance.getSandboxPath(), './etc/group'))

    def _fixGShadow(self, tmpShadowFile):
        '''
        This fixes the gshadow config, mainly for debian systems
        '''
        self.sandboxInstance.copyFileToHost('/etc/gshadow', tmpShadowFile)
        with open(tmpShadowFile, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('Content: "%s"', _content)

        newContent = ''

        for _line in _content.split('\n'):
            if _line:
                _pass = True
                for check in ['fax', 'voice', 'sudo', 'dip', 'operator', 'src',
                              'shadow', 'sasl', 'plugdev', 'staff', 'nogroup']:
                    if _line.startswith(check):
                        _pass = False
                        break
                if not _pass:
                    continue
                newContent += _line + '\n'

        with open(tmpShadowFile, 'w+', encoding='utf-8') as _file:
            _file.write(newContent)

        self.sandboxInstance.copyFileFromHost(tmpShadowFile,
                            os.path.join(self.sandboxInstance.getSandboxPath(), './etc/gshadow'))

    def fixAliases(self):
        '''
        Fix the aliases in the sandbox
        '''

        self.sandboxInstance.createSandboxPath(
                    os.path.join(self.sandboxInstance.getSandboxPath(), './etc/profile.d'))

        def fixDeactivate():
            tmpDeacScript = os.path.join(self.tmpPath, f'deac.sh_{str(uuid.uuid4())[:8]}')
            with open(tmpDeacScript, 'w+', encoding='utf-8') as _file:
                _file.write('alias deactivate=exit')

            self.sandboxInstance.copyFileFromHost(tmpDeacScript,
                    os.path.join(self.sandboxInstance.getSandboxPath(), './etc/profile.d/deac.sh'))

        fixDeactivate()

    def fixEnvironment(self):
        '''
        Fix missing env vars at 'login' which includes wsl linkage
        '''

        if self.addNVidia:
            self.sandboxInstance.createSandboxPath(
                os.path.join(self.sandboxInstance.getSandboxPath(), './etc/ld.so.conf.d'))
            tmpLDPath = os.path.join(self.tmpPath, f'ld.wsl.conf_{str(uuid.uuid4())[:8]}')
            with open(tmpLDPath, 'w+', encoding='utf-8') as _file:
                _file.write('/usr/lib/wsl/lib')
            self.sandboxInstance.copyFileFromHost(tmpLDPath,
                os.path.join(self.sandboxInstance.getSandboxPath(), './etc/ld.so.conf.d/wsl.conf'))

    def fixAptSandboxing(self):
        '''
        Fix issues related to installing packages on Debian in a single-user-sandbox...
        '''

        appConfPath = os.path.join(self.sandboxInstance.getSandboxPath(), './etc/apt/apt.conf.d/')
        self.sandboxInstance.createSandboxPath(appConfPath)

        layerPath = os.path.join(self.sandboxInstance.sandboxPath, './etc/apt/apt.conf.d/')
        if os.path.exists(layerPath):
            # Only want to apply this 'fix' in sandboxes where apt is installed

            fixApt  = 'APT::Sandbox::User "root";\nAPT::Sandbox::Verify "0";\n'
            fixApt += 'APT::Sandbox::Verify::IDs "0";\nAPT::Sandbox::Verify::Groups "0";\n'
            fixApt += 'APT::Sandbox::Verify::Regain "0";'

            tmpSandbox = os.path.join(self.tmpPath, f'sandbox-disable_{str(uuid.uuid4())[:8]}')
            with open(tmpSandbox, 'w+', encoding='utf-8') as _file:
                _file.write(fixApt)

            self.sandboxInstance.copyFileFromHost(tmpSandbox, os.path.join(appConfPath, '99appBox'))

            ## Hack of a hack...
            ## cp /bin/true /usr/bin/dpkg-statoverride

            shutil.copyfile(os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/true'),
                os.path.join(self.sandboxInstance.getSandboxPath(), 'usr/bin/dpkg-statoverride'))

            shutil.copyfile(os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/true'),
                    os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/dpkg-statoverride'))

    def installAppBox(self):
        '''
        Install the appBox tool into the sandbox
        '''
        currentInstance = os.path.abspath(__file__)
        if not os.path.exists(os.path.join(self.sandboxInstance.sandboxPath, './bin')):
            os.makedirs(os.path.join(self.sandboxInstance.sandboxPath, './bin'))
        installInstance = os.path.join(self.sandboxInstance.sandboxPath, './bin/appBox')

        self.sandboxInstance.copyFileFromHost(currentInstance, installInstance)

        cvmfsArgs = ''
        if self.sandboxInstance.rootfs:
            cvmfsArgs = f'-cvmfs {os.path.abspath(self.sandboxInstance.rootfs)}'

        for _ in ['user', 'root']:
            if _ == 'root':
                asString = '-rar'
                scriptName = 'activate-asroot'
            else:
                asString = '-ra'
                scriptName = 'activate'

            activateScript = """#!/bin/bash

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

/bin/env python3 ${SCRIPT_DIR}/appBox """
            activateScript = activateScript + cvmfsArgs
            activateScript = activateScript + " -l ${SCRIPT_DIR}/../ """ + asString

            activatePath = os.path.join(self.sandboxInstance.sandboxPath, f'./bin/{scriptName}')
            with open(activatePath, 'w+', encoding='utf-8') as _file:
                _file.write(activateScript)

            for _file in [installInstance, activatePath, ]:
                st = os.stat(_file)
                os.chmod(_file, st.st_mode | stat.S_IEXEC)

    def fixForLies(self):
        '''
        Override some commands to stop people doing bad things by accident,
        or on-purpose to themselves
        '''

        ## TODO decide if this is a bad idea or not...
        ## Intention here is to 'stop' automated tooling from trying to do something
        ## bad within the sandbox. This has the side-effect of stopping people changing
        ## a file so that they can't so anything with it without magic cmdline-fu (d'oh!)

        for _file in ['/usr/bin/chown', '/usr/bin/chmod', '/bin/chown', '/bin/chmod', ]:
            self.sandboxInstance.copyFileFromHost(
                            os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/true'),
                            os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_file))
            self.sandboxInstance.copyFileFromHost(
                            os.path.join(self.sandboxInstance.getSandboxPath(), 'bin/true'),
                            os.path.join(self.sandboxInstance.getSandboxPath(), '.'+_file))


class sessionManager():
    '''
    Class for managing interactive sandbox sessions
    '''

    def __init__(self, sandboxPath, compatV1=False, addNV=False, rootfs=None):
        '''
        Standard __init__ :)
        '''
        self.proc = None
        self.pidParent = None
        self.pidChild = None
        self.oldTTY = None
        self.sandboxPath = sandboxPath
        self.compatV1 = compatV1
        self.addNVidia = addNV

        self.stdoutM, self.stdoutS = None, None
        self.running = False

        self.proc2 = None
        self.pidSubChild, self.pidSubParent = None, None

        self.rootfs = rootfs
        self._layers = ['._appBoxLayers/overlay', '._appBoxLayers/upper', '._appBoxLayers/work']

    def getSandboxPath(self):
        '''
        Return the path to the sandbox
        '''
        if self.rootfs:
            rootFS = os.path.join(self.sandboxPath, '._appBoxLayers/overlay')
            appLogger.debug('Sandbox Path: %s', rootFS)
            return rootFS
        else:
            appLogger.debug('Sandbox Path: %s', self.sandboxPath)
            return self.sandboxPath

    def setraw(self, fd, when=termios.TCSAFLUSH):
        """Put terminal into a raw mode."""

        # Indexes for termios list.
        iFLAG = 0
        #OFLAG = 1
        cFLAG = 2
        lFLAG = 3
        #ISPEED = 4
        #OSPEED = 5
        cc = 6

        mode = termios.tcgetattr(fd)
        mode[iFLAG] = mode[iFLAG] & ~(termios.BRKINT | termios.ICRNL |
                                      termios.INPCK | termios.ISTRIP | termios.IXON)
        #mode[OFLAG] = mode[OFLAG] & ~(termios.OPOST)
        mode[cFLAG] = mode[cFLAG] & ~(termios.CSIZE | termios.PARENB)
        mode[cFLAG] = mode[cFLAG] | termios.CS8
        mode[lFLAG] = mode[lFLAG] & ~(termios.ECHO | termios.ICANON |
                                      termios.IEXTEN | termios.ISIG)
        mode[cc][termios.VMIN] = 1
        mode[cc][termios.VTIME] = 0
        termios.tcsetattr(fd, when, mode)

    def _wrangleTTY(self):
        '''
        This is some boiler-plate for setting up a pTTY
        '''

        # save original tty setting then set it to raw mode
        oldTTY = termios.tcgetattr(sys.stdin)
        #tty.setraw(sys.stdin.fileno())
        self.setraw(sys.stdin.fileno(), when=termios.TCSANOW)

        # open pseudo-terminal to interact with subprocess
        stdoutMfd, stdoutSfd = pty.openpty()

        size = os.get_terminal_size()
        winsize = struct.pack("HHHH", size[1], size[0], 0, 0)

        fcntl.ioctl(stdoutMfd, termios.TIOCSWINSZ, winsize)

        appLogger.debug('Opening PTY')

        self.oldTTY = oldTTY
        self.stdoutM, self.stdoutS = stdoutMfd, stdoutSfd

    def setupHostSpace(self):
        '''
        This sets up a 'root' namespace.
        This persists for the lifetime of this shell.
        '''

        if self.rootfs:
            for _layer in self._layers:
                thisLayer = os.path.join(self.sandboxPath, _layer)
                if not os.path.exists(thisLayer):
                    os.makedirs(thisLayer)

        backgroundTask='/bin/bash'
        appLogger.debug('Launching host namespace manager')
        hostManager=f"unshare -primf --propagation unchanged {backgroundTask}"
        appLogger.debug(hostManager)
        # pylint: disable=locally-disabled, subprocess-popen-preexec-fn
        self.proc = subprocess.Popen(hostManager,
                                     shell=True, preexec_fn=os.setsid,
                                     stdin = subprocess.PIPE,
                                     stdout = subprocess.PIPE,
                                     stderr = subprocess.PIPE,
                                     universal_newlines = True)

        appLogger.debug('Host sandbox namespace: %s', self.proc.pid)
        self.pidParent=self.proc.pid
        time.sleep(0.1)

        parentID = self.pidParent
        childID = parentID
        while True:

            appLogger.debug('Parent PID: %s', parentID)
            appLogger.debug('Child PID: %s', childID)
            try:
                parentID, childID = self.getChildID(childID)
                self.pidChild = childID
            except (OSError, ValueError) as pidErr:
                appLogger.debug('Error: %s', pidErr)
                break
            time.sleep(0.1)

            appLogger.debug('---')

        if not self.pidChild:
            raise SystemError('Cannot Fork Child Process. Are you trying to run inside appBox?')

        return self.pidParent, self.pidChild

    def _copyToFromSandbox(self, source, dest):
        '''
        Copy files from A to B
        '''
        copyCMD = f'cp -rfHL {source} {dest}'
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s',
                            self.pidChild, copyCMD)

        copyProc = subprocess.Popen(
                f'nsenter --preserve-credentials --user --mount --pid -t {self.pidChild} {copyCMD}',
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        ## TODO add better error checking here
        copyProc.wait()
        appLogger.debug(copyProc.poll())
        del copyProc

    def copyFileFromHost(self, hostFile, sandboxFile):
        '''
        Copy a file from the host into the sandbox
        '''
        i=0
        while os.path.islink(hostFile):
            appLogger.debug('Symlink: %s -> %s', hostFile, os.readlink(hostFile))
            hostFile = os.readlink(hostFile)
            i=i+1
            if i>10:
                break
        if i>10:
            appLogger.error('Too many symlinks in file: %s', hostFile)
            return
        #if self.compatV1:
        #    sandboxFile = os.path.join(self.getSandboxPath(), '.'+sandboxFile)
        self._copyToFromSandbox(hostFile, sandboxFile)

    def copyFileToHost(self, sandboxFile, hostFile):
        '''
        Copy a file from a Sandbox to the host
        '''
        #if self.compatV1:
        sandboxFile = os.path.join(self.getSandboxPath(), '.'+sandboxFile)
        self._copyToFromSandbox(sandboxFile, hostFile)

    def createSandboxPath(self, path, overridePID=None):
        '''
        Create a new path within the sandbox
        '''
        pidSpace = self.pidChild
        if overridePID:
            pidSpace = overridePID
        createCMD = f'mkdir -p {os.path.abspath(path)}'
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s',
                            pidSpace, createCMD)

        createProc = subprocess.Popen(
                f'nsenter --preserve-credentials --user --mount --pid -t {pidSpace} {createCMD}',
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        ## TODO add better error checking here
        createProc.wait()
        del createProc

    def createSandboxEmptyFile(self, path):
        '''
        Create an empty 'stub' file in the sandbox
        '''
        createCMD = f'touch {os.path.abspath(path)}'

        createProc = subprocess.Popen(
            f'nsenter --preserve-credentials --user --mount --pid -t {self.pidChild} {createCMD}',
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        ## TODO add better error checking here
        createProc.wait()
        del createProc

    def getChildID(self, thisPID):
        '''
        Get the child ID of a given PID
        '''
        childPIDPath = f'/proc/{thisPID}/task/{thisPID}/children'
        appLogger.debug('Querying ID: %s', childPIDPath)
        with open(childPIDPath, 'r', encoding='utf-8') as _file:
            _content = _file.read()
            appLogger.debug('Content: "%s"', _content)
            childPid = int(_content)
            appLogger.debug('PID: %s', childPid)

        return thisPID, childPid

    def getSharePaths(self):
        '''
        This is a list of directories to be mounted into the sandbox from the host
        '''
        mounts = ['/afs', '/home', '/tmp', '/dev', '/cvmfs',
                  '/scratch', '/Data', '/localdisk', '/sys', '/mnt']
        if self.addNVidia:
            mounts += ['/usr/lib/wsl', '/usr/bin/nvidia-smi', '/usr/bin/nvidia-modprobe']
        return mounts

    def mountHost(self, overridePID=None):
        '''
        Mount the shared paths between the host and the sandbox namespace
        '''
        hostMounts = self.getSharePaths()

        for hostPath in hostMounts:

            sandboxPath = os.path.abspath(os.path.join(self.getSandboxPath(), '.' + hostPath))

            if not os.path.exists(hostPath):
                appLogger.debug('Skipping path %s, as it doesn\'t exist on the host', hostPath)
                continue

            appLogger.debug('Bind Mounting: %s as: %s', hostPath, sandboxPath)
            self.createSandboxPath(sandboxPath, overridePID)

            pidSpace = self.pidChild
            mountOpts = '--rbind --make-rslave'
            if overridePID:
                pidSpace = overridePID
                mountOpts = '--rbind'

            appLogger.debug(
                'nsenter --preserve-credentials --user --mount --pid -t %s mount %s %s %s',
                                pidSpace, mountOpts, hostPath, sandboxPath)

            mountCMD = 'nsenter --preserve-credentials --user --mount --pid -t'
            mountCMD = mountCMD + f' {pidSpace} mount {mountOpts} {hostPath} {sandboxPath}'
            mountProc = subprocess.Popen(
                            mountCMD,
                            stdin = subprocess.PIPE,
                            stdout = subprocess.PIPE,
                            stderr = subprocess.PIPE,
                            shell=True)
            mountProc.wait()
            ## TODO add better error checking here

            del mountProc

    def mountrootfs(self, rootfs):
        '''
        Mount the ROOTFS for the sandbox from a RO source
        '''

        rootfsPath = os.path.realpath(os.path.abspath(os.path.join(rootfs)))

        neededLayers = ['._appBoxLayers/overlay', '._appBoxLayers/upper', '._appBoxLayers/work']

        layerPaths = []
        for _layer in neededLayers:

            layerPath = os.path.abspath(os.path.join(self.sandboxPath, _layer))

            if not os.path.exists(layerPath):
                os.makedirs(layerPath)

            layerPaths.append(layerPath)

        rootfsMountCMD = 'fuse-overlayfs -o squash_to_root -o'
        rootfsMountCMD = rootfsMountCMD + f' lowerdir={rootfsPath},upperdir={layerPaths[1]}'
        rootfsMountCMD = rootfsMountCMD + f',workdir={layerPaths[2]} {layerPaths[0]}'

        appLogger.debug('Mounting rootfs via: %s', rootfsMountCMD)

        mountProc = subprocess.Popen(
        f'nsenter --preserve-credentials --user --mount --pid -t {self.pidChild} {rootfsMountCMD}',
                        stdin = subprocess.PIPE,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE,
                        shell=True)

        ## TODO add better error checking here
        mountProc.wait()
        del mountProc

    def cleanupSpaces(self):
        '''
        Cleanup the 'persistent' spaces which have been created
        '''
        # restore tty settings back
        try:
            #os.write(sys.stdin.fileno(), '\n\r'.encode())
            # Restore the stdin back to what it used to be
            termios.tcsetattr(sys.stdin, termios.TCSANOW, self.oldTTY)
            sys.stdin.flush()
            sys.stdout.flush()
            del self.proc
        except (IOError, OSError) as delErr:
            appLogger.debug('Deletion Error: %s', delErr)

    def setupSubSpace(self, asRoot):
        '''
        Create a subSpace within the root space of the host
        '''
        appLogger.debug('Setting up SubSpace')

        chrootCMD = self._getSandboxCmd(None, asRoot)
        # pylint: disable=locally-disabled, subprocess-popen-preexec-fn
        self.proc2 = subprocess.Popen(chrootCMD,
                                     shell=True, preexec_fn=os.setsid,
                                     stdin = subprocess.PIPE,
                                     stdout = subprocess.PIPE,
                                     stderr = subprocess.PIPE,
                                     universal_newlines = True)

        appLogger.debug('PID of subSpace: %s', self.proc2.pid)

        self.pidSubParent=self.proc2.pid

        time.sleep(0.1)

        with open(f'/proc/{self.pidSubParent}/task/{self.pidSubParent}/children',
                  'r', encoding='utf-8') as _file:
            self.pidSubChild=int(_file.read())
            appLogger.debug('Child PID: %s', self.pidSubChild)

        return (self.pidSubParent, self.pidSubChild)

    def _getSandboxCmd(self, command=None, asRoot=False):
        '''
        Get the command to run inside the sandbox (i.e. the shell)
        '''

        if command is None:
            if self.rootfs:
                commandPath = os.path.join(self.rootfs, 'bin/bash')
            else:
                commandPath = os.path.join(self.sandboxPath, 'bin/bash')
            if os.path.exists(commandPath):
                command = '/bin/bash -l'
            else:
                command = '/bin/sh'
        else:
            if not self.compatV1:
                commandPath = os.path.join(self.sandboxPath, 'bin/bash')
                if os.path.exists(commandPath):
                    command = f'/bin/bash -c "sleep 1; {command}"'
                else:
                    pass
            else:
                command = f'/bin/bash -c \'sleep 1; {command}\''
        #command = '/bin/bash -l'

        if not self.compatV1:
            # Continue as Normal and use good hosts unshare
            if asRoot:
                chrootCMD = f'/bin/bash -c \'mount -t tmpfs tmpfs {self.getSandboxPath()}/run; '
                chrootCMD = chrootCMD + 'unshare -priUmf --mount --mount-proc -R '
                chrootCMD = chrootCMD + f'{self.getSandboxPath()} --propagation=unchanged '
                chrootCMD = chrootCMD + f'{command};\' exit $?'
            else:
                chrootCMD = f'/bin/bash -c \'mount -t tmpfs tmpfs {self.getSandboxPath()}/run;'
                chrootCMD = chrootCMD + 'unshare -piUmf --mount --mount-proc -R '
                chrootCMD = chrootCMD + f'{self.getSandboxPath()} --propagation=unchanged '
                chrootCMD = chrootCMD + f'{command};\' exit $?'
        else:
            # Use the older compatibility mode for the sandbox,
            # use chroot and drop the '-R' unshare arg...
            # TBF for HEP it was clear as day AL9 was going to be the way forward,
            # but some people are still on CO8/R8... _sigh_ ...

            # I absolutely could not find a way without unshare -R to drop down to
            # a non-priviledged anon user using chroot...
            # This could simply be me mis-understanding something about sandboxes
            # and their inheritance, or my mistake...
            # Given I don't really _want_ to support running on such an old
            # host I think we can just say for now:

            if not asRoot:
                appLogger.warning('Compatability with older Hosts doesn\'t work,')
                appLogger.warning('if dropping into a \'non-root\' sandbox.')
                appLogger.warning('Running as "root" in sandbox')

            chrootCMD = f'chroot {self.getSandboxPath()} /bin/bash -c'
            chrootCMD = chrootCMD + 'export PATH=/bin:/sbin:/usr/sbin:/usr/bin:$PATH;'
            chrootCMD = chrootCMD + '/bin/mount -t tmpfs tmpfs /run;'
            chrootCMD = chrootCMD + f'/bin/mount -t proc proc /proc; {command}"; exit $?'

        return chrootCMD

    def runCommand(self, command, asRoot=False):
        '''
        Run Said command inside the sandbox env
        '''

        chrootCMD = self._getSandboxCmd(command, asRoot)

        appLogger.debug('About to execute')
        appLogger.debug('nsenter --preserve-credentials --user --mount --pid -t %s %s ; exit $?;',
                                self.pidChild, chrootCMD)

        self._wrangleTTY()
        procCMD = 'nsenter --preserve-credentials --user --mount --pid -t'
        procCMD = procCMD + f' {self.pidChild} {chrootCMD}; exit $?;'
        # pylint: disable=locally-disabled, subprocess-popen-preexec-fn
        interactiveProc = subprocess.Popen(
                procCMD,
                stdin = self.stdoutS,
                stdout = self.stdoutS,
                stderr = self.stdoutS,
                shell = True, universal_newlines = True, preexec_fn=os.setsid
                )

        i=0
        timeLimit=100

        while i<= timeLimit:
            time.sleep(0.1)  # Total 10s chance for child to spawn on a healthy system
            i=i+1            # Obviously 10s+work-time, but I'm assuming accessing proc is cheap

            parentID = interactiveProc.pid
            childID = parentID

            try:
                # If the process is unknown or in a zombie state
                if self.procState(interactiveProc.pid) in ['Z', 'E']:
                    break
            except PermissionError as permissionErr:
                appLogger.debug('Error: %s', permissionErr)

            while True:

                appLogger.debug('Parent PID: %s', parentID)
                appLogger.debug('Child PID: %s', childID)
                try:
                    parentID, childID = self.getChildID(childID)
                    #self.pidChild = childID
                except (OSError, ValueError) as pidErr:
                    appLogger.debug('Error: %s', pidErr)
                    break
                time.sleep(0.1)

                appLogger.debug('---')

            if parentID != childID and childID:
                if self.compatV1:
                    self.mountHost(childID)
                break

        if i>timeLimit:
            raise RuntimeError('Failed to spawn child process to launch shell or run command.')

        readable = [sys.stdin, self.stdoutM]
        while True:

            self.running = True
            shouldContinue = self._shellFwdBck(interactiveProc, readable)

            if not shouldContinue:
                break
        self.running=False

        rc = interactiveProc.poll()

        appLogger.debug('Return Code: %s', rc)

        return rc

    def procState(self, pid):
        '''
        Return the state of a given PID in linux
        '''
        # Only on Linux
        for _line in open(f"/proc/{pid}/status", encoding='utf-8').readlines():
            if _line.startswith("State:"):
                entry = _line.split(":")[1].strip()
                value = entry.rstrip()[0]
                return value
        # Unknown
        return 'E'

    def _shellFwdBck(self, interactiveProc, readable):
        '''
        This is the component for handling sending data in/out of the pty
        '''

        try:
            # If the process is unknown or in a zombie state
            if self.procState(interactiveProc.pid) in ['Z', 'E']:
                return False
        except PermissionError as permissionErr:
            appLogger.debug('Error: %s', permissionErr)
            return False

	    # Poll for input/output
        if interactiveProc and interactiveProc.poll() is None:
            r, _w, _e = select.select(readable, [], [], 0.01)

            for _in in r:
                if _in is sys.stdin:
                    d = os.read(sys.stdin.fileno(), 10240)
                    #if d.decode() in ['\x04',]:
                    #    self._should_stop = True
                    #    return False
                    os.write(self.stdoutM, d)
                elif _in is self.stdoutM:
                    try:
                        o = os.read(self.stdoutM, 10240)
                    except OSError as e:
                        appLogger.debug('Error: %s', e)
                        return False
                    if o:
                        os.write(sys.stdout.fileno(), o)
                else:
                    raise RuntimeError('Help')
            return True
        else:
            return False


class appBoxManager():
    '''
    Class for general helper functions
    '''

    def setLogLevel(self, level):
        '''
        Set the log level of the global logger
        '''

        if level != logging.INFO:
            logging.basicConfig(level=level, format='%(levelname)s: %(message)s')
        else:
            logging.basicConfig(format='%(message)s')
        appLogger.setLevel(level)
        for handler in appLogger.handlers:
            handler.setLevel(level)



class cmdLineParser:
    '''
    Class for parsing command line arguments
    '''

    @staticmethod
    def getArgsParser():
        '''
        Parse the Args passed to this instance
        '''

        #class BlankLinesHelpFormatter(argparse.HelpFormatter):
        class blankLinesHelpFormatter(argparse.RawDescriptionHelpFormatter):
            '''
            Class to keep extra lines in help text
            '''
            def _split_lines(self, text, width):
                '''
                Keep the extra lines
                '''
                return super()._split_lines(text, width) + ['']

        un = getUN()
        epilog = f"""
------------------------------------------------------------------------------------------

Example Usage for this might be:
--------------------------------

# Usage 1 (Download, extract, setup then manuall source) #
##########################################################

RH> ./appBox -ii Ubuntu20 -ip /scratch/appBox_{un}/Ubuntu20
RH> source /scratch/appBox_{un}/Ubuntu20/bin/activate
...
Ubuntu>

# Usage 2 (Download, extract, setup and drop me into a root shell) #
####################################################################

RH7> ./appBox -ii docker://almalinux:9 -ip /scratch/appBox_{un}/AL9 -rar
...
RH9# dnf update -y
...

# Usage 3 (Download, ..., then run a command and exit) #
########################################################

RH7> ./appBox -ii Ubuntu22 -ip /scratch/appBox_{un}/Ubuntu22 -q -rcr 'echo /etc/os-release'
PRETTY_NAME="Ubuntu 22.04.4 LTS"
NAME="Ubuntu"
VERSION_ID="22.04"
VERSION="22.04.4 LTS (Jammy Jellyfish)"
VERSION_CODENAME=jammy
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=jammy
RH7> 

------------------------------------------------------------------------------------------

"""


        parser = argparse.ArgumentParser(
                        prog='appBox', formatter_class=blankLinesHelpFormatter,
        description='This is a tool to install a custom container as a sandbox like "virtualenv".',
                        epilog=epilog)

        parser.add_argument('-rc', '--run-command',
                            help='Run a given command inside a sandbox.')

        parser.add_argument('-rp', '--run-path',
        help='Path to look for an installed image (extracted sandbox) to use as a run-environment.')

        parser.add_argument('-rcr', '--run-command-root',
                            help='Run a given command AS ROOT inside a sandbox.')

        if os.path.exists('/scratch'):
            leadingPath = '/scratch'
        else:
            leadingPath = '/tmp'

        defaultRoot = f'{leadingPath}/appBox_{getUN()}/sandbox'

        #parser.add_argument('-ri', '--run-interactive',
        #                    type=str, default=default_root,
        #                    help='Launch a sandbox shell from this location.')

        #parser.add_argument('-rir', '--run-interactive-root',
        #                    type=str, default=default_root,
        #                    help='Launch a sandbox shell AS ROOT from this location.')

        #default_image = 'almalinux:9'
        defaultImage = 'centos:7'

        parser.add_argument('-ii', '--install-image',
                            default=defaultImage,
                help=f'Image to install, or short-hand of image from "{sys.argv[0]} -li"')

        parser.add_argument('-ip', '--install-path',
                            default=defaultRoot,
        help='Install path, path to "install" an image to on disk. (Path to extract to on disk)')

        parser.add_argument('-ra', '--run-after', action='store_true',
                            help='Should we drop into the new sandbox after installing.')

        parser.add_argument('-rar', '--run-after-root', action='store_true',
                            help='Should we drop into the new sandbox AS ROOT after installing.')

        #parser.add_argument('-li', '--list-images', action='store_true',
        #                    help='List suggested images to "install".')

        parser.add_argument('-q', '--quiet', action='store_true',
                            help='Quiet')

        parser.add_argument('-d', '--debug', action='store_true',
                            help='Debugging on.')

        #parser.add_argument('-ds', '--dump-settings', action='store_true',
        #                    help='Dump settings used by this instance.')

        parser.add_argument('-l', '--launch',
                            help='Launch Interactive environment from ...')

        parser.add_argument('-lr', '--launch-root',
                            help='Launch Interactive environment AS ROOT, from ...')

        parser.add_argument('-compat', '--compatV1', action='store_true',
            help='Use the older compatibility mode for the sandbox. Allows a CO8 host.')

        parser.add_argument('-addNV', '--add-nvidia', action='store_true',
                            help='Add the nvidia-smi binary to the sandbox.')

        parser.add_argument('-tmp', action='store_true',
                            help='The environment will be destroyed on exit. (Temporary Sandbox)')

        # Disabling the cvmfs tooling for now as it's not production ready/tested yet.
        #parser.add_argument('-cvmfs', '--use-cvmfs',
        #                    help='Use uncompressed image from this CVMFS path.')

        return parser


def runCommand(sandboxPath, command, asRoot, compatV1=False, addNV=False, rootfs=None):
    '''
    Run a command within a sandbox
    '''

    try:
        thisSandbox = sessionManager(sandboxPath, compatV1, addNV, rootfs)
        thisSandbox.setupHostSpace()

        if rootfs:
            thisSandbox.mountrootfs(rootfs)
            #time.sleep(1.0)

        thisSandbox.mountHost()

        theseFixes = sandboxFixes(addNV, thisSandbox)
        theseFixes.applyAllFixes()

        rc = thisSandbox.runCommand(command, asRoot)

        return rc

    except BaseException as globalErr: # pylint: disable=broad-except
        appLogger.error('Exception during running appBox Shell: %s', globalErr)
        thisSandbox.cleanupSpaces()
        if appLogger.level == logging.DEBUG:
            raise
        sys.exit(131)
    finally:
        thisSandbox.cleanupSpaces()


def main():
    '''
    Main :) Hello
    '''

    ### Parse our args and steer
    parser = cmdLineParser.getArgsParser()
    parsedArgs = parser.parse_args(sys.argv[1:])

    if parsedArgs.quiet:
        appBoxManager().setLogLevel(logging.ERROR)
    elif parsedArgs.debug:
        appBoxManager().setLogLevel(logging.DEBUG)
    else:
        appBoxManager().setLogLevel(logging.INFO)

    appLogger.debug('')
    appLogger.debug('Debugging Enabled. Jolan tru.')
    appLogger.debug('')


    commandToRun = None
    asRoot = False
    compatV1 = False
    wantedDest = None
    shouldRun = False
    needToInstall = False
    addNV = parsedArgs.add_nvidia

    lowerLayer = None

    if parsedArgs.compatV1:
        compatV1 = True

    wantedImage = parsedArgs.install_image
    if parsedArgs.install_path:
        wantedDest = parsedArgs.install_path
        needToInstall = True

    if parsedArgs.run_command:
        commandToRun = parsedArgs.run_command
        shouldRun = True
    if parsedArgs.run_command_root:
        commandToRun = parsedArgs.run_command_root
        asRoot = True
        shouldRun = True

    if parsedArgs.launch:
        wantedDest = parsedArgs.launch
        shouldRun = True
        wantedImage = None
    if parsedArgs.launch_root:
        wantedDest = parsedArgs.launch_root
        asRoot = True
        shouldRun = True
        wantedImage = None

    if parsedArgs.run_after:
        shouldRun = True
    if parsedArgs.run_after_root:
        asRoot = True
        shouldRun = True

    #if parsedArgs.use_cvmfs:
    #    lowerLayer = parsedArgs.use_cvmfs
    #    shouldRun = True
    #    #cvmfs_sandbox(parsedArgs.use_cvmfs, wantedDest, None, True)
    #    #sys.exit(-200)

    #if parsedArgs.run_interactive:
    #    wantedDest = parsedArgs.run_interactive
    #    shouldRun = True
    #if parsedArgs.run_interactive_root:
    #    wantedDest = parsedArgs.run_interactive_root
    #    asRoot = True
    #    shouldRun = True

    def platformDetection():
        platStr = platform.platform()
        detected = False
        for _str in ['centos-7', '3.10.', '4.18.0', ]:
            if _str in platStr:
                detected = True
                break
        return detected

    if platformDetection() and not compatV1:
        appLogger.warning('Detected older platform than EL9/UB22 defaulting to compatability mode.')
        appLogger.warning('You won\'t be able to use anonymous user-mapping for this session.')
        appLogger.warning('To disable this warning, use the -compat cmd arg.')
        compatV1 = True


    #image_manager = dockerRepo()
    ## Pull the image from the source to a temp folder
    #image_manager.pullImage('https://gitlab-registry.cern.ch/linuxsupport/alma9-base:latest')
    #image_manager.pullImage('linuxsupport/alma9-base')
    #image_manager = dockerRepo()
    # Pull the image from the source to a temp folder
    #image_manager.pullImage('cern/alma9-base')

    wantedDest = os.path.abspath(wantedDest)

    appLogger.debug('Looking in path: "%s"', wantedDest)

    if parsedArgs.run_path:
        wantedDest = parsedArgs.run_path
        shouldRun = True

    if not os.path.exists(wantedDest):
        appLogger.info('Sandbox: "%s" does not exist.', wantedDest)
        if not lowerLayer:
            if wantedImage is None:
                appLogger.error('Please install before trying to launch a sandbox.')
                sys.exit(132)
            appLogger.info('Installing: "%s" at "%s"', wantedImage, wantedDest)
            needToInstall = True
        else:
            appLogger.info('Using CVMFS: "%s"', lowerLayer)
            needToInstall = False


    rc = False
    if needToInstall and not lowerLayer and wantedImage:

        ## TODO
        ## Add some way of handling images from other sources
        ## This should identify docker images from docker://
        ## This will probably involve adding additional classes for Quay, Singularity, etc.
        ## Can safely default to assume most users just want a docker image

        # Construct Manager
        imageManager = dockerRepo()

        imageLower = wantedImage.lower()
        if wantedImage != imageLower:
            appLogger.debug('Changing search string to be lower-case! %s', imageLower)
            wantedImage = imageLower

        appLogger.debug('Looking for image: "%s"', wantedImage)

        # Pull the image from the source to a temp folder
        imageManager.pullImage(wantedImage)

        # Extract the image to the destination path
        try:

            rc = imageManager.buildSandbox(wantedImage, wantedDest)

        except PermissionError as permissionErr:
            appLogger.error('Permission Denied.')
            appLogger.error('Normally this means we don\'t have write access to: "%s"', wantedDest)
            appLogger.debug('Permission Error: %s', permissionErr)
            if appLogger.level == logging.DEBUG:
                raise permissionErr
            sys.exit(133)


    if shouldRun:

        # We now plan to run a command or launch a shell
        rc = runCommand(wantedDest, commandToRun, asRoot, compatV1, addNV, lowerLayer)
        if parsedArgs.tmp:
            shutil.rmtree(wantedDest)
        return rc

    sys.exit(0)


if __name__ == '__main__':
    try:
        RC = main()
    except KeyboardInterrupt as keyboardErr:
        if appLogger:
            appLogger.error('Aborting due to user request.')
            if appLogger.level == logging.DEBUG:
                print(keyboardErr)
        else:
            print('Aborting due to user request.')
        sys.exit(129)
    except BaseException as mainErr: # pylint: disable=broad-except
        if appLogger:
            appLogger.error('Exception: %s', mainErr)
            if appLogger.level == logging.DEBUG:
                raise
        else:
            print('Exception: %s', mainErr)
        sys.exit(130)
    sys.exit(RC)
